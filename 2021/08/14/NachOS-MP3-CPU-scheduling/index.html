<!DOCTYPE html>
<html lang="en" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="keywords" content="" />
  <meta name="author" content="Wendy" />
  <meta name="description" content="" />
  
  
  <title>
    
      NachOS MP3 - CPU scheduling 
      
      
      |
    
     Wendy
  </title>

  
    <link rel="apple-touch-icon" href="/images/favicon.png">
    <link rel="icon" href="/images/favicon.png">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  
<link rel="stylesheet" href="../../../../css/color-scheme.css">
<link rel="stylesheet" href="../../../../css/base.css">
<link rel="stylesheet" href="../../../../iconfont/iconfont.css">
<link rel="stylesheet" href="../../../../css/github-markdown.css">
<link rel="stylesheet" href="../../../../css/highlight.css">
<link rel="stylesheet" href="../../../../css/comments.css">


  <!-- jquery3.3.1 -->
  <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>

  <!-- fancybox -->
  <link href="https://cdn.bootcss.com/fancybox/3.5.2/jquery.fancybox.min.css" rel="stylesheet">
  <script async src="https://cdn.bootcss.com/fancybox/3.5.2/jquery.fancybox.min.js"></script>
  
<script src="../../../../js/fancybox.js"></script>


  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>

<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="atom.xml" title="Wendy" type="application/atom+xml">
</head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="/images/avatar.png" alt="">
      
    </a>
    <div class="nickname"><a href="/">Oranges</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">Home</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">Archives</a>
        </li>
      
        <li class="nav-item" data-path="/tags/">
          <a href="/tags/">Tags</a>
        </li>
      
        <li class="nav-item" data-path="/friends/">
          <a href="/friends/">Friends</a>
        </li>
      
        <li class="nav-item" data-path="/about/">
          <a href="/about/">About</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="../../../../js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->

<!-- LaTex Display -->
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>
<script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']]
  }
};
</script>



  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">NachOS MP3 - CPU scheduling</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime" title="Update time"></i>
          2021-08-14 22:49:56
        </span>
        
      </div>
      <div class="markdown-body">
        <h2 id="README"><a href="#README" class="headerlink" title="README"></a>README</h2><p>&#x9019;&#x662F;&#x6E05;&#x5927;&#x5468;&#x5FD7;&#x9060;&#x6559;&#x6388;&#x4F5C;&#x696D;&#x7CFB;&#x7D71;&#x7684;&#x4F5C;&#x696D;&#xFF0C;&#x6211;&#x5728;&#x7DB2;&#x8DEF;&#x4E0A;&#x627E;&#x5230;&#x9019;&#x4EFD;&#x4F5C;&#x696D;&#x7684;&#x76F8;&#x95DC;&#x8CC7;&#x6599;&#xFF0C;&#x6211;&#x4E26;&#x6C92;&#x6709;&#x4E0A;&#x904E;&#x9019;&#x9580;&#x8AB2;&#xFF0C;&#x9019;&#x53EA;&#x662F;&#x6211;&#x7684;&#x81EA;&#x5B78;&#x7DF4;&#x7FD2;&#xFF0C;&#x76EE;&#x524D;&#x6211;&#x9084;&#x6C92;&#x6709;&#x5B8C;&#x6210;&#x9019;&#x4EFD;&#x4F5C;&#x696D;&#x7684;&#x5BE6;&#x4F5C;&#x3002;</p>
<h2 id="Trace-code"><a href="#Trace-code" class="headerlink" title="Trace code"></a>Trace code</h2><h3 id="New-&#x2013;-gt-Ready"><a href="#New-&#x2013;-gt-Ready" class="headerlink" title="New &#x2013;&gt; Ready"></a>New &#x2013;&gt; Ready</h3><h4 id="1-Kernel-ExecAll"><a href="#1-Kernel-ExecAll" class="headerlink" title="1. Kernel::ExecAll()"></a>1. Kernel::ExecAll()</h4><p><strong>threads/kernel.cc&#x200B;</strong></p>
<p>&#x628A;&#x6240;&#x6709;&#x53EF;&#x57F7;&#x884C;&#x6A94;&#x4E1F;&#x9032; Exec &#x57F7;&#x884C;&#x3002;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kernel::ExecAll</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= execfileNum; i++) {</span><br><span class="line">        <span class="keyword">int</span> a = <span class="built_in">Exec</span>(execfile[i]);</span><br><span class="line">    }</span><br><span class="line">    currentThread-&gt;<span class="built_in">Finish</span>();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>thread &#x5B8C;&#x6210;&#x6240;&#x6709;&#x5DE5;&#x4F5C;&#x4E4B;&#x5F8C;&#xFF0C;&#x547C;&#x53EB; finish&#xFF0C;&#x5728;&#x63A7;&#x5236;&#x6B0A;&#x4EA4;&#x51FA;&#x53BB;&#x4E4B;&#x5F8C;&#xFF0C;&#x88AB; destroy&#x3002;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Thread::Finish</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    (<span class="keyword">void</span>) kernel-&gt;interrupt-&gt;<span class="built_in">SetLevel</span>(IntOff);		</span><br><span class="line">    <span class="built_in">Sleep</span>(TRUE); <span class="comment">/* invokes SWITCH */</span></span><br><span class="line">    <span class="comment">/* not reached */</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h4 id="2-int-Kernel-Exec-char-name"><a href="#2-int-Kernel-Exec-char-name" class="headerlink" title="2. int Kernel::Exec(char* name)"></a>2. int Kernel::Exec(char* name)</h4><p><strong>threads/kernel.cc&#x200B;</strong></p>
<p>&#x6BCF;&#x4E00;&#x500B;&#x53EF;&#x57F7;&#x884C;&#x6A94;&#x90FD;&#x9700;&#x8981; new &#x4E00;&#x500B;&#x65B0;&#x7684; thread &#x4F86;&#x57F7;&#x884C;&#x3002;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Kernel::Exec</span><span class="params">(<span class="keyword">char</span>* name)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    t[threadNum] = <span class="keyword">new</span> <span class="built_in">Thread</span>(name, threadNum);</span><br><span class="line">    t[threadNum]-&gt;space = <span class="keyword">new</span> <span class="built_in">AddrSpace</span>();</span><br><span class="line">    t[threadNum]-&gt;<span class="built_in">Fork</span>((VoidFunctionPtr)&amp;ForkExecute, </span><br><span class="line">                       (<span class="keyword">void</span>*)t[threadNum]);</span><br><span class="line">    threadNum++;</span><br><span class="line">    <span class="keyword">return</span> threadNum<span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h4 id="3-Thread-Fork-VoidFunctionPtr-void"><a href="#3-Thread-Fork-VoidFunctionPtr-void" class="headerlink" title="3. Thread::Fork(VoidFunctionPtr, void*)"></a>3. Thread::Fork(VoidFunctionPtr, void*)</h4><p><strong>threads/thread.cc</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Thread::Fork</span><span class="params">(VoidFunctionPtr func, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Interrupt *interrupt = kernel-&gt;interrupt;</span><br><span class="line">    Scheduler *scheduler = kernel-&gt;scheduler;</span><br><span class="line">    IntStatus oldLevel;</span><br><span class="line">    <span class="built_in">StackAllocate</span>(func, arg);</span><br><span class="line"></span><br><span class="line">    oldLevel = interrupt-&gt;<span class="built_in">SetLevel</span>(IntOff);</span><br><span class="line">    scheduler-&gt;<span class="built_in">ReadyToRun</span>(<span class="keyword">this</span>);</span><br><span class="line">    (<span class="keyword">void</span>) interrupt-&gt;<span class="built_in">SetLevel</span>(oldLevel);</span><br><span class="line">}   </span><br></pre></td></tr></table></figure>

<p>StackAllocate() &#x5EFA;&#x7ACB; thread stack &#x4EE5;&#x53CA;&#x521D;&#x59CB;&#x5316; machine register&#xFF0C;machine register &#x662F;&#x4E00;&#x500B; array&#xFF0C;NachOS &#x6703;&#x628A; machine register &#x5BEB;&#x5165;&#x4F60;&#x7684;&#x96FB;&#x8166;&#x88E1;&#x7684; CPU register&#xFF0C;&#x5373; host register&#xFF0C;&#x4ED6;&#x4E0D;&#x662F;&#x6A21;&#x64EC;&#x7684; register&#xFF0C;&#x4ED6;&#x662F;&#x771F;&#x7684;&#x6703;&#x628A;&#x9019;&#x4E9B;&#x503C;&#x5BEB;&#x9032;&#x4F60;&#x7684;&#x96FB;&#x8166;&#x7684; CPU register &#x88E1;&#x9762;&#xFF0C;&#x4E0D;&#x904E;&#x4E0D;&#x662F;&#x73FE;&#x5728;&#xFF0C;&#x662F;&#x5728;&#x505A; context switch &#x7684;&#x6642;&#x5019;&#x3002;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* threads/thread.cc */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Thread::StackAllocate</span> <span class="params">(VoidFunctionPtr func, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    stack = (<span class="keyword">int</span> *) <span class="built_in">AllocBoundedArray</span>(StackSize * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line">    ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> x86</span></span><br><span class="line">    stackTop = stack + StackSize - <span class="number">4</span>; <span class="comment">/* -4 to be on the safe side */</span></span><br><span class="line">    *(--stackTop) = (<span class="keyword">int</span>) ThreadRoot;</span><br><span class="line">    *stack = STACK_FENCEPOST;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> </span></span><br><span class="line">    ...</span><br><span class="line">    machineState[PCState] = (<span class="keyword">void</span>*)ThreadRoot;</span><br><span class="line">    machineState[StartupPCState] = (<span class="keyword">void</span>*)ThreadBegin;</span><br><span class="line">    machineState[InitialPCState] = (<span class="keyword">void</span>*)func;</span><br><span class="line">    machineState[InitialArgState] = (<span class="keyword">void</span>*)arg;</span><br><span class="line">    machineState[WhenDonePCState] = (<span class="keyword">void</span>*)ThreadFinish;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* lib/sysdep.cc */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">AllocBoundedArray</span><span class="params">(<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NO_MPROT</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">char</span>[size];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> x86</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* the offsets of the registers from the beginning of the thread object */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _ESP     0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _EAX     4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _EBX     8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _ECX     12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _EDX     16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _EBP     20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _ESI     24</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _EDI     28</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PC      32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* These definitions are used in Thread::AllocateStack(). */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCState         (_PC/4-1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FPState         (_EBP/4-1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InitialPCState  (_ESI/4-1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InitialArgState (_EDX/4-1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WhenDonePCState (_EDI/4-1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> StartupPCState  (_ECX/4-1)</span></span><br></pre></td></tr></table></figure>

<h4 id="5-void-Scheduler-ReadyToRun-Thread-thread"><a href="#5-void-Scheduler-ReadyToRun-Thread-thread" class="headerlink" title="5. void Scheduler::ReadyToRun (Thread *thread)"></a>5. void Scheduler::ReadyToRun (Thread *thread)</h4><p><strong>threads/scheduler.cc</strong></p>
<p>&#x5C07; thread &#x52A0;&#x5165; readyList&#xFF0C;&#x7576; scheduler &#x9700;&#x8981;&#x5B89;&#x6392; thread &#x4F86;&#x57F7;&#x884C;&#x7684;&#x6642;&#x5019;&#xFF0C;&#x5C31;&#x5F9E; readyList dequeue &#x4E00;&#x500B; thread &#x4F86;&#x57F7;&#x884C;&#x3002;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Scheduler::ReadyToRun</span> <span class="params">(Thread *thread)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    thread-&gt;<span class="built_in">setStatus</span>(READY);</span><br><span class="line">    readyList-&gt;<span class="built_in">Append</span>(thread);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scheduler</span> {</span></span><br><span class="line">    <span class="function">Thread* <span class="title">FindNextToRun</span><span class="params">()</span></span>;</span><br><span class="line">    List&lt;Thread *&gt; *readyList;	</span><br><span class="line">};</span><br></pre></td></tr></table></figure>

<h3 id="Running-&#x2013;-gt-Ready"><a href="#Running-&#x2013;-gt-Ready" class="headerlink" title="Running &#x2013;&gt; Ready"></a>Running &#x2013;&gt; Ready</h3><h4 id="1-void-Machine-Run"><a href="#1-void-Machine-Run" class="headerlink" title="1. void Machine::Run()"></a>1. void Machine::Run()</h4><p><strong>machine/mippsim.cc</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Machine::Run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/* storage for decoded instruction */</span></span><br><span class="line">    Instruction *instr = <span class="keyword">new</span> Instruction; /</span><br><span class="line"></span><br><span class="line">    kernel-&gt;interrupt-&gt;<span class="built_in">setStatus</span>(UserMode);</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="built_in">OneInstruction</span>(instr);</span><br><span class="line">        kernel-&gt;interrupt-&gt;<span class="built_in">OneTick</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h4 id="2-void-Interrupt-OneTick"><a href="#2-void-Interrupt-OneTick" class="headerlink" title="2. void Interrupt::OneTick()"></a>2. void Interrupt::OneTick()</h4><p><strong>machine/interrupt.cc</strong></p>
<p>Onetick() &#x5C07;&#x7CFB;&#x7D71;&#x6642;&#x9593;&#x63A8;&#x9032;&#x4E00;&#x500B;&#x55AE;&#x4F4D;&#xFF0C;&#x82E5;&#x6709; context switch &#x61C9;&#x8A72;&#x767C;&#x751F;&#xFF0C;&#x547C;&#x53EB; Yield()&#x3002;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Interrupt::OneTick</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    MachineStatus oldStatus = status;</span><br><span class="line">    Statistics *stats = kernel-&gt;stats;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status == SystemMode) {</span><br><span class="line">        stats-&gt;totalTicks += SystemTick;</span><br><span class="line">        stats-&gt;systemTicks += SystemTick;</span><br><span class="line">    } </span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        stats-&gt;totalTicks += UserTick;</span><br><span class="line">        stats-&gt;userTicks += UserTick;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check for pending interrupts */</span></span><br><span class="line">    <span class="built_in">CheckIfDue</span>(FALSE); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* if the timer device handler asked for a context switch, ok to do </span></span><br><span class="line"><span class="comment">     * it now */</span></span><br><span class="line">    <span class="keyword">if</span> (yieldOnReturn) {	</span><br><span class="line">        yieldOnReturn = FALSE;</span><br><span class="line">        status = SystemMode; <span class="comment">/* yield is a kernel routine */</span></span><br><span class="line">        kernel-&gt;currentThread-&gt;<span class="built_in">Yield</span>();</span><br><span class="line">        status = oldStatus;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interrupt</span> {</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> yieldOnReturn; 	<span class="comment">/* TRUE if we are to context switch */</span></span><br><span class="line">    MachineStatus status; <span class="comment">/* idle, kernel mode, user mode */</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h4 id="3-void-Thread-Yield"><a href="#3-void-Thread-Yield" class="headerlink" title="3. void Thread::Yield()"></a>3. void Thread::Yield()</h4><p><strong>threads/thread.cc</strong></p>
<p>currentThread &#x547C;&#x53EB; Yield() &#x628A;&#x63A7;&#x5236;&#x6B0A;&#x8B93;&#x7D66;&#x5176;&#x4ED6; thread&#xFF0C;&#x547C;&#x53EB; FindNextToRun() &#x4F86;&#x6C7A;&#x5B9A;&#x8981;&#x628A;&#x63A7;&#x5236;&#x6B0A;&#x8B93;&#x7D66;&#x54EA;&#x500B; thread&#xFF0C;&#x5728;&#x4EA4;&#x51FA;&#x63A7;&#x5236;&#x6B0A;&#x524D;&#x5148;&#x628A;&#x81EA;&#x5DF1; schedule &#x9032; readyList &#x88E1;&#x9762;&#xFF0C;&#x624D;&#x547C;&#x53EB; Run() &#x8B93; nextThread &#x958B;&#x59CB;&#x4F7F;&#x7528; CPU&#x3002;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Thread::Yield</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Thread *nextThread;</span><br><span class="line">    IntStatus oldLevel = kernel-&gt;interrupt-&gt;<span class="built_in">SetLevel</span>(IntOff);</span><br><span class="line">    </span><br><span class="line">    nextThread = kernel-&gt;scheduler-&gt;<span class="built_in">FindNextToRun</span>();</span><br><span class="line">    <span class="keyword">if</span> (nextThread != <span class="literal">NULL</span>) {</span><br><span class="line">        kernel-&gt;scheduler-&gt;<span class="built_in">ReadyToRun</span>(<span class="keyword">this</span>);</span><br><span class="line">        kernel-&gt;scheduler-&gt;<span class="built_in">Run</span>(nextThread, FALSE);</span><br><span class="line">    }</span><br><span class="line">    (<span class="keyword">void</span>) kernel-&gt;interrupt-&gt;<span class="built_in">SetLevel</span>(oldLevel);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h4 id="4-Thread-Scheduler-FindNextToRun"><a href="#4-Thread-Scheduler-FindNextToRun" class="headerlink" title="4. Thread *Scheduler::FindNextToRun()"></a>4. Thread *Scheduler::FindNextToRun()</h4><p><strong>threads/scheduler.cc</strong></p>
<p>&#x5F9E; readyList &#x53D6;&#x51FA;&#x6700;&#x524D;&#x9762;&#x7684; thread&#xFF0C;&#x662F;&#x4E0B;&#x4E00;&#x500B;&#x8981;&#x57F7;&#x884C;&#x7684; thread&#x3002;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Thread *<span class="title">Scheduler::FindNextToRun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (readyList-&gt;<span class="built_in">IsEmpty</span>()) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    } </span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> readyList-&gt;<span class="built_in">RemoveFront</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h4 id="5-void-Scheduler-ReadyToRun-Thread-thread-1"><a href="#5-void-Scheduler-ReadyToRun-Thread-thread-1" class="headerlink" title="5. void Scheduler::ReadyToRun(Thread *thread)"></a>5. void Scheduler::ReadyToRun(Thread *thread)</h4><p><strong>threads/scheduler.cc</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Scheduler::ReadyToRun</span><span class="params">(Thread *thread)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    thread-&gt;<span class="built_in">setStatus</span>(READY);</span><br><span class="line">    readyList-&gt;<span class="built_in">Append</span>(thread);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h4 id="6-void-Scheduler-Run-Thread-nextThread-bool-finishing"><a href="#6-void-Scheduler-Run-Thread-nextThread-bool-finishing" class="headerlink" title="6. void Scheduler::Run (Thread *nextThread, bool finishing)"></a>6. void Scheduler::Run (Thread *nextThread, bool finishing)</h4><p><strong>threads/scheduler.cc</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Scheduler::Run</span> <span class="params">(Thread *nextThread, <span class="keyword">bool</span> finishing)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Thread *oldThread = kernel-&gt;currentThread;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (finishing) {	</span><br><span class="line">        <span class="comment">/* mark that we need to delete old thread */</span></span><br><span class="line">        toBeDestroyed = oldThread;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldThread-&gt;space &#xFF01;= <span class="literal">NULL</span>) {	</span><br><span class="line">        <span class="comment">/* save the user&apos;s state */</span></span><br><span class="line">        oldThread-&gt;<span class="built_in">SaveUserState</span>();</span><br><span class="line">        oldThread-&gt;space-&gt;<span class="built_in">SaveState</span>();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    oldThread-&gt;<span class="built_in">CheckOverflow</span>();</span><br><span class="line">    <span class="comment">/* switch to the next thread */</span></span><br><span class="line">    kernel-&gt;currentThread = nextThread;      </span><br><span class="line">    <span class="comment">/* nextThread is now running */</span></span><br><span class="line">    nextThread-&gt;<span class="built_in">setStatus</span>(RUNNING);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This is a machine-dependent assembly language routine defined </span></span><br><span class="line"><span class="comment">     * in switch.s */</span></span><br><span class="line">    <span class="built_in">SWITCH</span>(oldThread, nextThread);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* we&apos;re back, running oldThread */</span></span><br><span class="line">    <span class="comment">/* check if thread we were running before this one has finished</span></span><br><span class="line"><span class="comment">     * and needs to be cleaned up */</span></span><br><span class="line">    <span class="built_in">CheckToBeDestroyed</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldThread-&gt;space != <span class="literal">NULL</span>) {	</span><br><span class="line">        <span class="comment">/* if there is an address space to restore, do it */</span></span><br><span class="line">        oldThread-&gt;<span class="built_in">RestoreUserState</span>();</span><br><span class="line">        oldThread-&gt;space-&gt;<span class="built_in">RestoreState</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>&#x5982;&#x679C; finishing &#x70BA;&#x771F;&#xFF0C;&#x4EE3;&#x8868; old thread &#x61C9;&#x8A72;&#x88AB; destroy&#xFF0C;&#x56E0;&#x70BA;&#x4E00;&#x500B; thread &#x4E0D;&#x80FD;&#x81EA;&#x5DF1; destroy &#x81EA;&#x5DF1;&#xFF0C;&#x56E0;&#x6B64;&#x8981;&#x7B49; context switch &#x4E4B;&#x5F8C;&#x8B93;&#x4E0B;&#x4E00;&#x500B; thread destroy old thread&#x3002;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (finishing) {	</span><br><span class="line">    <span class="comment">/* mark that we need to delete old thread */</span></span><br><span class="line">    toBeDestroyed = oldThread;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Scheduler::CheckToBeDestroyed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (toBeDestroyed != <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">delete</span> toBeDestroyed;</span><br><span class="line">        toBeDestroyed = <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>NachOS &#x6709;&#x5169;&#x5957; register&#xFF0C;&#x4E00;&#x5957;&#x662F; machineState&#xFF0C;&#x7528;&#x4F86;&#x5132;&#x5B58;&#x4F60;&#x7684;&#x96FB;&#x8166;&#x7684;&#x771F;&#x6B63;&#x7684; CPU register&#xFF0C;&#x5373; host register&#xFF0C;&#x53E6;&#x4E00;&#x5957; userRegisters &#x662F; NachOS &#x81EA;&#x5DF1;&#x6A21;&#x64EC;&#x7684; register&#xFF0C;&#x7528;&#x4F86;&#x5132;&#x5B58;&#x5728; OneInstruction() &#x6A21;&#x64EC;&#x6307;&#x4EE4;&#x57F7;&#x884C;&#x6642;&#x4F7F;&#x7528;&#x7684; register&#x3002;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldThread-&gt;space &#xFF01;= <span class="literal">NULL</span>) {	</span><br><span class="line">    <span class="comment">/* save the user&apos;s state */</span></span><br><span class="line">    oldThread-&gt;<span class="built_in">SaveUserState</span>();</span><br><span class="line">    oldThread-&gt;space-&gt;<span class="built_in">SaveState</span>();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Thread::SaveUserState</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NumTotalRegs; i++) {</span><br><span class="line">        userRegisters[i] = kernel-&gt;machine-&gt;<span class="built_in">ReadRegister</span>(i);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Machine::OneInstruction</span><span class="params">(Instruction *instr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* Execute the instruction */</span></span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (instr-&gt;opCode) {</span><br><span class="line">        <span class="keyword">case</span> OP_ADD:</span><br><span class="line">        <span class="comment">/* manipulate userRegisters */</span></span><br><span class="line">        sum = registers[instr-&gt;rs] + registers[instr-&gt;rt];</span><br><span class="line">        registers[instr-&gt;rd] = sum;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>&#x547C;&#x53EB; SWITCH() &#x9032;&#x884C; context switch&#xFF0C;&#x5728; SWITCH() &#x5B8C;&#x6210;&#x4E4B;&#x5F8C;&#xFF0C;&#x4E26;&#x4E0D;&#x6703;&#x7E7C;&#x7E8C;&#x57F7;&#x884C; Run() &#x7684;&#x4E0B;&#x4E00;&#x884C;&#xFF0C;&#x56E0;&#x70BA;&#x63A7;&#x5236;&#x6B0A;&#x5DF2;&#x7D93;&#x50B3;&#x7D66; nextThread&#xFF0C;&#x4E0B;&#x4E00;&#x884C;&#x8981;&#x88AB;&#x57F7;&#x884C;&#x7684;&#x6307;&#x4EE4;&#x662F; nextThread &#x7684;&#x6307;&#x4EE4;&#xFF0C;&#x7576; CheckToBeDestroyed() &#x88AB;&#x57F7;&#x884C;&#xFF0C;&#x4EE3;&#x8868;&#x5DF2;&#x7D93;&#x53C8;&#x8F2A;&#x5230;&#x9019;&#x500B; thread &#x4F7F;&#x7528; CPU&#xFF0C;&#x9019;&#x4E2D;&#x9593;&#x53EF;&#x80FD;&#x5DF2;&#x7D93;&#x5728;&#x597D;&#x5E7E;&#x500B; thread &#x4E4B;&#x9593; context  switch &#x597D;&#x5E7E;&#x6B21;&#x4E86;&#x3002;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SWITCH</span>(oldThread, nextThread);</span><br></pre></td></tr></table></figure>

<h3 id="SWITCH"><a href="#SWITCH" class="headerlink" title="SWITCH"></a>SWITCH</h3><h4 id="1-void-SWITCH-Thread-oldThread-Thread-newThread"><a href="#1-void-SWITCH-Thread-oldThread-Thread-newThread" class="headerlink" title="1. void SWITCH(Thread *oldThread, Thread *newThread)"></a>1. void SWITCH(Thread *oldThread, Thread *newThread)</h4><p><strong>threads/switch.S</strong></p>
<p>&#x547C;&#x53EB; SWITCH() &#x9032;&#x884C; context switch&#xFF0C;oldThread &#x7684;&#x57F7;&#x884C;&#x505C;&#x6B62;&#xFF0C;newThread &#x958B;&#x59CB;&#x57F7;&#x884C;&#x3002;&#x7576;&#x4E00;&#x500B; thread &#x7B2C;&#x4E00;&#x6B21;&#x547C;&#x53EB; SWITCH() &#x6642;&#xFF0C;&#x4ED6;&#x6703;&#x5148;&#x57F7;&#x884C; ThreadRoot&#xFF0C;SWITCH() &#x4EE5;&#x7D44;&#x8A9E;&#x7DE8;&#x5BEB;&#xFF0C;&#x6211;&#x5011;&#x5FC5;&#x9808;&#x5F9E; StackAllocate() &#x958B;&#x59CB; trace code &#x624D;&#x80FD;&#x77E5;&#x9053;&#x70BA;&#x4EC0;&#x9EBC;&#x7B2C;&#x4E00;&#x6B21;&#x547C;&#x53EB; SWITCH() &#x6642;&#x6703;&#x57F7;&#x884C; ThreadRoot&#x3002;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* threads/thread.h */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SWITCH</span><span class="params">(Thread *oldThread, Thread *newThread)</span></span>;</span><br></pre></td></tr></table></figure>

<p>StackAllocate() &#x5EFA;&#x7ACB; thread stack &#x4EE5;&#x53CA;&#x521D;&#x59CB;&#x5316; machine register &#x7684;&#x503C;&#x3002;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* threads/thread.cc */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Thread::StackAllocate</span> <span class="params">(VoidFunctionPtr func, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    stack = (<span class="keyword">int</span> *) <span class="built_in">AllocBoundedArray</span>(StackSize * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line">    ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> x86</span></span><br><span class="line">    stackTop = stack + StackSize - <span class="number">4</span>; <span class="comment">/* -4 to be on the safe side */</span></span><br><span class="line">    *(--stackTop) = (<span class="keyword">int</span>) ThreadRoot;</span><br><span class="line">    *stack = STACK_FENCEPOST;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> </span></span><br><span class="line">    ...</span><br><span class="line">    machineState[PCState] = (<span class="keyword">void</span>*)ThreadRoot;</span><br><span class="line">    machineState[StartupPCState] = (<span class="keyword">void</span>*)ThreadBegin;</span><br><span class="line">    machineState[InitialPCState] = (<span class="keyword">void</span>*)func;</span><br><span class="line">    machineState[InitialArgState] = (<span class="keyword">void</span>*)arg;</span><br><span class="line">    machineState[WhenDonePCState] = (<span class="keyword">void</span>*)ThreadFinish;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span> {</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* <span class="doctag">NOTE:</span> DO NOT CHANGE the order of these first two members.</span></span><br><span class="line"><span class="comment">     * THEY MUST be in this position for SWITCH to work. */</span></span><br><span class="line">    <span class="keyword">int</span> *stackTop;	 <span class="comment">/* the current stack pointer */</span></span><br><span class="line">    <span class="keyword">void</span> *machineState[MachineStateSize]; <span class="comment">/* all registers except for </span></span><br><span class="line"><span class="comment">                                           * stackTop */</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* threads/switch.h */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> x86</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* the offsets of the registers from the beginning of the thread object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _ESP     0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _EAX     4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _EBX     8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _ECX     12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _EDX     16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _EBP     20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _ESI     24</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _EDI     28</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PC      32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* These definitions are used in Thread::AllocateStack(). */</span></span><br><span class="line"><span class="comment">/* Translate from offset to machineState index */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCState         (_PC/4-1)  <span class="comment">/* 7 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FPState         (_EBP/4-1) <span class="comment">/* 1 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InitialPCState  (_ESI/4-1) <span class="comment">/* 5 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InitialArgState (_EDX/4-1) <span class="comment">/* 3 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WhenDonePCState (_EDI/4-1) <span class="comment">/* 6 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> StartupPCState  (_ECX/4-1) <span class="comment">/* 2 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InitialPC       %esi</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InitialArg      %edx</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WhenDonePC      %edi</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> StartupPC       %ecx</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// x86</span></span></span><br></pre></td></tr></table></figure>

<p>class Thread &#x7684;&#x8A3B;&#x89E3;&#x8981;&#x6C42;&#x6211;&#x5011;&#x4E0D;&#x80FD;&#x66F4;&#x52D5; stackTop &#x548C; machineState &#x7684;&#x9806;&#x5E8F;&#xFF0C;&#x76EE;&#x524D; Thread &#x7269;&#x4EF6;&#x7684;&#x8D77;&#x59CB;&#x4F4D;&#x7F6E;&#x548C; stackTop &#x7684; offset &#x70BA; 0&#xFF0C;&#x548C; machineState &#x7684;&#x8D77;&#x59CB;&#x4F4D;&#x7F6E; offset &#x70BA; 4&#xFF0C;&#x5982;&#x679C; offset &#x6709;&#x6240;&#x8B8A;&#x52D5;&#xFF0C;SWITCH() &#x7684;&#x5BE6;&#x505A;&#x5FC5;&#x9808;&#x6709;&#x76F8;&#x5C0D;&#x61C9;&#x7684;&#x8B8A;&#x52D5;&#x3002;&#x547C;&#x53EB; StackAllocate() &#x662F;&#x5C0D; Thread &#x7269;&#x4EF6;&#x9032;&#x884C;&#x521D;&#x59CB;&#x8A2D;&#x5B9A;&#xFF0C;&#x82E5;&#x6307;&#x5411; Thread &#x7269;&#x4EF6;&#x7684;&#x6307;&#x6A19;&#x70BA; t&#xFF0C;&#x4E0B;&#x5716;&#x662F;&#x547C;&#x53EB; StackAllocate() &#x5F8C; Thread &#x7269;&#x4EF6;&#x7684;&#x72C0;&#x614B;&#x3002;</p>
<table>
<thead>
<tr>
<th>address</th>
<th>thread member data</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>t + _ESP</td>
<td>stackTop</td>
<td></td>
</tr>
<tr>
<td>t + _EAX</td>
<td>machineState[0]</td>
<td></td>
</tr>
<tr>
<td>t + _EBX</td>
<td>machineState[1]</td>
<td></td>
</tr>
<tr>
<td>t + _ECX</td>
<td>machineState[2]</td>
<td>ThreadBegin</td>
</tr>
<tr>
<td>t + _EDX</td>
<td>machineState[3]</td>
<td>arg</td>
</tr>
<tr>
<td>t + _EBP</td>
<td>machineState[4]</td>
<td></td>
</tr>
<tr>
<td>t + _ESI</td>
<td>machineState[5]</td>
<td>ForkExecute</td>
</tr>
<tr>
<td>t + _EDI</td>
<td>machineState[6]</td>
<td>ThreadFinish</td>
</tr>
<tr>
<td>t + _PC</td>
<td>machineState[7]</td>
<td>ThreadRoot</td>
</tr>
</tbody></table>
<p>x86 &#x7684; compiler &#x6703;&#x5C07; c &#x8A9E;&#x8A00;&#x5C0D; SWITCH() &#x7684; function call &#x7DE8;&#x8B6F;&#x6210;&#x5148; push argument &#x548C; return address&#xFF0C;&#x518D;&#x8DF3;&#x5230; assembly &#x88E1; SWITCH &#x7684; label&#xFF0C;&#x6B64;&#x6642; stack &#x7684;&#x5167;&#x5BB9;&#x5982;&#x4E0B;&#x3002;</p>
<table>
<thead>
<tr>
<th>address</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>stack pointer + 8</td>
<td>new thread *t2</td>
</tr>
<tr>
<td>stack pointer + 4</td>
<td>old thread *t1</td>
</tr>
<tr>
<td>stack pointer</td>
<td>return address</td>
</tr>
</tbody></table>
<p>&#x6211;&#x5011;&#x547C;&#x53EB; SWITCH() &#x662F;&#x70BA;&#x4E86;&#x9032;&#x884C; context switch&#xFF0C;SWITCH() &#x7684;&#x5BE6;&#x505A;&#x662F;&#x4FDD;&#x5B58;&#x7576;&#x4E0B; host register &#x5167;&#x5BB9;&#xFF0C;&#x4E26;&#x8F09;&#x5165;&#x4E0B;&#x4E00;&#x500B;&#x8981;&#x57F7;&#x884C;&#x7684; thread &#x7684; host register&#x3002;&#x6211;&#x5011;&#x5C07;&#x7576;&#x4E0B;&#x7684; host register &#x5167;&#x5BB9;&#x4FDD;&#x5B58;&#x5728;&#x7269;&#x4EF6; thread &#x88E1;&#x7684; stackTop &#x548C; machineState&#xFF0C;&#x5C07;&#x4E0B;&#x4E00;&#x500B;&#x8981;&#x57F7;&#x884C;&#x7684; thread&#x7269;&#x4EF6;&#x7684; stackTop &#x548C; machineState &#x8F09;&#x5165; register&#x3002;&#x89C0;&#x5BDF; SWITCH &#x7D44;&#x8A9E;&#xFF0C;&#x53EF;&#x4EE5;&#x770B;&#x5230;&#x6211;&#x5011;&#x6709; 8 &#x500B; register &#x9700;&#x8981;&#x88AB;&#x4FDD;&#x5B58;&#xFF0C;&#x9664;&#x4E86;&#x9019; 8 &#x500B; register &#x4E4B;&#x5916;&#xFF0C;&#x9084;&#x8981;&#x4FDD;&#x5B58; return address&#xFF0C;return address &#x653E;&#x5728;&#x4F4D;&#x5740; (%esp)&#xFF0C;&#x4E0D;&#x662F;&#x653E;&#x5728; register esp&#xFF0C;&#x662F;&#x653E;&#x5728;&#x8A18;&#x61B6;&#x9AD4;&#x4F4D;&#x5740; (%esp)&#xFF0C;&#x56E0;&#x70BA; register esp &#x653E;&#x7684;&#x662F; stack pointer&#xFF0C;&#x800C; return address &#x662F;&#x653E;&#x5728; stack &#x88E1;&#x3002;</p>
<p>&#x5FC5;&#x9808;&#x7279;&#x5225;&#x8AAA;&#x660E;&#x7684;&#x662F;&#xFF0C;SWITCH() &#x6240;&#x64CD;&#x4F5C;&#x7684; machineState &#x662F; host register&#xFF0C;&#x81F3;&#x65BC;&#x70BA;&#x4EC0;&#x9EBC; context switch &#x9700;&#x8981;&#x5207;&#x63DB; host register&#xFF0C;&#x6211;&#x4E0D;&#x77E5;&#x9053;&#xFF0C;&#x56E0;&#x70BA;&#x6211;&#x500B;&#x4EBA;&#x7406;&#x89E3;&#x61C9;&#x8A72;&#x53EA;&#x8981;&#x5207;&#x63DB; userRegister &#x5C31;&#x53EF;&#x4EE5;&#x4E86;&#x3002;&#x6211;&#x539F;&#x672C;&#x7684;&#x731C;&#x6E2C;&#xFF0C;&#x5982;&#x679C; NachOS &#x6703;&#x5728; guest instruction &#x57F7;&#x884C;&#x5230;&#x4E00;&#x534A;&#x7684;&#x6642;&#x5019;&#x9032;&#x884C; context switch&#xFF0C;&#x78BA;&#x5BE6;&#x6703;&#x9700;&#x8981;&#x628A; host &#x7684;&#x72C0;&#x614B;&#x4E5F;&#x4FDD;&#x7559;&#x4E0B;&#x4F86;&#xFF0C;&#x4F46;&#x6211;&#x76EE;&#x524D; trace code &#x7684;&#x7D50;&#x679C;&#xFF0C;context switch &#x90FD;&#x6703;&#x5728;&#x4E00;&#x500B;&#x6307;&#x4EE4;&#x5B8C;&#x6574;&#x5B8C;&#x6210;&#x4E4B;&#x5F8C;&#x624D;&#x6703;&#x9032;&#x884C;&#xFF0C;&#x6240;&#x4EE5;&#x6211;&#x771F;&#x7684;&#x60F3;&#x4E0D;&#x5230;&#x6709;&#x4EC0;&#x9EBC;&#x539F;&#x56E0;&#x9808;&#x8981;&#x5207;&#x63DB; host register&#x3002;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">    .comm   _eax_save,4 # _eax_save is a 4 byte data </span><br><span class="line">    </span><br><span class="line">    .globl  SWITCH</span><br><span class="line">    .globl  _SWITCH</span><br><span class="line">_SWITCH:		</span><br><span class="line">SWITCH:</span><br><span class="line">        movl    %eax,_eax_save   # save the value of eax to _eax_save</span><br><span class="line">        movl    4(%esp),%eax     # move pointer to t1 into eax</span><br><span class="line">        movl    %ebx,_EBX(%eax)  # save ebx to machineState[1] of t1</span><br><span class="line">        movl    %ecx,_ECX(%eax)  # save ecx to machineState[2] of t1</span><br><span class="line">        movl    %edx,_EDX(%eax)  # save edx to machineState[3] of t1</span><br><span class="line">        movl    %esi,_ESI(%eax)  # save esi to machineState[5] of t1</span><br><span class="line">        movl    %edi,_EDI(%eax)  # save edi to machineState[6] of t1</span><br><span class="line">        movl    %ebp,_EBP(%eax)  # save ebp to machineState[4] of t1</span><br><span class="line">        movl    %esp,_ESP(%eax)  # save esp to stackTop of t1</span><br><span class="line">        movl    _eax_save,%ebx   # save the value of _eax_save to ebx</span><br><span class="line">        movl    %ebx,_EAX(%eax)  # save ebx to machineState[0] of t1</span><br><span class="line">        movl    0(%esp),%ebx     # get return address from stack into ebx</span><br><span class="line">        movl    %ebx,_PC(%eax)   # save return address to machineState[7]</span><br><span class="line">                                 # of t1</span><br><span class="line"></span><br><span class="line">        movl    8(%esp),%eax     # move pointer to t2 into eax</span><br><span class="line">        movl    _EAX(%eax),%ebx  # restore machineState[0] of t2 to ebx</span><br><span class="line">        movl    %ebx,_eax_save   # save the value of ebx to _eax_save</span><br><span class="line">        movl    _EBX(%eax),%ebx  # restore machineState[1] of t2 to ebx</span><br><span class="line">        movl    _ECX(%eax),%ecx  # restore machineState[2] of t2 to ecx</span><br><span class="line">        movl    _EDX(%eax),%edx  # restore machineState[3] of t2 to edx</span><br><span class="line">        movl    _ESI(%eax),%esi  # restore machineState[5] of t2 to esi</span><br><span class="line">        movl    _EDI(%eax),%edi  # restore machineState[6] of t2 to edi</span><br><span class="line">        movl    _EBP(%eax),%ebp  # restore machineState[4] of t2 to ebp</span><br><span class="line">        movl    _ESP(%eax),%esp  # restore stackTop of t2 to esp</span><br><span class="line">        movl    _PC(%eax),%eax   # restore return address into eax</span><br><span class="line">        movl    %eax,4(%esp)     # copy over the ret address on the stack</span><br><span class="line">        movl    _eax_save,%eax   # save the value of _eax_save to eax</span><br><span class="line"></span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>

<p>&#x5728;&#x8F09;&#x5165;&#x4E0B;&#x4E00;&#x500B;&#x8981;&#x57F7;&#x884C;&#x7684; thread &#x7684; register &#x4E4B;&#x5F8C;&#xFF0C;return address &#x88AB;&#x8986;&#x5BEB;&#xFF0C;&#x56E0;&#x6B64;&#x5728; SWITCH() &#x7D50;&#x675F;&#x4E4B;&#x5F8C;&#xFF0C;&#x4E0D;&#x6703; return &#x56DE;&#x539F;&#x672C;&#x7684; thread&#xFF0C;&#x800C;&#x662F; return &#x56DE;&#x4E0B;&#x4E00;&#x500B;&#x8981;&#x57F7;&#x884C;&#x7684; thread&#xFF0C;&#x5982;&#x6B64;&#x4E00;&#x500B; context switch &#x5373;&#x5B8C;&#x6210;&#x3002;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movl    %eax,4(%esp)     # copy over the ret address on the stack</span><br></pre></td></tr></table></figure>

<p>&#x4EE5;&#x6211;&#x7684;&#x7406;&#x89E3;&#xFF0C;&#x7576; SWITCH() &#x9032;&#x884C;&#x5230;&#x7D44;&#x8A9E; ret &#x6642;&#x6703; return &#x56DE;&#x4F4D;&#x5740; %esp&#xFF0C;&#x56E0;&#x6B64;&#x5728;&#x8986;&#x5BEB; return address &#x6642;&#x61C9;&#x8A72;&#x5BEB;&#x5230;&#x4F4D;&#x5740; %esp&#xFF0C;&#x4F46;&#x5728;&#x9019;&#x88E1;&#x4ED6;&#x5BEB;&#x5230;&#x4F4D;&#x5740; 4(%esp)&#xFF0C;&#x6211;&#x5341;&#x5206;&#x56F0;&#x60D1;&#x3002;&#x4EE5;&#x4E0B;&#x7D14;&#x5C6C;&#x6211;&#x500B;&#x4EBA;&#x731C;&#x6E2C;&#xFF0C;&#x5C0D;&#x7167; SWITCH &#x7684;&#x8A3B;&#x89E3;&#xFF0C;&#x6216;&#x8A31; <code>movl %eax,_eax_save</code>&#xFF0C;&#x6703;&#x4F7F;&#x5F97; _eax_save &#x88AB; push &#x9032; stack&#xFF0C;&#x800C; <code>movl _eax_save,%ebx</code>&#xFF0C;&#x6703;&#x4F7F;&#x5F97; _eax_save &#x88AB; pop &#x51FA; stack&#x3002;&#x5982;&#x679C;&#x9019;&#x500B;&#x63A8;&#x6E2C;&#x5C6C;&#x5BE6;&#xFF0C;&#x5C31;&#x53EF;&#x4EE5;&#x89E3;&#x91CB;&#x70BA;&#x4EC0;&#x9EBC;&#x5728;&#x8986;&#x5BEB; return address &#x6642;&#x6703;&#x4F7F;&#x7528; %eax,4(%esp)&#xFF0C;&#x56E0;&#x70BA;&#x6B64;&#x6642; (%esp) &#x6307;&#x5411;&#x525B; push &#x9032;&#x53BB;&#x7684; _eax_save&#xFF0C;4(%esp) &#x624D;&#x6307;&#x5411; return address&#xFF0C;&#x5728; ret &#x524D;&#x7684;&#x6700;&#x5F8C;&#x4E00;&#x500B;&#x6307;&#x4EE4; <code>movl _eax_save,%eax</code>&#xFF0C;&#x5982;&#x679C;&#x5982;&#x6211;&#x5011;&#x731C;&#x6E2C;&#x7684;&#x5C07; _eax_save pop &#x51FA; stack&#xFF0C;&#x5247;&#x6B64;&#x6642; (%esp) &#x53C8;&#x5C07;&#x662F;&#x6307;&#x5411; return address&#xFF0C;&#x53EF;&#x4EE5;&#x9806;&#x5229;&#x5B8C;&#x6210; context switch&#xFF0C;&#x4EE5;&#x4E0A;&#x7D14;&#x5C6C;&#x6211;&#x500B;&#x4EBA;&#x731C;&#x6E2C;&#xFF0C;&#x56E0;&#x70BA;&#x6211;&#x627E;&#x4E0D;&#x5230;&#x8B49;&#x64DA;&#x6216;&#x662F;&#x5176;&#x4ED6;&#x89E3;&#x91CB;&#x3002;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* threads/switch.s */</span><br><span class="line"></span><br><span class="line">/* we push the current eax on the stack so that we can use it as</span><br><span class="line"> * a pointer to t1, this decrements esp by 4, so when we use it</span><br><span class="line"> * to reference stuff on the stack, we add 4 to the offset. */</span><br></pre></td></tr></table></figure>

<h4 id="2-void-ThreadRoot"><a href="#2-void-ThreadRoot" class="headerlink" title="2. void ThreadRoot();"></a>2. void ThreadRoot();</h4><p><strong>threads/switch.S</strong></p>
<p>&#x7576;&#x4E00;&#x500B; thread &#x7B2C;&#x4E00;&#x6B21;&#x53D6;&#x5F97;&#x63A7;&#x5236;&#x6B0A;&#xFF0C;&#x4ED6;&#x4E4B;&#x524D;&#x6C92;&#x6709;&#x57F7;&#x884C;&#x904E;&#x4EFB;&#x4F55;&#x6771;&#x897F;&#xFF0C;&#x90A3;&#x4ED6;&#x61C9;&#x8A72;&#x8981; return &#x56DE;&#x54EA;&#x88E1;&#x5462;&#xFF0C;&#x5728;&#x547C;&#x53EB; StackAllocate() &#x6642;&#x6240;&#x505A;&#x7684;&#x521D;&#x59CB;&#x5316;&#xFF0C;&#x5DF2;&#x7D93;&#x6307;&#x5B9A;&#x7576;&#x4E00;&#x500B; thread &#x7B2C;&#x4E00;&#x6B21;&#x53D6;&#x5F97;&#x63A7;&#x5236;&#x6B0A;&#x6642;&#xFF0C;&#x4ED6;&#x6703; return &#x5230; ThreadRoot&#xFF0C;&#x4E5F;&#x5C31;&#x662F;&#x4ED6;&#x6703;&#x53BB;&#x57F7;&#x884C; ThreadRoot&#xFF0C;&#x56E0;&#x6B64;&#x6211;&#x5011;&#x63A5;&#x4E0B;&#x4F86;&#x8981;&#x770B;&#xFF0C;ThreadRoot &#x6703;&#x505A;&#x54EA;&#x4E9B;&#x4E8B;&#x60C5;&#x3002;</p>
<table>
<thead>
<tr>
<th>register</th>
<th>offset</th>
<th>thread member data</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>ecx</td>
<td>t + _ECX</td>
<td>machineState[2]</td>
<td>ThreadBegin</td>
</tr>
<tr>
<td>edx</td>
<td>t + _EDX</td>
<td>machineState[3]</td>
<td>arg</td>
</tr>
<tr>
<td>esi</td>
<td>t + _ESI</td>
<td>machineState[5]</td>
<td>ForkExecute</td>
</tr>
<tr>
<td>edi</td>
<td>t + _EDI</td>
<td>machineState[6]</td>
<td>ThreadFinish</td>
</tr>
<tr>
<td></td>
<td>t + _PC</td>
<td>machineState[7]</td>
<td>ThreadRoot</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* threads/thread.cc */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* func - &amp;ForkExecute */</span></span><br><span class="line"><span class="comment">/* arg - (void*)t[threadNum] */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Thread::StackAllocate</span> <span class="params">(VoidFunctionPtr func, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">     ...     </span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>ThreadRoot &#x5148;&#x628A; arg push &#x9032; stack&#xFF0C;&#x63A5;&#x8457;&#x547C;&#x53EB; ThreadBegin()&#xFF0C;&#x547C;&#x53EB; ForkExecute()&#xFF0C;&#x547C;&#x53EB; ThreadFinish()&#x3002;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#define InitialPC       %esi</span><br><span class="line">#define InitialArg      %edx</span><br><span class="line">#define WhenDonePC      %edi</span><br><span class="line">#define StartupPC       %ecx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    .globl  ThreadRoot</span><br><span class="line">    .globl  _ThreadRoot	</span><br><span class="line"></span><br><span class="line">_ThreadRoot:	</span><br><span class="line">ThreadRoot:</span><br><span class="line">        pushl   %ebp         # push value of %ebp to stack</span><br><span class="line">        movl    %esp,%ebp    # move %esp to %ebp </span><br><span class="line">        pushl   InitialArg   # push value of %edx to stack</span><br><span class="line">        call    *StartupPC   # push return address to stack, then set CPU</span><br><span class="line">                               program counter %ecx</span><br><span class="line">        call    *InitialPC   # push return address to stack, then set CPU</span><br><span class="line">                             # program counter %esi</span><br><span class="line">        call    *WhenDonePC  # push return address to stack, then set CPU</span><br><span class="line">                             # program counter %edi</span><br><span class="line"></span><br><span class="line">        # NOT REACHED</span><br><span class="line">        movl    %ebp,%esp</span><br><span class="line">        popl    %ebp</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>

<h4 id="3-static-void-ThreadBegin"><a href="#3-static-void-ThreadBegin" class="headerlink" title="3. static void ThreadBegin()"></a>3. static void ThreadBegin()</h4><p><strong>threads/thread.cc</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* deallocate the previously running thread if it finished. */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ThreadBegin</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line">    kernel-&gt;currentThread-&gt;<span class="built_in">Begin</span>(); </span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Thread::Begin</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{    </span><br><span class="line">    kernel-&gt;scheduler-&gt;<span class="built_in">CheckToBeDestroyed</span>();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If the old thread gave up the processor because it was finishing,</span></span><br><span class="line"><span class="comment"> * we need to delete its carcass. */</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Scheduler::CheckToBeDestroyed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (toBeDestroyed != <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">delete</span> toBeDestroyed;</span><br><span class="line">        toBeDestroyed = <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h4 id="4-void-ForkExecute-Thread-t"><a href="#4-void-ForkExecute-Thread-t" class="headerlink" title="4. void ForkExecute(Thread *t)"></a>4. void ForkExecute(Thread *t)</h4><p><strong>threads/kernel.cc</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ForkExecute</span><span class="params">(Thread *t)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/* load executable file from file to memory &amp; </span></span><br><span class="line"><span class="comment">     * allocate pageTable for this thread */</span></span><br><span class="line">    <span class="keyword">if</span> (!t-&gt;space-&gt;<span class="built_in">Load</span>(t-&gt;<span class="built_in">getName</span>())) {</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">/* executable not found */</span></span><br><span class="line">    }</span><br><span class="line">    t-&gt;space-&gt;<span class="built_in">Execute</span>(t-&gt;<span class="built_in">getName</span>());</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">AddrSpace::Execute</span><span class="params">(<span class="keyword">char</span>* fileName)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    kernel-&gt;currentThread-&gt;space = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">InitRegisters</span>(); <span class="comment">/* initialize user register */</span> </span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">RestoreState</span>(); <span class="comment">/* load page table register */</span></span><br><span class="line">    kernel-&gt;machine-&gt;<span class="built_in">Run</span>(); <span class="comment">/*  jump to the user program */</span></span><br><span class="line">    <span class="built_in">ASSERTNOTREACHED</span>(); <span class="comment">/*  machine-&gt;Run never returns; */</span>			</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h4 id="5-static-void-ThreadFinish"><a href="#5-static-void-ThreadFinish" class="headerlink" title="5. static void ThreadFinish()"></a>5. static void ThreadFinish()</h4><p><strong>threads/thread.cc</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* called by ThreadRoot when a thread is done executing the forked</span></span><br><span class="line"><span class="comment"> * procedure. */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ThreadFinish</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line">    kernel-&gt;currentThread-&gt;<span class="built_in">Finish</span>(); </span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Thread::Finish</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">Sleep</span>(TRUE); <span class="comment">/* invokes SWITCH */</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h3 id="Running-&#x2013;-gt-Waiting"><a href="#Running-&#x2013;-gt-Waiting" class="headerlink" title="Running &#x2013;&gt; Waiting"></a>Running &#x2013;&gt; Waiting</h3><h4 id="1-void-SynchConsoleOutput-PutChar-char-ch"><a href="#1-void-SynchConsoleOutput-PutChar-char-ch" class="headerlink" title="1. void SynchConsoleOutput::PutChar(char ch)"></a>1. void SynchConsoleOutput::PutChar(char ch)</h4><p><strong>userporg/synchconsole.cc</strong></p>
<p>&#x53EA;&#x6709;&#x4E00;&#x500B; console&#xFF0C;&#x56E0;&#x6B64;&#x5FC5;&#x9808;&#x8981; sync&#xFF0C;&#x8F38;&#x51FA;&#x7684;&#x904E;&#x7A0B;&#x662F; critical section&#xFF0C;&#x4E00;&#x6B21;&#x53EA;&#x80FD;&#x6709;&#x4E00;&#x500B; thread &#x505A; console output&#xFF0C;schedule &#x5B8C;&#x8F38;&#x51FA;&#x4E4B;&#x5F8C;&#x624D;&#x80FD; release lock &#x8B93;&#x5225;&#x7684; thread &#x4E5F;&#x80FD;&#x53BB;&#x505A;&#x8F38;&#x51FA;&#x3002;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SynchConsoleOutput::PutChar</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    lock-&gt;<span class="built_in">Acquire</span>();</span><br><span class="line">    consoleOutput-&gt;<span class="built_in">PutChar</span>(ch);</span><br><span class="line">    waitFor-&gt;<span class="built_in">P</span>();</span><br><span class="line">    lock-&gt;<span class="built_in">Release</span>();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h4 id="2-ConsoleOutput-PutChar"><a href="#2-ConsoleOutput-PutChar" class="headerlink" title="2. ConsoleOutput::PutChar()"></a>2. ConsoleOutput::PutChar()</h4><p><strong>machine/console.cc</strong></p>
<p>&#x547C;&#x53EB; WriteFile() &#x5C0D;&#x87A2;&#x5E55;&#x9032;&#x884C;&#x8F38;&#x51FA;&#xFF0C;&#x547C;&#x53EB; Schedule() &#x6A21;&#x64EC;&#x87A2;&#x5E55;&#x5B8C;&#x6210;&#x8F38;&#x51FA;&#x5F8C;&#x767C;&#x51FA; interrupt&#x3002;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConsoleOutput::PutChar</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">WriteFile</span>(writeFileNo, &amp;ch, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>));</span><br><span class="line">    kernel-&gt;interrupt-&gt;<span class="built_in">Schedule</span>(<span class="keyword">this</span>, ConsoleTime, ConsoleWriteInt);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>WriteFile() &#x7684;&#x5BE6;&#x505A;&#x662F;&#x547C;&#x53EB; linux &#x63D0;&#x4F9B;&#x7684; write()&#xFF0C;fd &#x662F;&#x88AB;&#x5BEB;&#x5165;&#x6A94;&#x6848;&#x7684; file descriptor&#xFF0C;writeFileNo &#x7684;&#x503C;&#x5728; console.cc &#x4E2D;&#x88AB; assign &#x70BA; 1&#x3002; &#x5728; linux &#x7CFB;&#x7D71;&#x4E2D;&#xFF0C;file descriptor &#x70BA; 1 &#x5373;&#x662F; stdout&#xFF0C;&#x5B57;&#x5143;&#x6703;&#x88AB;&#x8F38;&#x51FA;&#x5230;&#x87A2;&#x5E55;&#x3002;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* lib/sysdep.cc */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WriteFile</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *buffer, <span class="keyword">int</span> nBytes)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> retVal = <span class="built_in">write</span>(fd, buffer, nBytes);</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>&#x4E00;&#x500B;&#x771F;&#x6B63;&#x7684;&#x4F5C;&#x696D;&#x7CFB;&#x7D71;&#x6703;&#x5728;&#x8F38;&#x51FA;&#x5B8C;&#x6210;&#x7684;&#x6642;&#x5019;&#x767C;&#x51FA; interrupt&#xFF0C;&#x7531;&#x65BC;&#x9019;&#x4E0D;&#x662F;&#x771F;&#x7684;&#x4F5C;&#x696D;&#x7CFB;&#x7D71;&#xFF0C;&#x6240;&#x4EE5;&#x4ED6;&#x53EA;&#x80FD;&#x9810;&#x4F30;&#x8F38;&#x51FA;&#x6642;&#x9593;&#x7136;&#x5F8C;&#x81EA;&#x5DF1;&#x767C;&#x51FA; interrupt &#x3002;NachOS &#x9810;&#x4F30;&#x5B57;&#x5143;&#x8F38;&#x51FA;&#x9700;&#x8981; 100 &#x55AE;&#x4F4D;&#x6642;&#x9593;&#xFF0C;&#x56E0;&#x6B64;&#x5B89;&#x6392;&#x5728; 100 &#x500B;&#x55AE;&#x4F4D;&#x6642;&#x9593;&#x5F8C;&#x767C;&#x51FA; interrupt &#x3002;&#x95DC;&#x9375;&#x5B57; this &#x901A;&#x5E38;&#x88AB;&#x7528;&#x5728;&#x4E00;&#x500B; class &#x5167;&#x90E8;&#xFF0C;this &#x662F;&#x4E00;&#x500B;&#x6307;&#x6A19;&#xFF0C;&#x6307;&#x5411;&#x6B63;&#x5728;&#x88AB;&#x57F7;&#x884C;&#x7684; class &#x7684;&#x7269;&#x4EF6;&#xFF0C;&#x56E0;&#x6B64; this &#x662F; ConsoleOutput&#x3002;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel-&gt;interrupt-&gt;<span class="built_in">Schedule</span>(<span class="keyword">this</span>, ConsoleTime, ConsoleWriteInt);</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* machine/stats.h */</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ConsoleTime =	<span class="number">100</span>; <span class="comment">/* time to read or write one character */</span></span><br></pre></td></tr></table></figure>

<p>IntType &#x7D00;&#x9304;&#x9019;&#x500B; interrupt &#x662F;&#x7531;&#x54EA;&#x500B;&#x786C;&#x9AD4;&#x767C;&#x51FA;&#xFF0C;NachOS&#x652F;&#x63F4;&#x516D;&#x7A2E;&#x786C;&#x9AD4;&#x76F8;&#x95DC; interrupt&#x3002;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* machine/interrupt.h */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IntType</span> {</span> TimerInt, DiskInt, ConsoleWriteInt, ConsoleReadInt, </span><br><span class="line">               NetworkSendInt, NetworkRecvInt};</span><br></pre></td></tr></table></figure>

<p>writeFileNo &#x7684;&#x503C;&#x5728; console.cc &#x4E2D;&#x88AB; assign &#x70BA; 1&#x3002;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* machine/console.cc */</span></span><br><span class="line"></span><br><span class="line">ConsoleOutput::<span class="built_in">ConsoleOutput</span>(<span class="keyword">char</span> *writeFile, CallBackObj *toCall)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (writeFile == <span class="literal">NULL</span>) {</span><br><span class="line">        writeFileNo = <span class="number">1</span>;</span><br><span class="line">    }			</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        writeFileNo = <span class="built_in">OpenForWrite</span>(writeFile);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* threads/kernel.cc */</span></span><br><span class="line"></span><br><span class="line">synchConsoleOut = <span class="keyword">new</span> <span class="built_in">SynchConsoleOutput</span>(consoleOut);</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* threads/kernel.cc */</span></span><br><span class="line"></span><br><span class="line">consoleOut = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<h4 id="3-void-Semaphore-P"><a href="#3-void-Semaphore-P" class="headerlink" title="3. void Semaphore::P()"></a>3. void Semaphore::P()</h4><p><strong>threads/synch.cc</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* threads/synch.h */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">P</span><span class="params">()</span></span>; <span class="comment">/* waits until value &gt; 0, then decrement */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">V</span><span class="params">()</span></span>; <span class="comment">/* increment, waking up a thread waiting in P() if </span></span><br><span class="line"><span class="comment">               * necessary */</span></span><br><span class="line"><span class="keyword">private</span>:      </span><br><span class="line">    <span class="keyword">int</span> value;             </span><br><span class="line">    List&lt;Thread *&gt; *queue; <span class="comment">/* threads waiting in P() for the value to be </span></span><br><span class="line"><span class="comment">                            * &gt; 0 */</span>      </span><br><span class="line">};</span><br></pre></td></tr></table></figure>

<p>waitFor &#x662F; class Semaphore &#x7684;&#x7269;&#x4EF6;&#x3002;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">waitFor-&gt;<span class="built_in">P</span>();</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* threads/synch.h */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">P</span><span class="params">()</span></span>; <span class="comment">/* waits until value &gt; 0, then decrement */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">V</span><span class="params">()</span></span>; <span class="comment">/* increment, waking up a thread waiting in P() if </span></span><br><span class="line"><span class="comment">               * necessary */</span></span><br><span class="line"><span class="keyword">private</span>:      </span><br><span class="line">    <span class="keyword">int</span> value;             </span><br><span class="line">    List&lt;Thread *&gt; *queue; <span class="comment">/* threads waiting in P() for the value to be </span></span><br><span class="line"><span class="comment">                            * &gt; 0 */</span>      </span><br><span class="line">};</span><br></pre></td></tr></table></figure>

<p>&#x5728; SynchConsole &#x7684;&#x5EFA;&#x69CB;&#x5B50;&#xFF0C;&#x6211;&#x5011;&#x53EF;&#x4EE5;&#x770B;&#x5230; waitFor &#x7684;&#x521D;&#x59CB;&#x503C;&#x662F; 0&#xFF0C;&#x56E0;&#x6B64;&#x7576;&#x7B2C;&#x4E00;&#x500B;&#x8981;&#x8F38;&#x51FA;&#x7684;&#x5B57;&#x5143;&#x9032;&#x5165; Semaphore &#x6642;&#xFF0C;&#x5C31;&#x6703;&#x9032;&#x5165; while &#x8FF4;&#x5708;&#xFF0C;&#x4E26;&#x4E14;&#x9032;&#x5165; Sleep&#xFF0C;&#x7B49;&#x5230;&#x8F38;&#x51FA;&#x5B8C;&#x6210;&#xFF0C;kernel &#x6703;&#x9019;&#x500B; thread &#x52A0;&#x5165; readyList&#xFF0C;&#x4E26;&#x4E14;&#x547C;&#x53EB; CallBack()&#xFF0C;CallBack() &#x6703;&#x547C;&#x53EB; V() &#x8B93; value &#x5F9E; 0 &#x8B8A;&#x6210; 1&#xFF0C;&#x5728;&#x9019;&#x500B; thread &#x518D;&#x6B21;&#x53D6;&#x5F97;&#x63A7;&#x5236;&#x6B0A;&#x6642;&#xFF0C;value &#x662F; 1&#xFF0C;&#x6240;&#x4EE5;&#x53EF;&#x4EE5;&#x8DF3;&#x51FA; while &#x8FF4;&#x5708;&#xFF0C;&#x6B64;&#x6642; value &#x5F9E; 1 &#x8B8A;&#x6210; 0&#xFF0C;&#x56E0;&#x6B64;&#x82E5;&#x6709;&#x4E0B;&#x4E00;&#x500B; thread &#x9032;&#x5165; Semaphore&#xFF0C;&#x4ED6;&#x5FC5;&#x9808;&#x91CD;&#x8907;&#x4E0A;&#x8FF0;&#x7684;&#x6D41;&#x7A0B;&#x3002;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* threads/synch.cc */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Semaphore::P</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line">    <span class="keyword">while</span> (value == <span class="number">0</span>) { 	</span><br><span class="line">        queue-&gt;<span class="built_in">Append</span>(currentThread);	</span><br><span class="line">        currentThread-&gt;<span class="built_in">Sleep</span>(FALSE);</span><br><span class="line">    } </span><br><span class="line">    value--; 	       		</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* kernel/synchconsole.cc */</span></span><br><span class="line"></span><br><span class="line">SynchConsoleOutput::<span class="built_in">SynchConsoleOutput</span>(<span class="keyword">char</span> *outputFile)</span><br><span class="line">{</span><br><span class="line">    consoleOutput = <span class="keyword">new</span> <span class="built_in">ConsoleOutput</span>(outputFile, <span class="keyword">this</span>);</span><br><span class="line">    lock = <span class="keyword">new</span> <span class="built_in">Lock</span>(<span class="string">&quot;console out&quot;</span>);</span><br><span class="line">    waitFor = <span class="keyword">new</span> <span class="built_in">Semaphore</span>(<span class="string">&quot;console out&quot;</span>, <span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h4 id="4-void-List-Append-T-item"><a href="#4-void-List-Append-T-item" class="headerlink" title="4. void List::Append(T item)"></a>4. void List<T>::Append(T item)</T></h4><p><strong>threads/synchlist.cc</strong></p>
<p>queue &#x662F; class List &#x7684;&#x7269;&#x4EF6;&#xFF0C;class List &#x88E1;&#x7DAD;&#x8B77;&#x4E00;&#x500B; linked list&#xFF0C;&#x547C;&#x53EB; Append() &#x5C07; currentThread &#x52A0;&#x5230; queue &#x7684;&#x5C3E;&#x7AEF;&#x3002; </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> List&lt;T&gt;::<span class="built_in">Append</span>(T item)</span><br><span class="line">{</span><br><span class="line">    ListElement&lt;T&gt; *element = <span class="keyword">new</span> ListElement&lt;T&gt;(item);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsEmpty</span>()) { <span class="comment">/* list is empty */</span></span><br><span class="line">        first = element;</span><br><span class="line">        last = element;</span><br><span class="line">    } </span><br><span class="line">    <span class="keyword">else</span> {	 <span class="comment">/* else put it after last */</span></span><br><span class="line">        last-&gt;next = element;</span><br><span class="line">        last = element;</span><br><span class="line">    }</span><br><span class="line">    numInList++;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h4 id="5-Thread-Sleep-bool"><a href="#5-Thread-Sleep-bool" class="headerlink" title="5. Thread::Sleep(bool)"></a>5. Thread::Sleep(bool)</h4><p><strong>threads/thread.cc</strong></p>
<p>&#x5728; thread &#x9032;&#x5165; sleep &#x4E4B;&#x524D;&#xFF0C;&#x8981;&#x5148;&#x627E;&#x597D;&#x8981;&#x628A;&#x63A7;&#x5236;&#x6B0A;&#x7D66;&#x8AB0;&#xFF0C;&#x624D;&#x80FD;&#x628A;&#x63A7;&#x5236;&#x6B0A;&#x4EA4;&#x51FA;&#x53BB;&#xFF0C;&#x9032;&#x5165; sleep&#xFF0C;&#x7B49;&#x5230;&#x9019;&#x500B; thread &#x518D;&#x6B21;&#x57F7;&#x884C;&#x6642;&#xFF0C;&#x4EE3;&#x8868;&#x5B57;&#x5143;&#x5DF2;&#x7D93;&#x8F38;&#x51FA;&#x5B8C;&#x6210;&#x4E86;&#x3002;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Thread::Sleep</span> <span class="params">(<span class="keyword">bool</span> finishing)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Thread *nextThread;</span><br><span class="line">    status = BLOCKED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((nextThread = kernel-&gt;scheduler-&gt;<span class="built_in">FindNextToRun</span>()) == <span class="literal">NULL</span>) {</span><br><span class="line">		kernel-&gt;interrupt-&gt;<span class="built_in">Idle</span>();</span><br><span class="line">    }   </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* returns when it&apos;s time for us to run */</span></span><br><span class="line">    kernel-&gt;scheduler-&gt;<span class="built_in">Run</span>(nextThread, finishing); </span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h4 id="6-Thread-Scheduler-FindNextToRun"><a href="#6-Thread-Scheduler-FindNextToRun" class="headerlink" title="6. Thread *Scheduler::FindNextToRun()"></a>6. Thread *Scheduler::FindNextToRun()</h4><p><strong>threads/scheduler.cc</strong></p>
<p>&#x5F9E; readyList &#x53D6;&#x51FA;&#x6700;&#x524D;&#x9762;&#x7684; thread&#xFF0C;&#x662F;&#x4E0B;&#x4E00;&#x500B;&#x8981;&#x57F7;&#x884C;&#x7684; thread&#x3002;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Thread *<span class="title">Scheduler::FindNextToRun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (readyList-&gt;<span class="built_in">IsEmpty</span>()) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    } </span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> readyList-&gt;<span class="built_in">RemoveFront</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h4 id="7-void-Scheduler-Run-Thread-nextThread-bool-finishing"><a href="#7-void-Scheduler-Run-Thread-nextThread-bool-finishing" class="headerlink" title="7. void Scheduler::Run (Thread *nextThread, bool finishing)"></a>7. void Scheduler::Run (Thread *nextThread, bool finishing)</h4><p><strong>threads/scheduler.cc</strong></p>
<p>old thread &#x548C; next thread &#x9032;&#x884C; context switch&#x3002;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Scheduler::Run</span> <span class="params">(Thread *nextThread, <span class="keyword">bool</span> finishing)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Thread *oldThread = kernel-&gt;currentThread;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (finishing) {	</span><br><span class="line">        <span class="comment">/* mark that we need to delete current thread */</span></span><br><span class="line">        <span class="built_in">ASSERT</span>(toBeDestroyed == <span class="literal">NULL</span>);</span><br><span class="line">        toBeDestroyed = oldThread;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldThread-&gt;space &#xFF01;= <span class="literal">NULL</span>) {	</span><br><span class="line">        <span class="comment">/* save the user&apos;s state */</span></span><br><span class="line">        oldThread-&gt;<span class="built_in">SaveUserState</span>();</span><br><span class="line">        oldThread-&gt;space-&gt;<span class="built_in">SaveState</span>();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    oldThread-&gt;<span class="built_in">CheckOverflow</span>();</span><br><span class="line">    <span class="comment">/* switch to the next thread */</span></span><br><span class="line">    kernel-&gt;currentThread = nextThread;      </span><br><span class="line">    <span class="comment">/* nextThread is now running */</span></span><br><span class="line">    nextThread-&gt;<span class="built_in">setStatus</span>(RUNNING);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This is a machine-dependent assembly language routine defined </span></span><br><span class="line"><span class="comment">     * in switch.s */</span></span><br><span class="line">    <span class="built_in">SWITCH</span>(oldThread, nextThread);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* we&apos;re back, running oldThread */</span></span><br><span class="line">    <span class="comment">/* check if thread we were running before this one has finished</span></span><br><span class="line"><span class="comment">     * and needs to be cleaned up */</span></span><br><span class="line">    <span class="built_in">CheckToBeDestroyed</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldThread-&gt;space != <span class="literal">NULL</span>) {	</span><br><span class="line">        <span class="comment">/* if there is an address space to restore, do it */</span></span><br><span class="line">        oldThread-&gt;<span class="built_in">RestoreUserState</span>();</span><br><span class="line">        oldThread-&gt;space-&gt;<span class="built_in">RestoreState</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h3 id="Waiting-&#x2013;-gt-Ready"><a href="#Waiting-&#x2013;-gt-Ready" class="headerlink" title="Waiting &#x2013;&gt; Ready"></a>Waiting &#x2013;&gt; Ready</h3><h4 id="1-void-Machine-Run-1"><a href="#1-void-Machine-Run-1" class="headerlink" title="1. void Machine::Run()"></a>1. void Machine::Run()</h4><p><strong>machine/mipssim.cc</strong></p>
<p>Onetick() &#x5C07;&#x7CFB;&#x7D71;&#x6642;&#x9593;&#x63A8;&#x9032;&#x4E00;&#x500B;&#x55AE;&#x4F4D;&#xFF0C;&#x4E26;&#x4E14;&#x6AA2;&#x67E5;&#x662F;&#x5426;&#x6709; interrupt &#x6B63;&#x8981;&#x767C;&#x751F;&#x3002;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Machine::Run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Instruction *instr = <span class="keyword">new</span> Instruction;</span><br><span class="line">    kernel-&gt;interrupt-&gt;<span class="built_in">setStatus</span>(UserMode);</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="built_in">OneInstruction</span>(instr);</span><br><span class="line">        kernel-&gt;interrupt-&gt;<span class="built_in">OneTick</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h4 id="2-Interrupt-OneTick"><a href="#2-Interrupt-OneTick" class="headerlink" title="2. Interrupt::OneTick()"></a>2. Interrupt::OneTick()</h4><p><strong>machine/interrupt.cc</strong></p>
<p>&#x4E4B;&#x524D;&#x6211;&#x5011;&#x5728;&#x5B89;&#x6392;&#x8F38;&#x51FA;&#x6642;&#xFF0C;&#x6709; schedule &#x4E00;&#x500B; interrupt&#xFF0C;&#x6A21;&#x64EC;&#x786C;&#x9AD4;&#x5B8C;&#x6210;&#x8F38;&#x51FA;&#x6642;&#x767C;&#x51FA; interrupt&#xFF0C;&#x6211;&#x5011;&#x5728; CheckIfDue() &#x6AA2;&#x67E5;&#x662F;&#x5426;&#x6709;&#x61C9;&#x8A72;&#x767C;&#x751F;&#x7684; interrupt&#x3002;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Interrupt::OneTick</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (status == SystemMode) {</span><br><span class="line">        stats-&gt;totalTicks += SystemTick;</span><br><span class="line">        stats-&gt;systemTicks += SystemTick;</span><br><span class="line">    } </span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        stats-&gt;totalTicks += UserTick;</span><br><span class="line">        stats-&gt;userTicks += UserTick;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">CheckIfDue</span>(FALSE);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h4 id="3-Interrupt-CheckIfDue"><a href="#3-Interrupt-CheckIfDue" class="headerlink" title="3. Interrupt::CheckIfDue"></a>3. Interrupt::CheckIfDue</h4><p><strong>machine/interrupt.cc</strong></p>
<p>&#x5982;&#x679C;&#x6C92;&#x6709;interrupt &#x8981;&#x767C;&#x751F;&#xFF0C;&#x56DE;&#x50B3; false&#xFF0C;&#x82E5;&#x6709; interrupt &#x8981;&#x767C;&#x751F;&#xFF0C;&#x57F7;&#x884C;&#x4E26;&#x4E14;&#x56DE;&#x50B3; true&#xFF0C;&#x82E5; advanceClock &#x70BA; true&#xFF0C;&#x8868;&#x793A;&#x76EE;&#x524D;&#x5DF2;&#x7D93;&#x6C92;&#x6709;&#x4EFB;&#x4F55;&#x6307;&#x4EE4;&#x8981;&#x57F7;&#x884C;&#xFF0C;&#x5247;&#x76F4;&#x63A5;&#x57F7;&#x884C;&#x4E00;&#x500B; interrupt&#x3002;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Interrupt::CheckIfDue</span><span class="params">(<span class="keyword">bool</span> advanceClock)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    PendingInterrupt *next;</span><br><span class="line">    Statistics *stats = kernel-&gt;stats;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pending-&gt;<span class="built_in">IsEmpty</span>()) {</span><br><span class="line">        <span class="keyword">return</span> FALSE;	</span><br><span class="line">    }		</span><br><span class="line">    next = pending-&gt;<span class="built_in">Front</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next-&gt;when &gt; stats-&gt;totalTicks) {</span><br><span class="line">        <span class="keyword">if</span> (!advanceClock) { </span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> { </span><br><span class="line">	    stats-&gt;idleTicks += (next-&gt;when - stats-&gt;totalTicks);</span><br><span class="line">	    stats-&gt;totalTicks = next-&gt;when;</span><br><span class="line">	    }</span><br><span class="line">    }</span><br><span class="line">    inHandler = TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> {</span><br><span class="line">        next = pending-&gt;<span class="built_in">RemoveFront</span>();    </span><br><span class="line">        next-&gt;callOnInterrupt-&gt;<span class="built_in">CallBack</span>();</span><br><span class="line">        <span class="keyword">delete</span> next;</span><br><span class="line">    } <span class="keyword">while</span>(!pending-&gt;<span class="built_in">IsEmpty</span>() &amp;&amp; (pending-&gt;<span class="built_in">Front</span>()-&gt;when &lt;= stats-&gt;totalTicks));</span><br><span class="line">    inHandler = FALSE;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>&#x82E5;&#x76EE;&#x524D;&#x6709;&#x8981;&#x767C;&#x751F;&#x7684; interrupt&#xFF0C;&#x628A; interrupt &#x5F9E; pending &#x4E2D;&#x53D6;&#x51FA;&#xFF0C;&#x547C;&#x53EB;&#x767C;&#x51FA;&#x6B64; interrupt<br>&#x7269;&#x4EF6;&#x7684; callBack()&#xFF0C;&#x5728; interrupt &#x8655;&#x7406;&#x5B8C;&#x4E4B;&#x5F8C;&#xFF0C;&#x56DE;&#x50B3; true&#x3002;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> {</span><br><span class="line">    next = pending-&gt;<span class="built_in">RemoveFront</span>();    </span><br><span class="line">    next-&gt;callOnInterrupt-&gt;<span class="built_in">CallBack</span>();</span><br><span class="line">    <span class="keyword">delete</span> next;</span><br><span class="line">} <span class="keyword">while</span>(!pending-&gt;<span class="built_in">IsEmpty</span>() &amp;&amp; (pending-&gt;<span class="built_in">Front</span>()-&gt;when &lt;= stats-&gt;totalTicks));</span><br></pre></td></tr></table></figure>

<h4 id="4-void-ConsoleOutput-CallBack"><a href="#4-void-ConsoleOutput-CallBack" class="headerlink" title="4. void ConsoleOutput::CallBack()"></a>4. void ConsoleOutput::CallBack()</h4><p><strong>machine/console.cc</strong></p>
<p>&#x7576;&#x87A2;&#x5E55;&#x8F38;&#x51FA;&#x5B8C;&#x6210;&#xFF0C;ConsoleOutput &#x547C;&#x53EB; SynchConsoleOutput&#x7269;&#x4EF6;&#x7684; callBack()&#x3002;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConsoleOutput::CallBack</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    putBusy = FALSE;</span><br><span class="line">    kernel-&gt;stats-&gt;numConsoleCharsWritten++;</span><br><span class="line">    callWhenDone-&gt;<span class="built_in">CallBack</span>();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>consoleOutput &#x7684; callWhenDone &#x662F; SynchConsoleOutput&#x3002;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* machine/console.h */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsoleOutput</span> :</span> <span class="keyword">public</span> CallBackObj {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CallBackObj *callWhenDone;		</span><br><span class="line">};</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* machine/console.cc */</span></span><br><span class="line"></span><br><span class="line">ConsoleOutput::<span class="built_in">ConsoleOutput</span>(<span class="keyword">char</span> *writeFile, CallBackObj *toCall)</span><br><span class="line">{</span><br><span class="line">    callWhenDone = toCall;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* userprog/synchconsole.cc */</span></span><br><span class="line"></span><br><span class="line">SynchConsoleOutput::<span class="built_in">SynchConsoleOutput</span>(<span class="keyword">char</span> *outputFile)</span><br><span class="line">{</span><br><span class="line">    consoleOutput = <span class="keyword">new</span> <span class="built_in">ConsoleOutput</span>(outputFile, <span class="keyword">this</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h4 id="5-SynchConsoleOutput-CallBack"><a href="#5-SynchConsoleOutput-CallBack" class="headerlink" title="5. SynchConsoleOutput::CallBack()"></a>5. SynchConsoleOutput::CallBack()</h4><p><strong>userprog/synchconsole.cc</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SynchConsoleOutput::CallBack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    waitFor-&gt;<span class="built_in">V</span>();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>&#x547C;&#x53EB; V() &#x91CB;&#x653E;&#x4E00;&#x500B; semaphore &#x8CC7;&#x6E90;&#xFF0C;&#x4E26;&#x4E14; pop &#x51FA;&#x4E0B;&#x4E00;&#x500B;&#x5728;queue &#x88E1;&#x7684; thread &#x653E;&#x9032; readyList&#xFF0C;&#x7B49;&#x5230; scheduler &#x5B89;&#x6392;&#x6B64; thread &#x53EF;&#x4EE5;&#x4F7F;&#x7528; CPU &#x6642;&#xFF0C;&#x4E0A;&#x4E00;&#x500B;&#x5B57;&#x5143;&#x5DF2;&#x7D93;&#x5B8C;&#x6210;&#x8F38;&#x51FA;&#xFF0C;&#x53EF;&#x4EE5;&#x8F38;&#x51FA;&#x4E0B;&#x4E00;&#x500B;&#x5B57;&#x5143;&#x3002; </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* threads/synch.cc */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Semaphore::V</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{    </span><br><span class="line">    <span class="keyword">if</span> (!queue-&gt;<span class="built_in">IsEmpty</span>()) { </span><br><span class="line">        kernel-&gt;scheduler-&gt;<span class="built_in">ReadyToRun</span>(queue-&gt;<span class="built_in">RemoveFront</span>());</span><br><span class="line">    }</span><br><span class="line">    value++;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h4 id="6-Scheduler-ReadyToRun-Thread"><a href="#6-Scheduler-ReadyToRun-Thread" class="headerlink" title="6. Scheduler::ReadyToRun(Thread*)"></a>6. Scheduler::ReadyToRun(Thread*)</h4><p><strong>threads/scheduler.cc</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Scheduler::ReadyToRun</span> <span class="params">(Thread *thread)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    thread-&gt;<span class="built_in">setStatus</span>(READY);</span><br><span class="line">    readyList-&gt;<span class="built_in">Append</span>(thread);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h3 id="Running-&#x2013;-gt-Terminated"><a href="#Running-&#x2013;-gt-Terminated" class="headerlink" title="Running &#x2013;&gt; Terminated"></a>Running &#x2013;&gt; Terminated</h3><h4 id="1-void-ExceptionHandler-ExceptionType-which"><a href="#1-void-ExceptionHandler-ExceptionType-which" class="headerlink" title="1. void ExceptionHandler(ExceptionType which)"></a>1. void ExceptionHandler(ExceptionType which)</h4><p><strong>userprog/exception.cc</strong></p>
<p>&#x547C;&#x53EB; Finish() &#x7D50;&#x675F; current thread &#x7684;&#x57F7;&#x884C;&#x3002;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExceptionHandler</span><span class="params">(ExceptionType which)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> type = kernel-&gt;machine-&gt;<span class="built_in">ReadRegister</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (which) {</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> SyscallException:</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span>(type) {</span><br><span class="line">        ...   </span><br><span class="line">        <span class="keyword">case</span> SC_Exit:</span><br><span class="line">            val=kernel-&gt;machine-&gt;<span class="built_in">ReadRegister</span>(<span class="number">4</span>);</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;return value:&quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">            kernel-&gt;currentThread-&gt;<span class="built_in">Finish</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        ...</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h4 id="2-void-Thread-Finish"><a href="#2-void-Thread-Finish" class="headerlink" title="2. void Thread::Finish()"></a>2. void Thread::Finish()</h4><p><strong>userprog/exception.cc</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Thread::Finish</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    (<span class="keyword">void</span>) kernel-&gt;interrupt-&gt;<span class="built_in">SetLevel</span>(IntOff);		</span><br><span class="line">    <span class="built_in">Sleep</span>(TRUE); <span class="comment">/* invokes SWITCH */</span></span><br><span class="line">    <span class="comment">/* not reached */</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h4 id="3-Thread-Sleep-bool"><a href="#3-Thread-Sleep-bool" class="headerlink" title="3. Thread::Sleep(bool)"></a>3. Thread::Sleep(bool)</h4><p><strong>threads/thread.cc</strong></p>
<p>&#x5728;&#x547C;&#x53EB; Sleep() &#x6642;&#xFF0C;&#x5982;&#x679C;&#x50B3;&#x5165;&#x7684;&#x53C3;&#x6578;&#x662F; FALSE&#xFF0C;&#x4EE3;&#x8868;&#x9019;&#x500B; thread &#x53EA;&#x662F;&#x66AB;&#x6642;&#x4EA4;&#x51FA;&#x63A7;&#x5236;&#x6B0A;&#xFF0C;&#x4F46;&#x5982;&#x679C;&#x50B3;&#x5165;&#x7684;&#x53C3;&#x6578;&#x662F; TRUE&#xFF0C;&#x4EE3;&#x8868;&#x9019;&#x500B; thread &#x5DF2;&#x7D93;&#x5B8C;&#x6210;&#x5DE5;&#x4F5C;&#xFF0C;&#x8981;&#x88AB; destroy &#x4E86;&#x3002;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Thread::Sleep</span> <span class="params">(<span class="keyword">bool</span> finishing)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Thread *nextThread;</span><br><span class="line">    status = BLOCKED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((nextThread = kernel-&gt;scheduler-&gt;<span class="built_in">FindNextToRun</span>()) == <span class="literal">NULL</span>) {</span><br><span class="line">        kernel-&gt;interrupt-&gt;<span class="built_in">Idle</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* not reach if finishing is TRUE */</span></span><br><span class="line">    kernel-&gt;scheduler-&gt;<span class="built_in">Run</span>(nextThread, finishing); </span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h4 id="4-Thread-Scheduler-FindNextToRun-1"><a href="#4-Thread-Scheduler-FindNextToRun-1" class="headerlink" title="4. Thread *Scheduler::FindNextToRun()"></a>4. Thread *Scheduler::FindNextToRun()</h4><p><strong>threads/scheduler.cc</strong></p>
<p>&#x5F9E; readyList &#x53D6;&#x51FA;&#x6700;&#x524D;&#x9762;&#x7684; thread&#xFF0C;&#x662F;&#x4E0B;&#x4E00;&#x500B;&#x8981;&#x57F7;&#x884C;&#x7684; thread&#x3002;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Thread *<span class="title">Scheduler::FindNextToRun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (readyList-&gt;<span class="built_in">IsEmpty</span>()) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    } </span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> readyList-&gt;<span class="built_in">RemoveFront</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h4 id="5-void-Scheduler-Run-Thread-nextThread-bool-finishing"><a href="#5-void-Scheduler-Run-Thread-nextThread-bool-finishing" class="headerlink" title="5. void Scheduler::Run (Thread *nextThread, bool finishing)"></a>5. void Scheduler::Run (Thread *nextThread, bool finishing)</h4><p><strong>threads/scheduler.cc</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Scheduler::Run</span> <span class="params">(Thread *nextThread, <span class="keyword">bool</span> finishing)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Thread *oldThread = kernel-&gt;currentThread;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (finishing) {	</span><br><span class="line">        <span class="comment">/* mark that we need to delete old thread */</span></span><br><span class="line">        toBeDestroyed = oldThread;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldThread-&gt;space &#xFF01;= <span class="literal">NULL</span>) {	</span><br><span class="line">        <span class="comment">/* save the user&apos;s state */</span></span><br><span class="line">        oldThread-&gt;<span class="built_in">SaveUserState</span>();</span><br><span class="line">        oldThread-&gt;space-&gt;<span class="built_in">SaveState</span>();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    oldThread-&gt;<span class="built_in">CheckOverflow</span>();</span><br><span class="line">    <span class="comment">/* switch to the next thread */</span></span><br><span class="line">    kernel-&gt;currentThread = nextThread;      </span><br><span class="line">    <span class="comment">/* nextThread is now running */</span></span><br><span class="line">    nextThread-&gt;<span class="built_in">setStatus</span>(RUNNING);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This is a machine-dependent assembly language routine defined </span></span><br><span class="line"><span class="comment">     * in switch.s */</span></span><br><span class="line">    <span class="built_in">SWITCH</span>(oldThread, nextThread);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* we&apos;re back, running oldThread */</span></span><br><span class="line">    <span class="comment">/* check if thread we were running before this one has finished</span></span><br><span class="line"><span class="comment">     * and needs to be cleaned up */</span></span><br><span class="line">    <span class="built_in">CheckToBeDestroyed</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldThread-&gt;space != <span class="literal">NULL</span>) {	</span><br><span class="line">        <span class="comment">/* if there is an address space to restore, do it */</span></span><br><span class="line">        oldThread-&gt;<span class="built_in">RestoreUserState</span>();</span><br><span class="line">        oldThread-&gt;space-&gt;<span class="built_in">RestoreState</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>&#x5982;&#x679C; finishing &#x70BA;&#x771F;&#xFF0C;&#x4EE3;&#x8868; old thread &#x61C9;&#x8A72;&#x88AB; destroy&#xFF0C;&#x56E0;&#x70BA;&#x4E00;&#x500B; thread &#x4E0D;&#x80FD;&#x81EA;&#x5DF1; destroy &#x81EA;&#x5DF1;&#xFF0C;&#x56E0;&#x6B64;&#x8981;&#x7B49; context switch &#x4E4B;&#x5F8C;&#x8B93;&#x4E0B;&#x4E00;&#x500B; thread destroy old thread&#x3002;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (finishing) {	</span><br><span class="line">    <span class="comment">/* mark that we need to delete old thread */</span></span><br><span class="line">    toBeDestroyed = oldThread;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Scheduler::CheckToBeDestroyed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (toBeDestroyed != <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">delete</span> toBeDestroyed;</span><br><span class="line">        toBeDestroyed = <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="../../13/%E5%BE%AE%E5%BE%AE%E4%B8%BB%E5%A9%A6%E5%BF%83%E5%BE%97/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>Prev</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime" title="Update time"></i>
              2021-08-14 22:49:56
            </span>
            
          </div>
          <div class="post-foot-prev">
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">Contents</div>
    <div class="catalog-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#README"><span class="toc-text">README</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Trace-code"><span class="toc-text">Trace code</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#New-%E2%80%93-gt-Ready"><span class="toc-text">New –&gt; Ready</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Kernel-ExecAll"><span class="toc-text">1. Kernel::ExecAll()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-int-Kernel-Exec-char-name"><span class="toc-text">2. int Kernel::Exec(char* name)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Thread-Fork-VoidFunctionPtr-void"><span class="toc-text">3. Thread::Fork(VoidFunctionPtr, void*)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-void-Scheduler-ReadyToRun-Thread-thread"><span class="toc-text">5. void Scheduler::ReadyToRun (Thread *thread)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Running-%E2%80%93-gt-Ready"><span class="toc-text">Running –&gt; Ready</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-void-Machine-Run"><span class="toc-text">1. void Machine::Run()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-void-Interrupt-OneTick"><span class="toc-text">2. void Interrupt::OneTick()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-void-Thread-Yield"><span class="toc-text">3. void Thread::Yield()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Thread-Scheduler-FindNextToRun"><span class="toc-text">4. Thread *Scheduler::FindNextToRun()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-void-Scheduler-ReadyToRun-Thread-thread-1"><span class="toc-text">5. void Scheduler::ReadyToRun(Thread *thread)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-void-Scheduler-Run-Thread-nextThread-bool-finishing"><span class="toc-text">6. void Scheduler::Run (Thread *nextThread, bool finishing)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SWITCH"><span class="toc-text">SWITCH</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-void-SWITCH-Thread-oldThread-Thread-newThread"><span class="toc-text">1. void SWITCH(Thread *oldThread, Thread *newThread)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-void-ThreadRoot"><span class="toc-text">2. void ThreadRoot();</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-static-void-ThreadBegin"><span class="toc-text">3. static void ThreadBegin()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-void-ForkExecute-Thread-t"><span class="toc-text">4. void ForkExecute(Thread *t)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-static-void-ThreadFinish"><span class="toc-text">5. static void ThreadFinish()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Running-%E2%80%93-gt-Waiting"><span class="toc-text">Running –&gt; Waiting</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-void-SynchConsoleOutput-PutChar-char-ch"><span class="toc-text">1. void SynchConsoleOutput::PutChar(char ch)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-ConsoleOutput-PutChar"><span class="toc-text">2. ConsoleOutput::PutChar()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-void-Semaphore-P"><span class="toc-text">3. void Semaphore::P()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-void-List-Append-T-item"><span class="toc-text">4. void List::Append(T item)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Thread-Sleep-bool"><span class="toc-text">5. Thread::Sleep(bool)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-Thread-Scheduler-FindNextToRun"><span class="toc-text">6. Thread *Scheduler::FindNextToRun()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-void-Scheduler-Run-Thread-nextThread-bool-finishing"><span class="toc-text">7. void Scheduler::Run (Thread *nextThread, bool finishing)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Waiting-%E2%80%93-gt-Ready"><span class="toc-text">Waiting –&gt; Ready</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-void-Machine-Run-1"><span class="toc-text">1. void Machine::Run()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Interrupt-OneTick"><span class="toc-text">2. Interrupt::OneTick()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Interrupt-CheckIfDue"><span class="toc-text">3. Interrupt::CheckIfDue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-void-ConsoleOutput-CallBack"><span class="toc-text">4. void ConsoleOutput::CallBack()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-SynchConsoleOutput-CallBack"><span class="toc-text">5. SynchConsoleOutput::CallBack()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-Scheduler-ReadyToRun-Thread"><span class="toc-text">6. Scheduler::ReadyToRun(Thread*)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Running-%E2%80%93-gt-Terminated"><span class="toc-text">Running –&gt; Terminated</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-void-ExceptionHandler-ExceptionType-which"><span class="toc-text">1. void ExceptionHandler(ExceptionType which)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-void-Thread-Finish"><span class="toc-text">2. void Thread::Finish()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Thread-Sleep-bool"><span class="toc-text">3. Thread::Sleep(bool)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Thread-Scheduler-FindNextToRun-1"><span class="toc-text">4. Thread *Scheduler::FindNextToRun()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-void-Scheduler-Run-Thread-nextThread-bool-finishing"><span class="toc-text">5. void Scheduler::Run (Thread *nextThread, bool finishing)</span></a></li></ol></li></ol></li></ol>
    </div>
  </div>

  
<script src="../../../../js/catalog.js"></script>




    
      <div class="comments-container">
        





      </div>
    
  </div>


        <div class="footer">
  <div class="social">
    <ul>
      
        <li>
          <a title="github" target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">
            <i class="iconfont icon-github"></i>
          </a>
        </li>
      
        <li>
          <a title="email" href="">
            <i class="iconfont icon-envelope"></i>
          </a>
        </li>
      
        <li>
          <a title="facebook" href="">
            <i class="iconfont icon-facebooksquare"></i>
          </a>
        </li>
      
        <li>
          <a title="twitter" href="">
            <i class="iconfont icon-twitter"></i>
          </a>
        </li>
      
        <li>
          <a title="wechat" href="">
            <i class="iconfont icon-wechat"></i>
          </a>
        </li>
      
        <li>
          <a title="weibo" href="">
            <i class="iconfont icon-weibo"></i>
          </a>
        </li>
      
        <li>
          <a title="rss" href="/atom.xml">
            <i class="iconfont icon-rss"></i>
          </a>
        </li>
      
    </ul>
  </div>
  
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Copyright © Oranges 2021</a>
        
    </div>
  
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a>
        
    </div>
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="../../../../js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="Search...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>First search, index file loading, please wait...<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>No result<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The search.xml file was not found, please refer to：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The request failed, Try to refresh the page or try again later.<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="../../../../js/colorscheme.js"></script>




      </div>
    </div>
  </body>
</html>
