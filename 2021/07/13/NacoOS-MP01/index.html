<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> NacoOS MP1 · Hexo</title><meta name="description" content="NacoOS MP1 - John Doe"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="../../../../favicon.png"><link rel="stylesheet" href="../../../../css/hermes.css"><link rel="search" type="application/opensearchdescription+xml" href="https://wendyusinggithub.github.io/atom.xml" title="Hexo"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="atom.xml" title="Hexo" type="application/atom+xml">
</head><body><div class="wrap"><header><a class="logo-link" href="../../../../index.html"><img src="../../../../favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="../../../../index.html" target="_self">BLOG</a></li><li class="nav-list-item"><a class="nav-list-link" href="../../../../https:/github.com/WendyUsingGithub" target="_blank">GITHUB</a></li><li class="nav-list-item"><a class="nav-list-link" href="../../../../archives/" target="_self">ARCHIVE</a></li><li class="nav-list-item"><a class="nav-list-link" href="../../../../atom.xml" target="_self">FEED</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">NacoOS MP1</h1><div class="post-info">Jul 13, 2021</div><div class="post-content"><h2 id="Trace-code"><a href="#Trace-code" class="headerlink" title="Trace code"></a>Trace code</h2><h3 id="SC-Halt"><a href="#SC-Halt" class="headerlink" title="SC_Halt"></a>SC_Halt</h3><p>Trace the SC_Halt system call to understand the implementation of a system call. (Sample code : halt.c)</p>
<h4 id="void-Halt"><a href="#void-Halt" class="headerlink" title="void Halt();"></a>void Halt();</h4><p><strong>userprog/syscall.h</strong></p>
<p>trace code 的目標是 syscall.h 的 Halt()。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SC_Halt 0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Halt</span><span class="params">()</span></span>;	</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* test/start.s */</span><br><span class="line"></span><br><span class="line">	.globl Halt</span><br><span class="line">	.ent	Halt</span><br><span class="line">Halt:</span><br><span class="line">	addiu $2,$0,SC_Halt</span><br><span class="line">	syscall</span><br><span class="line">	j	$31</span><br><span class="line">	.end Halt</span><br></pre></td></tr></table></figure>

<p>執行指令 addiu，SC_Halt 是定義在 “syscall.h” 的常數，MIPS 架構的 register(0) 永遠是 0 ，將兩者相加後存到 register(2) 中，即將 SC_Halt 的值 assign 給 register(2)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addiu $2,$0,SC_Halt</span><br></pre></td></tr></table></figure>

<p>執行指令 syscall，進入Exception handler。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">syscall</span><br></pre></td></tr></table></figure>

<p>在 machine.h 定義常數 RetAddrReg 的值是 31。跳到 register(31) 所儲存的位置，表示回到 frame 的上一層。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">j	$31</span><br></pre></td></tr></table></figure>

<h4 id="1-void-Machine-Run"><a href="#1-void-Machine-Run" class="headerlink" title="1. void Machine::Run()"></a>1. void Machine::Run()</h4><p><strong>machine/mipssim.cc</strong> </p>
<p>程式開始執行，kernel 呼叫 Machine::Run()，Machine::Run() 在無窮迴圈呼叫OneInstruction()，不停的執行指令。”mipssim.h” 定義了 MIPS 架構支援的 63 個operation，OneInstruction() 負責處理這 63 個 operation 組成的指令。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Machine::Run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;) </span><br><span class="line">    &#123;</span><br><span class="line">        OneInstruction(instr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-void-Machine-OneInstruction-Instruction-instr"><a href="#2-void-Machine-OneInstruction-Instruction-instr" class="headerlink" title="2. void Machine::OneInstruction(Instruction *instr)"></a>2. void Machine::OneInstruction(Instruction *instr)</h4><p><strong>machine/mipssim.cc</strong></p>
<p>machine.h 定義常數PCReg 值 34，register(34) 放有當前指令的位址。不同指令進入不同的 switch case，當指令是 addiu，不會發生 interrupt，但當指令是 syscall，interupt 發生，呼叫 RaiseException()。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Void <span class="title">Machine::OneInstruction</span><span class="params">(Instruction *instr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> raw;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* fetch instruction */</span></span><br><span class="line">    <span class="keyword">if</span> (!ReadMem(registers[PCReg], <span class="number">4</span>, &amp;raw)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;	</span><br><span class="line">    &#125;	</span><br><span class="line">	</span><br><span class="line">    instr-&gt;value = raw;</span><br><span class="line">    instr-&gt;Decode();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (instr-&gt;opCode) &#123;</span><br><span class="line">    <span class="keyword">case</span> OP_SYSCALL:</span><br><span class="line">        RaiseException(SyscallException, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NachOS 定義了 9 種 exception 類型，在 case OP_SYSCALL 發生的是SyscallException 類型的 exception。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* machine/machine.h */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ExceptionType</span> &#123;</span> </span><br><span class="line">    NoException,           </span><br><span class="line">    SyscallException,      </span><br><span class="line">    PageFaultException,   </span><br><span class="line">    ReadOnlyException,     </span><br><span class="line">    BusErrorException,     </span><br><span class="line">    AddressErrorException, </span><br><span class="line">    OverflowException,     </span><br><span class="line">    IllegalInstrException, </span><br><span class="line">    NumExceptionTypes</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-Void-Machine-RaiseException-ExceptionType-which-int-badVAddr"><a href="#3-Void-Machine-RaiseException-ExceptionType-which-int-badVAddr" class="headerlink" title="3. Void Machine::RaiseException(ExceptionType which, int badVAddr)"></a>3. Void Machine::RaiseException(ExceptionType which, int badVAddr)</h4><p><strong>machine/machine.cc</strong></p>
<p>把程式從 user mode 改成 kernel mode，呼叫 ExceptionHandler。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Void <span class="title">Machine::RaiseException</span><span class="params">(ExceptionType which, <span class="keyword">int</span> badVAddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    kernel-&gt;interrupt-&gt;setStatus(SystemMode);</span><br><span class="line">    ExceptionHandler(which);		</span><br><span class="line">    kernel-&gt;interrupt-&gt;setStatus(UserMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-void-ExceptionHandler-ExceptionType-which"><a href="#4-void-ExceptionHandler-ExceptionType-which" class="headerlink" title="4. void ExceptionHandler(ExceptionType which)"></a>4. void ExceptionHandler(ExceptionType which)</h4><p><strong>userprog/exception .cc</strong></p>
<p>ExceptionHandler() 讀取 register(2) 的值，先前已經把 SC_Halt 的值 assign 給register(2)，因此進入 SC_Halt 的 switch case，呼叫 SysHalt()。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExceptionHandler</span><span class="params">(ExceptionType which)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> type = kernel-&gt;machine-&gt;ReadRegister(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">switch</span>(type) &#123;</span><br><span class="line">    <span class="keyword">case</span> SC_Halt:</span><br><span class="line">        SysHalt(); </span><br><span class="line">        <span class="keyword">break</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-void-SysHalt"><a href="#5-void-SysHalt" class="headerlink" title="5. void SysHalt()"></a>5. void SysHalt()</h4><p><strong>userprog/ksyscall.h</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SysHalt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    kernel-&gt;interrupt-&gt;Halt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="6-Void-Interrupt-Halt"><a href="#6-Void-Interrupt-Halt" class="headerlink" title="6. Void Interrupt::Halt()"></a>6. Void Interrupt::Halt()</h4><p><strong>machine/interrupt.cc</strong></p>
<p>將物件 kernel 所佔用的記憶體釋放，即關機。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Void <span class="title">Interrupt::Halt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Machine halting!\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;This is halt\n&quot;</span>;</span><br><span class="line">    kernel-&gt;stats-&gt;Print();</span><br><span class="line">    <span class="keyword">delete</span> kernel; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="SC-Create"><a href="#SC-Create" class="headerlink" title="SC_Create"></a>SC_Create</h3><p>Trace the SC_Create system call to understand the basic operations and data structure in a file system. (Sample code : createFile.c)</p>
<h4 id="void-Create"><a href="#void-Create" class="headerlink" title="void Create();"></a>void Create();</h4><p><strong>userprog/syscall.h</strong></p>
<p>trace code 的目標是 syscall.h 的 Create()。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SC_Create	4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Create</span><span class="params">(<span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* test/start.s */</span><br><span class="line"></span><br><span class="line">#include &quot;syscall.h&quot;</span><br><span class="line"></span><br><span class="line">	.globl Create</span><br><span class="line">	.ent	Create</span><br><span class="line">Create:</span><br><span class="line">	addiu $2,$0,SC_Create</span><br><span class="line">	syscall</span><br><span class="line">	j	$31</span><br><span class="line">	.end Create</span><br></pre></td></tr></table></figure>

<h4 id="1-OneInstruction-Instruction-instr"><a href="#1-OneInstruction-Instruction-instr" class="headerlink" title="1. OneInstruction(Instruction *instr)"></a>1. OneInstruction(Instruction *instr)</h4><p><strong>machine/mipssim</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;machine.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mipssim.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">Void <span class="title">Machine::OneInstruction</span><span class="params">(Instruction *instr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (instr-&gt;opCode) &#123;</span><br><span class="line">    	<span class="keyword">case</span> OP_SYSCALL:</span><br><span class="line">    	   RaiseException(SyscallException, <span class="number">0</span>);</span><br><span class="line">    	   <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-RaiseException-ExceptionType-which-int-badVAddr"><a href="#2-RaiseException-ExceptionType-which-int-badVAddr" class="headerlink" title="2. RaiseException(ExceptionType which, int badVAddr)"></a>2. RaiseException(ExceptionType which, int badVAddr)</h4><p><strong>machine/machine.cc</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;machine.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">Void <span class="title">Machine::RaiseException</span><span class="params">(ExceptionType which, <span class="keyword">int</span> badVAddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    kernel-&gt;interrupt-&gt;setStatus(SystemMode);</span><br><span class="line">    ExceptionHandler(which);		</span><br><span class="line">    kernel-&gt;interrupt-&gt;setStatus(UserMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-ExceptionHandler-ExceptionType-which"><a href="#3-ExceptionHandler-ExceptionType-which" class="headerlink" title="3. ExceptionHandler(ExceptionType which)"></a>3. ExceptionHandler(ExceptionType which)</h4><p><strong>userprog/exception.cc</strong></p>
<p>從 register(4) 讀出呼叫 Create 時傳入的參數，即 filename 的位置。Syscreate 回傳是否有成功的 create file，成功回傳 1，失敗回傳 0。完成 SysCreate 後必須修改 PCReg 讓 PCReg 指向下一個指令，如果沒有加上這一行，程式會不停的執行同一道指令。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;syscall.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ksyscall.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExceptionHandler</span><span class="params">(ExceptionType which)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> type = kernel-&gt;machine-&gt;ReadRegister(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">switch</span>(type) </span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">case</span> SC_Create:</span><br><span class="line">          val = kernel-&gt;machine-&gt;ReadRegister(<span class="number">4</span>);</span><br><span class="line">          <span class="keyword">char</span> *filename = &amp;(kernel-&gt;machine-&gt;mainMemory[val]);</span><br><span class="line">          status = SysCreate(filename);</span><br><span class="line">          <span class="keyword">if</span>(status != <span class="number">-1</span>) status = <span class="number">1</span>;</span><br><span class="line">          kernel-&gt;machine-&gt;WriteRegister(<span class="number">2</span>, (<span class="keyword">int</span>) status);</span><br><span class="line"></span><br><span class="line">	    kernel-&gt;machine-&gt;WriteRegister(PrevPCReg, </span><br><span class="line">                              kernel-&gt;machine-&gt;ReadRegister(PCReg));</span><br><span class="line">	    kernel-&gt;machine-&gt;WriteRegister(PCReg, </span><br><span class="line">                              kernel-&gt;machine-&gt;ReadRegister(PCReg) + <span class="number">4</span>);</span><br><span class="line">	    kernel-&gt;machine-&gt;WriteRegister(NextPCReg, </span><br><span class="line">                              kernel-&gt;machine-&gt;ReadRegister(PCReg)+<span class="number">4</span>);</span><br><span class="line">	    <span class="keyword">return</span>;</span><br><span class="line">	    ASSERTNOTREACHED();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-int-SysCreate-char-filename"><a href="#4-int-SysCreate-char-filename" class="headerlink" title="4. int SysCreate(char *filename)"></a>4. int SysCreate(char *filename)</h4><p><strong>userprog/ksyscall.h</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Interrupt::CreateFile</span><span class="params">(<span class="keyword">char</span> *filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> kernel-&gt;CreateFile(filename);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-int-Interrupt-CreateFile-char-filename"><a href="#5-int-Interrupt-CreateFile-char-filename" class="headerlink" title="5. int Interrupt::CreateFile(char *filename)"></a>5. int Interrupt::CreateFile(char *filename)</h4><p><strong>machine/interrupt.cc</strong></p>
<p>class FileSystem 是 NachOS 的 file system API。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Kernel::CreateFile</span><span class="params">(<span class="keyword">char</span> *filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fileSystem-&gt;Create(filename);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 filesys.cc 的開頭有一段 #ifdef #else，有沒有 #define FILESYS_STUB 使用的是不同的檔案系統，如果有 #define FILESYS_STUB，並不是使用真正的 NachOS 檔案系統，只是借用了 linux 的檔案系統，如果沒有 #define FILESYS_STUB，才是使用 NachOS 的檔案系統。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> FILESYS_STUB</span></span><br></pre></td></tr></table></figure>

<p>Makefile 裡有下 DFILESYS_STUB 的 flag，代表目前 NachOS 只是借用了 linux 的檔案系統。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEFINES =  -DFILESYS_STUB -DRDATA -DSIM_FIX</span><br></pre></td></tr></table></figure>

<h4 id="6-bool-Filesystem-OpenForWrite-char-name"><a href="#6-bool-Filesystem-OpenForWrite-char-name" class="headerlink" title="6. bool Filesystem::OpenForWrite(char *name)"></a>6. bool Filesystem::OpenForWrite(char *name)</h4><p><strong>filesys/filesys.cc</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> FILESYS_STUB 		</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Create</span><span class="params">(<span class="keyword">char</span> *name)</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> fileDescriptor = OpenForWrite(name);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (fileDescriptor == <span class="number">-1</span>) <span class="keyword">return</span> FALSE;</span><br><span class="line">		Close(fileDescriptor); </span><br><span class="line">		<span class="keyword">return</span> TRUE; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-int-OpenForWrite-char-name"><a href="#7-int-OpenForWrite-char-name" class="headerlink" title="7. int OpenForWrite(char *name)"></a>7. int OpenForWrite(char *name)</h4><p><strong>lib/sysdep.c</strong></p>
<p>目前的檔案系統是借用 linux 的檔案系統，Create 的實做是呼叫了 linux 提供的 open()，open() 失敗回傳 -1，成功回傳非負整數。NachOS 目前沒有真正的檔案系統，如果我們要使用真正的 NachOS 檔案系統，就要在 File System 的 API 之下，自己寫一個檔案系統。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/file.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">OpenForWrite</span><span class="params">(<span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(name, O_RDWR|O_CREAT|O_TRUNC, <span class="number">0666</span>);</span><br><span class="line">    ASSERT(fd &gt;= <span class="number">0</span>); </span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PrintInt"><a href="#PrintInt" class="headerlink" title="PrintInt"></a>PrintInt</h3><p>Trace the SC_PrintInt system call to understand how NachOS implements asynchronized I/O using CallBack functions and register schedule events. (Sample code : add.c)</p>
<h4 id="void-PrintInt-int-number"><a href="#void-PrintInt-int-number" class="headerlink" title="void PrintInt(int number);"></a>void PrintInt(int number);</h4><p><strong>userprog/syscall.h</strong></p>
<p>trace code 的目標是 syscall.h 的 PrintInt() 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SC_PrintInt 16</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintInt</span><span class="params">(<span class="keyword">int</span> number)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* test/start.s */</span><br><span class="line"></span><br><span class="line">#include &quot;syscall.h&quot;</span><br><span class="line"></span><br><span class="line">	.globl PrintInt</span><br><span class="line">	.ent	PrintInt</span><br><span class="line">PrintInt:</span><br><span class="line">	addiu $2,$0,SC_PrintInt</span><br><span class="line">	syscall</span><br><span class="line">	j	$31</span><br><span class="line">	.end PrintInt</span><br></pre></td></tr></table></figure>

<h4 id="1-OneInstruction-Instruction-instr-1"><a href="#1-OneInstruction-Instruction-instr-1" class="headerlink" title="1. OneInstruction(Instruction *instr)"></a>1. OneInstruction(Instruction *instr)</h4><p><strong>machine/mipssim</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Void <span class="title">Machine::OneInstruction</span><span class="params">(Instruction *instr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> raw;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ReadMem(registers[PCReg], <span class="number">4</span>, &amp;raw))</span><br><span class="line">	<span class="keyword">return</span>;			</span><br><span class="line">	</span><br><span class="line">    instr-&gt;value = raw;</span><br><span class="line">    instr-&gt;Decode();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (instr-&gt;opCode) &#123;</span><br><span class="line">    <span class="keyword">case</span> OP_SYSCALL:</span><br><span class="line">        RaiseException(SyscallException, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-RaiseException-ExceptionType-which-int-badVAddr-1"><a href="#2-RaiseException-ExceptionType-which-int-badVAddr-1" class="headerlink" title="2. RaiseException(ExceptionType which, int badVAddr)"></a>2. RaiseException(ExceptionType which, int badVAddr)</h4><p><strong>machine/machine.cc</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Void <span class="title">Machine::RaiseException</span><span class="params">(ExceptionType which, <span class="keyword">int</span> badVAddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    kernel-&gt;interrupt-&gt;setStatus(SystemMode);</span><br><span class="line">    ExceptionHandler(which);		</span><br><span class="line">    kernel-&gt;interrupt-&gt;setStatus(UserMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-ExceptionHandler-ExceptionType-which-1"><a href="#3-ExceptionHandler-ExceptionType-which-1" class="headerlink" title="3. ExceptionHandler(ExceptionType which)"></a>3. ExceptionHandler(ExceptionType which)</h4><p><strong>userprog/exception .cc</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;syscall.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ksyscall.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExceptionHandler</span><span class="params">(ExceptionType which)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> type = kernel-&gt;machine-&gt;ReadRegister(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">switch</span>(type) </span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">case</span> SC_PrintInt:</span><br><span class="line">          val = kernel-&gt;machine-&gt;ReadRegister(<span class="number">4</span>);</span><br><span class="line">          SysPrintInt(val); </span><br><span class="line">	    kernel-&gt;machine-&gt;WriteRegister(PrevPCReg, </span><br><span class="line">                              kernel-&gt;machine-&gt;ReadRegister(PCReg));</span><br><span class="line">	    kernel-&gt;machine-&gt;WriteRegister(PCReg, </span><br><span class="line">                              kernel-&gt;machine-&gt;ReadRegister(PCReg) + <span class="number">4</span>);</span><br><span class="line">	    kernel-&gt;machine-&gt;WriteRegister(NextPCReg, </span><br><span class="line">                              kernel-&gt;machine-&gt;ReadRegister(PCReg)+<span class="number">4</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-SysPrintInt"><a href="#4-SysPrintInt" class="headerlink" title="4. SysPrintInt()"></a>4. SysPrintInt()</h4><p><strong>userprog/ksyscall.h</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SysPrintInt</span><span class="params">(<span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    kernel-&gt;synchConsoleOut-&gt;PutInt(number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-void-SynchConsoleOutput-PutInt-int-number"><a href="#5-void-SynchConsoleOutput-PutInt-int-number" class="headerlink" title="5. void SynchConsoleOutput::PutInt(int number)"></a>5. void SynchConsoleOutput::PutInt(int number)</h4><p><strong>userprog/synchconsole.cc</strong></p>
<p>只有一個 console，因此必須要 sync，輸出的過程是 critical section，一次只能有一個 thread 做 console output。使用 while 迴圈，將字串中的字元一個一個的印出。在此使用 do while 迴圈，因為第一個輸出的字元不需要等待，他既然可以成功 acquire 到 lock 代表目前沒有人在進行輸出，但接下來的字元輸出都要等前一個字元輸出完成才能進行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SynchConsoleOutput::PutInt</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">15</span>];</span><br><span class="line">    <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(str, <span class="string">&quot;%d\n\0&quot;</span>, value); <span class="comment">/* convert int into string */</span></span><br><span class="line">    lock-&gt;Acquire();  <span class="comment">/* enter critical section */</span></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        consoleOutput-&gt;PutChar(str[idx]);</span><br><span class="line">        idx++;</span><br><span class="line">	  waitFor-&gt;P();</span><br><span class="line">    &#125; <span class="keyword">while</span>(str[idx] != <span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line">    lock-&gt;Release(); <span class="comment">/* leave critical section */</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SynchConsoleOutput</span> :</span> <span class="keyword">public</span> CallBackObj &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ConsoleOutput *consoleOutput; <span class="comment">/* the hardware display */</span></span><br><span class="line">    Lock *lock; <span class="comment">/* only one writer at a time */</span></span><br><span class="line">    Semaphore *waitFor; <span class="comment">/* wait for callBack */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CallBack</span><span class="params">()</span></span>; <span class="comment">/* called when more data can be written */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>waitFor 是 class Semaphore 的物件，當呼叫 P() 時，若 waitFor.value &lt; 0 ，thread 會被加入 waitFor.queue 中等待。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">waitFor-&gt;P();</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* threads/synch.h */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">P</span><span class="params">()</span></span>; <span class="comment">/* waits until value &gt; 0, then decrement */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">V</span><span class="params">()</span></span>; <span class="comment">/* increment, waking up a thread waiting in P() if </span></span><br><span class="line"><span class="comment">               * necessary */</span></span><br><span class="line"><span class="keyword">private</span>:      </span><br><span class="line">    <span class="keyword">int</span> value;             </span><br><span class="line">    List&lt;Thread *&gt; *<span class="built_in">queue</span>; <span class="comment">/* threads waiting in P() for the value to be </span></span><br><span class="line"><span class="comment">                            * &gt; 0 */</span>      </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在 value &gt; 0 之前都會卡在迴圈裡，在前一個字元做輸出時，thread 會進入 Sleep() 中，scheduler 會安排正在readyList 的 thread 使用 CPU。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* threads/synch.cc */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Semaphore::P</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">while</span> (value == <span class="number">0</span>) &#123; 	</span><br><span class="line">        <span class="built_in">queue</span>-&gt;Append(currentThread);	</span><br><span class="line">        currentThread-&gt;Sleep(FALSE);</span><br><span class="line">    &#125; </span><br><span class="line">    value--; 	       		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-ConsoleOutput-PutChar"><a href="#6-ConsoleOutput-PutChar" class="headerlink" title="6. ConsoleOutput::PutChar()"></a>6. ConsoleOutput::PutChar()</h4><p><strong>machine/console.cc</strong></p>
<p>呼叫 WriteFile() 對螢幕進行輸出，呼叫 Schedule() 模擬螢幕完成輸出後發出 interrupt 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConsoleOutput::PutChar</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WriteFile(writeFileNo, &amp;ch, <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    kernel-&gt;interrupt-&gt;Schedule(<span class="keyword">this</span>, ConsoleTime, ConsoleWriteInt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WriteFile() 的實做是呼叫 linux 提供的 write()，fd 是被寫入檔案的 file descriptor，writeFileNo 的值在 console.cc 中被 assign 為 1。 在 linux 系統中，file descriptor 為 1 即是 stdout，字元會被輸出到螢幕。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* lib/sysdep.cc */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WriteFile</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *buffer, <span class="keyword">int</span> nBytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retVal = write(fd, buffer, nBytes);</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一個真正的作業系統會在輸出完成的時候發出 interrupt，由於這不是真的作業系統，所以他只能預估輸出時間然後自己發出 interrupt 。NachOS 預估字元輸出需要 100 單位時間，因此安排在 100 個單位時間後發出 interrupt 。關鍵字 this 通常被用在一個 class 內部，this 是一個指標，指向正在被執行的 class 的物件，this 在此處是 ConsoleOutput 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel-&gt;interrupt-&gt;Schedule(<span class="keyword">this</span>, ConsoleTime, ConsoleWriteInt);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* machine/stats.h */</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ConsoleTime =	<span class="number">100</span>; <span class="comment">/* time to read or write one character */</span></span><br></pre></td></tr></table></figure>

<p>IntType 紀錄這個 interrupt 是由哪個硬體發出，NachOS支援六種硬體相關 interrupt 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* machine/interrupt.h */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IntType</span> &#123;</span> TimerInt, DiskInt, ConsoleWriteInt, ConsoleReadInt, </span><br><span class="line">               NetworkSendInt, NetworkRecvInt&#125;;</span><br></pre></td></tr></table></figure>

<p>writeFileNo 的值在 console.cc 中被 assign 為 1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* machine/console.cc */</span></span><br><span class="line"></span><br><span class="line">ConsoleOutput::ConsoleOutput(<span class="keyword">char</span> *writeFile, CallBackObj *toCall)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (writeFile == <span class="literal">NULL</span>)</span><br><span class="line">        writeFileNo = <span class="number">1</span>;			</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        writeFileNo = OpenForWrite(writeFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* threads/kernel.cc */</span></span><br><span class="line"></span><br><span class="line">synchConsoleOut = <span class="keyword">new</span> SynchConsoleOutput(consoleOut);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* threads/kernel.cc */</span></span><br><span class="line"></span><br><span class="line">consoleOut = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<h4 id="7-void-Interrupt-Schedule-CallBackObj-toCall-int-fromNow-IntType-type"><a href="#7-void-Interrupt-Schedule-CallBackObj-toCall-int-fromNow-IntType-type" class="headerlink" title="7. void Interrupt::Schedule(CallBackObj *toCall, int fromNow, IntType type)"></a>7. void Interrupt::Schedule(CallBackObj *toCall, int fromNow, IntType type)</h4><p><strong>machine/interrupt.cc</strong></p>
<p>把待發生的 interrupt 放進 pending，當排定的時間到達時才會發生。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Interrupt::Schedule</span><span class="params">(CallBackObj *toCall, <span class="keyword">int</span> fromNow, IntType type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> when = kernel-&gt;stats-&gt;totalTicks + fromNow;</span><br><span class="line">    PendingInterrupt *toOccur = <span class="keyword">new</span> PendingInterrupt(toCall, when, type);</span><br><span class="line">    pending-&gt;Insert(toOccur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interrupt</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    SortedList&lt;PendingInterrupt *&gt; *pending;		</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>當排定的時間到達，interrupt 發生，回報發出 interrupt 的物件，即 ConsoleOutput，讓他進行 interrupt 的處理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PendingInterrupt *toOccur = <span class="keyword">new</span> PendingInterrupt(toCall, when, type);</span><br></pre></td></tr></table></figure>

<p>when 是 interrupt 排定要發生的時間，totalTicks 是當前時間，fromNow 的值為 ConsoleTime，即 100。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> when = kernel-&gt;stats-&gt;totalTicks + fromNow;</span><br></pre></td></tr></table></figure>

<h4 id="8-void-Machine-Run"><a href="#8-void-Machine-Run" class="headerlink" title="8. void Machine::Run()"></a>8. void Machine::Run()</h4><p><strong>machine/mipssim.cc</strong></p>
<p>Onetick() 將系統時間推進一個單位，並且檢查是否有 interrupt 需要被執行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Machine::Run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Instruction *instr = <span class="keyword">new</span> Instruction;</span><br><span class="line">    kernel-&gt;interrupt-&gt;setStatus(UserMode);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        OneInstruction(instr);</span><br><span class="line">        kernel-&gt;interrupt-&gt;OneTick();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-Interrupt-OneTick"><a href="#9-Interrupt-OneTick" class="headerlink" title="9. Interrupt::OneTick()"></a>9. Interrupt::OneTick()</h4><p><strong>machine/interrupt.cc</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Interrupt::OneTick</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (status == SystemMode) &#123;</span><br><span class="line">        stats-&gt;totalTicks += SystemTick;</span><br><span class="line">        stats-&gt;systemTicks += SystemTick;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        stats-&gt;totalTicks += UserTick;</span><br><span class="line">        stats-&gt;userTicks += UserTick;</span><br><span class="line">    &#125;</span><br><span class="line">    CheckIfDue(FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="10-Interrupt-CheckIfDue"><a href="#10-Interrupt-CheckIfDue" class="headerlink" title="10. Interrupt::CheckIfDue"></a>10. Interrupt::CheckIfDue</h4><p><strong>machine/interrupt.cc</strong></p>
<p>如果沒有interrupt 要發生，回傳 false，若有 interrupt 要發生，執行並且回傳 true，若 advanceClock 為 true，表示目前已經沒有任何指令要執行，則直接執行一個 interrupt。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Interrupt::CheckIfDue</span><span class="params">(<span class="keyword">bool</span> advanceClock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PendingInterrupt *next;</span><br><span class="line">    Statistics *stats = kernel-&gt;stats;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pending-&gt;IsEmpty()) &#123;</span><br><span class="line">	<span class="keyword">return</span> FALSE;	</span><br><span class="line">    &#125;		</span><br><span class="line">    next = pending-&gt;Front();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next-&gt;when &gt; stats-&gt;totalTicks) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!advanceClock) &#123; </span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; </span><br><span class="line">	    stats-&gt;idleTicks += (next-&gt;when - stats-&gt;totalTicks);</span><br><span class="line">	    stats-&gt;totalTicks = next-&gt;when;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    inHandler = TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        next = pending-&gt;RemoveFront();    </span><br><span class="line">        next-&gt;callOnInterrupt-&gt;CallBack();</span><br><span class="line">	  <span class="keyword">delete</span> next;</span><br><span class="line">    &#125; <span class="keyword">while</span>(!pending-&gt;IsEmpty()</span><br><span class="line">            &amp;&amp; (pending-&gt;Front()-&gt;when &lt;= stats-&gt;totalTicks));</span><br><span class="line">    inHandler = FALSE;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若目前有要發生的 interrupt，把 interrupt 從 pending 中取出，呼叫發出此 interrupt<br>物件的 callBack()，在 interrupt 處理完之後，回傳 true。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    next = pending-&gt;RemoveFront();    </span><br><span class="line">    next-&gt;callOnInterrupt-&gt;CallBack();</span><br><span class="line">    <span class="keyword">delete</span> next;</span><br><span class="line">&#125; <span class="keyword">while</span>(!pending-&gt;IsEmpty()</span><br><span class="line">        &amp;&amp; (pending-&gt;Front()-&gt;when &lt;= stats-&gt;totalTicks));</span><br></pre></td></tr></table></figure>

<h4 id="11-void-ConsoleOutput-CallBack"><a href="#11-void-ConsoleOutput-CallBack" class="headerlink" title="11. void ConsoleOutput::CallBack()"></a>11. void ConsoleOutput::CallBack()</h4><p><strong>machine/console.cc</strong></p>
<p>當螢幕輸出完成，ConsoleOutput 呼叫 SynchConsoleOutput物件的 callBack()。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConsoleOutput::CallBack</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    putBusy = FALSE;</span><br><span class="line">    kernel-&gt;stats-&gt;numConsoleCharsWritten++;</span><br><span class="line">    callWhenDone-&gt;CallBack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>consoleOutput 的 callWhenDone 是 SynchConsoleOutput。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* machine/console.h */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsoleOutput</span> :</span> <span class="keyword">public</span> CallBackObj &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CallBackObj *callWhenDone;		</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* machine/console.cc */</span></span><br><span class="line"></span><br><span class="line">ConsoleOutput::ConsoleOutput(<span class="keyword">char</span> *writeFile, CallBackObj *toCall)</span><br><span class="line">&#123;</span><br><span class="line">    callWhenDone = toCall;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* userprog/synchconsole.cc */</span></span><br><span class="line"></span><br><span class="line">SynchConsoleOutput::SynchConsoleOutput(<span class="keyword">char</span> *outputFile)</span><br><span class="line">&#123;</span><br><span class="line">    consoleOutput = <span class="keyword">new</span> ConsoleOutput(outputFile, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="11-SynchConsoleOutput-CallBack"><a href="#11-SynchConsoleOutput-CallBack" class="headerlink" title="11. SynchConsoleOutput::CallBack()"></a>11. SynchConsoleOutput::CallBack()</h4><p><strong>userprog/synchconsole.cc</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SynchConsoleOutput::CallBack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    waitFor-&gt;V();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>V() 釋放一個 semaphore 資源，並且 pop 出下一個在 semaphore.queue 的 thread 放進 readyList，等到 scheduler 安排此 thread 可以使用 CPU 時，才能輸出下一個字元。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* threads/synch.cc */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Semaphore::V</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">queue</span>-&gt;IsEmpty()) &#123; </span><br><span class="line">	kernel-&gt;scheduler-&gt;ReadyToRun(<span class="built_in">queue</span>-&gt;RemoveFront());</span><br><span class="line">    &#125;</span><br><span class="line">    value++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Implement-four-I-O-system-calls-in-NachOS"><a href="#Implement-four-I-O-system-calls-in-NachOS" class="headerlink" title="Implement four I/O system calls in NachOS"></a>Implement four I/O system calls in NachOS</h3><ul>
<li>OpenFileId Open(char *name);</li>
<li>int Write(char *buffer, int size, OpenFileId id);</li>
<li>int Read(char *buffer, int size, OpenFileId id);</li>
<li>int Close(OpenFileId id);</li>
</ul>
<p>Open / Close / Read / Write 四者非常像，因此我以 Write 為例子進行實做解說 ，唯有比較需要說明的部份會將 Open / Close / Read 一起說明。</p>
<h4 id="int-Write-char-buffer-int-size-OpenFileId-id"><a href="#int-Write-char-buffer-int-size-OpenFileId-id" class="headerlink" title="int Write(char *buffer, int size, OpenFileId id);"></a>int Write(char *buffer, int size, OpenFileId id);</h4><p><strong>userprog/syscall.h</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SC_Write 8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> *buffer, <span class="keyword">int</span> size, OpenFileId id)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* test/start.s */</span><br><span class="line"></span><br><span class="line">#include &quot;syscall.h&quot;</span><br><span class="line"></span><br><span class="line">	.globl Write</span><br><span class="line">	.ent	Write</span><br><span class="line">Write:</span><br><span class="line">	addiu $2,$0,SC_Write</span><br><span class="line">	syscall</span><br><span class="line">	j	$31</span><br><span class="line">	.end Write</span><br></pre></td></tr></table></figure>

<h4 id="1-Void-Machine-OneInstruction-Instruction-instr"><a href="#1-Void-Machine-OneInstruction-Instruction-instr" class="headerlink" title="1. Void Machine::OneInstruction(Instruction *instr)"></a>1. Void Machine::OneInstruction(Instruction *instr)</h4><p><strong>machine/mipssim</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;machine.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mipssim.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">Void <span class="title">Machine::OneInstruction</span><span class="params">(Instruction *instr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (instr-&gt;opCode) &#123;</span><br><span class="line">    <span class="keyword">case</span> OP_SYSCALL:</span><br><span class="line">        RaiseException(SyscallException, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-RaiseException-ExceptionType-which-int-badVAddr-2"><a href="#2-RaiseException-ExceptionType-which-int-badVAddr-2" class="headerlink" title="2. RaiseException(ExceptionType which, int badVAddr)"></a>2. RaiseException(ExceptionType which, int badVAddr)</h4><p><strong>machine/machine.cc</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;machine.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">Void <span class="title">Machine::RaiseException</span><span class="params">(ExceptionType which, <span class="keyword">int</span> badVAddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    kernel-&gt;interrupt-&gt;setStatus(SystemMode);</span><br><span class="line">    ExceptionHandler(which);		</span><br><span class="line">    kernel-&gt;interrupt-&gt;setStatus(UserMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-ExceptionHandler-ExceptionType-which-2"><a href="#3-ExceptionHandler-ExceptionType-which-2" class="headerlink" title="3. ExceptionHandler(ExceptionType which)"></a>3. ExceptionHandler(ExceptionType which)</h4><p><strong>userprog/exception.cc</strong></p>
<p>依照我們傳入參數的順序 (char *buffer, int size, OpenFileId id) 依序從 register $a0 $a1 $a2，即從 register(4) register(5) register(6) 讀出呼叫 system call Write 時所傳入的參數。SysWrite 會回傳寫入是否成功。依照 MIPS 慣例，函式回傳值應放在 register $v0，即 register(4)。完成 SysWrite 之後要修改 PCReg 讓 PCReg 指向下一個指令，如果沒有加上這一行的話，程式會不停的執行當前指令。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;syscall.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ksyscall.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExceptionHandler</span><span class="params">(ExceptionType which)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> type = kernel-&gt;machine-&gt;ReadRegister(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> SC_Write:</span><br><span class="line">	    val = kernel-&gt;machine-&gt;ReadRegister(<span class="number">4</span>);</span><br><span class="line">	    <span class="keyword">char</span> *buffer = &amp;(kernel-&gt;machine-&gt;mainMemory[val]);</span><br><span class="line">	    size = kernel-&gt;machine-&gt;ReadRegister(<span class="number">5</span>); </span><br><span class="line">	    id = kernel-&gt;machine-&gt;ReadRegister(<span class="number">6</span>); </span><br><span class="line">	    status = SysWrite(buffer, size, id);</span><br><span class="line">	    kernel-&gt;machine-&gt;WriteRegister(<span class="number">2</span>, (<span class="keyword">int</span>) status);</span><br><span class="line">	    kernel-&gt;machine-&gt;WriteRegister(PrevPCReg, </span><br><span class="line">                              kernel-&gt;machine-&gt;ReadRegister(PCReg));</span><br><span class="line">	    kernel-&gt;machine-&gt;WriteRegister(PCReg, </span><br><span class="line">                              kernel-&gt;machine-&gt;ReadRegister(PCReg) + <span class="number">4</span>);</span><br><span class="line">	    kernel-&gt;machine-&gt;WriteRegister(NextPCReg, </span><br><span class="line">        kernel-&gt;machine-&gt;ReadRegister(PCReg)+<span class="number">4</span>);</span><br><span class="line">	    <span class="keyword">return</span>;	</span><br><span class="line">	    ASSERTNOTREACHED();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-int-SysWrite-char-buffer-int-size-int-id"><a href="#4-int-SysWrite-char-buffer-int-size-int-id" class="headerlink" title="4. int SysWrite(char *buffer, int size, int id)"></a>4. int SysWrite(char *buffer, int size, int id)</h4><p><strong>userprog/ksyscall.h</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SysWrite</span><span class="params">(<span class="keyword">char</span> *buffer, <span class="keyword">int</span> size, <span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> kernel-&gt;WriteFile(buffer, size, id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-int-Kernel-WriteFile-char-buffer-int-size-int-id"><a href="#5-int-Kernel-WriteFile-char-buffer-int-size-int-id" class="headerlink" title="5. int Kernel::WriteFile(char *buffer, int size, int id)"></a>5. int Kernel::WriteFile(char *buffer, int size, int id)</h4><p><strong>machine/interrupt.cc</strong></p>
<p>class FileSystem 是 NachOS 的 file system API。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Kernel::WriteFile</span><span class="params">(<span class="keyword">char</span> *buffer, <span class="keyword">int</span> size, <span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> fileSystem-&gt;WriteF(buffer, size, id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-int-Filesystem-WriteField-char-name"><a href="#6-int-Filesystem-WriteField-char-name" class="headerlink" title="6. int Filesystem::WriteField(char *name)"></a>6. int Filesystem::WriteField(char *name)</h4><p><strong>filesys/filesys.cc</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> FILESYS_STUB 		</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">WriteF</span><span class="params">(<span class="keyword">char</span> *buffer, <span class="keyword">int</span> size, <span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> status = WriteFile(id, buffer, size);</span><br><span class="line">        <span class="keyword">return</span> status; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-1-int-WriteFile-int-fd-char-buffer-int-nBytes"><a href="#7-1-int-WriteFile-int-fd-char-buffer-int-nBytes" class="headerlink" title="7_1.  int WriteFile(int fd, char *buffer, int nBytes)"></a>7_1.  int WriteFile(int fd, char *buffer, int nBytes)</h4><p><strong>lib/sysdep.cc</strong></p>
<p>class FileSystem 是 NachOS 的檔案系統 API，由於目前的檔案系統是依賴 linux 的檔案系統，system call Write 的實做是呼叫 linux 提供的 write()，write() 失敗回傳 -1，成功回傳成功寫入的字元數。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WriteFile</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *buffer, <span class="keyword">int</span> nBytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retVal = write(fd, buffer, nBytes);</span><br><span class="line">    ASSERT(retVal == nBytes);</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-2-int-OpenForReadWrite-char-name-bool-crashOnError"><a href="#7-2-int-OpenForReadWrite-char-name-bool-crashOnError" class="headerlink" title="7_2. int OpenForReadWrite(char *name, bool crashOnError)"></a>7_2. int OpenForReadWrite(char *name, bool crashOnError)</h4><p><strong>lib/sysdep.cc</strong></p>
<p>system call Open 的實做是呼叫 linux 提供的 open()，open() 失敗回傳 -1，成功回傳 file description。需要注意的是，如果使用 fopen() 開啟檔案，他回傳的是 FILE*，是一個指標，而 open() 回傳的是一個整數。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">OpenForReadWrite</span><span class="params">(<span class="keyword">char</span> *name, <span class="keyword">bool</span> crashOnError)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(name, O_RDWR, <span class="number">0</span>);</span><br><span class="line">    ASSERT(!crashOnError || fd &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-3-int-Read-int-fd-char-buffer-int-nBytes"><a href="#7-3-int-Read-int-fd-char-buffer-int-nBytes" class="headerlink" title="7_3. int Read(int fd, char *buffer, int nBytes)"></a>7_3. int Read(int fd, char *buffer, int nBytes)</h4><p><strong>lib/sysdep.cc</strong></p>
<p>system call Read 的實做是呼叫 linux 提供的 read()，read() 失敗回傳 -1，成功回傳成功讀出的字元數。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *buffer, <span class="keyword">int</span> nBytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retVal = read(fd, buffer, nBytes);</span><br><span class="line">    ASSERT(retVal == nBytes);</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-4-int-Close-int-fd"><a href="#7-4-int-Close-int-fd" class="headerlink" title="7_4. int Close(int fd)"></a>7_4. int Close(int fd)</h4><p><strong>lib/sysdep.cc</strong></p>
<p>system call Close 的實做是呼叫 linux 提供的 read()，read() 失敗回傳 -1，成功回傳 0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Close</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retVal = close(fd);</span><br><span class="line">    ASSERT(retVal &gt;= <span class="number">0</span>); </span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h3><h4 id="Compile-Rebuild-NachOS"><a href="#Compile-Rebuild-NachOS" class="headerlink" title="Compile / Rebuild NachOS"></a>Compile / Rebuild NachOS</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; cd NachOS-4.0_MP1/code/build.linux</span><br><span class="line">&gt; make clean</span><br><span class="line">&gt; make depend</span><br><span class="line">&gt; make</span><br></pre></td></tr></table></figure>

<h4 id="Test-NachOS"><a href="#Test-NachOS" class="headerlink" title="Test NachOS"></a>Test NachOS</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; cd NachOS-4.0_MP1/code/test</span><br><span class="line">&gt; make clean</span><br><span class="line">&gt; make halt</span><br><span class="line">&gt; ../build.linux/nachos -e halt</span><br></pre></td></tr></table></figure>


<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>[1] shawn2000100/10810CS_342301_OperatingSystem<br><a target="_blank" rel="noopener" href="https://github.com/shawn2000100/10810CS_342301_OperatingSystem">https://github.com/shawn2000100/10810CS_342301_OperatingSystem</a></p>
</div></article></div></main><footer><div class="paginator"><a class="next" href="../../../06/25/%E5%AD%B8%E6%9C%9F%E7%B5%90%E6%9D%9F%E4%BA%86/">NEXT</a></div><div class="copyright"><p>© 2019 - 2021 <a href="https://wendyusinggithub.github.io">John Doe</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/claymcleod/hexo-theme-hermes" target="_blank">hexo-theme-hermes</a>. </p><p>Logo made by <a target="_blank" rel="noopener" href="https://www.flaticon.com/authors/freepik">Freepik</a> from <a target="_blank" rel="noopener" href="https://flaticon.com">www.flaticon.com</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>