<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> NachOS MP2 Â· Hexo</title><meta name="description" content="NachOS MP2 - John Doe"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="../../../../favicon.png"><link rel="stylesheet" href="../../../../css/hermes.css"><link rel="search" type="application/opensearchdescription+xml" href="http://example.com/atom.xml" title="Hexo"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="atom.xml" title="Hexo" type="application/atom+xml">
</head><body><div class="wrap"><header><a class="logo-link" href="../../../../index.html"><img src="../../../../favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="../../../../index.html" target="_self">BLOG</a></li><li class="nav-list-item"><a class="nav-list-link" href="../../../../https:/github.com/WendyUsingGithub" target="_blank">GITHUB</a></li><li class="nav-list-item"><a class="nav-list-link" href="../../../../archives/" target="_self">ARCHIVE</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">NachOS MP2</h1><div class="post-info">Jul 18, 2021</div><div class="post-content"><h2 id="Trace-code"><a href="#Trace-code" class="headerlink" title="Trace code"></a>Trace code</h2><h3 id="a-threads-kernel-cc&#x200B;-Kernel-ExecAll-&#x200B;"><a href="#a-threads-kernel-cc&#x200B;-Kernel-ExecAll-&#x200B;" class="headerlink" title="(a) threads/kernel.cc&#x200B; Kernel::ExecAll()&#x200B;"></a>(a) threads/kernel.cc&#x200B; Kernel::ExecAll()&#x200B;</h3><p>Starting from &#x201C;threads/kernel.cc&#x200B; Kernel::ExecAll()&#x200B;&#x201D; is called.</p>
<h4 id="1-int-main-int-argc-char-argv"><a href="#1-int-main-int-argc-char-argv" class="headerlink" title="1. int main(int argc, char **argv)"></a>1. int main(int argc, char **argv)</h4><p><strong>threads/main.cc</strong></p>
<p>kernel &#x5BA3;&#x544A;&#x70BA;&#x5168;&#x57DF;&#x8B8A;&#x6578;&#xFF0C;&#x6574;&#x500B; NachOS file &#x90FD;&#x53EF;&#x4EE5;&#x5171;&#x4EAB;&#x3002;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Kernel *kernel; <span class="comment">/* global variable */</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    kernel = <span class="keyword">new</span> Kernel(argc, argv);</span><br><span class="line">    kernel-&gt;Initialize();</span><br><span class="line">    ... </span><br><span class="line">    kernel-&gt;ExecAll();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>&#x7576;&#x6211;&#x5011;&#x5728;&#x547D;&#x4EE4;&#x5217;&#x4E0B;&#x6307;&#x4EE4; -e halt&#xFF0C;halt &#x5373;&#x662F;&#x6211;&#x5011;&#x60F3;&#x57F7;&#x884C;&#x7684;&#x53EF;&#x57F7;&#x884C;&#x6A94;&#x3002;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* threads/kernel.cc */</span></span><br><span class="line"></span><br><span class="line">Kernel::Kernel(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argc; i++) {</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[i], <span class="string">&quot;-e&quot;</span>) == <span class="number">0</span>) {</span><br><span class="line">            execfile[++execfileNum]= argv[++i];</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; execfile[execfileNum] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        }     </span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* threads/kernel.h */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Kernel</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Thread *currentThread; <span class="comment">/* the thread holding CPU */</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	  Thread* t[<span class="number">10</span>]; <span class="comment">/* 10 threads at most */</span></span><br><span class="line">	  <span class="keyword">char</span>* execfile[<span class="number">10</span>]; <span class="comment">/* executable file name */</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* threads/kernel.cc */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kernel::Initialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    currentThread = <span class="keyword">new</span> Thread(<span class="string">&quot;main&quot;</span>, threadNum++);		</span><br><span class="line">    currentThread-&gt;setStatus(RUNNING); </span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h4 id="2-void-Kernel-ExecAll"><a href="#2-void-Kernel-ExecAll" class="headerlink" title="2. void Kernel::ExecAll()"></a>2. void Kernel::ExecAll()</h4><p><strong>threads/kernel.cc</strong>&#x200B; </p>
<p>&#x628A;&#x6240;&#x6709;&#x53EF;&#x57F7;&#x884C;&#x6A94;&#x4E1F;&#x9032; Exec() &#x57F7;&#x884C;&#x3002;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kernel::ExecAll</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= execfileNum; i++) {</span><br><span class="line">        <span class="keyword">int</span> a = Exec(execfile[i]);</span><br><span class="line">    }</span><br><span class="line">    currentThread-&gt;Finish();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h4 id="3-int-Kernel-Exec-char-name"><a href="#3-int-Kernel-Exec-char-name" class="headerlink" title="3. int Kernel::Exec(char* name)"></a>3. int Kernel::Exec(char* name)</h4><p><strong>threads/kernel.cc</strong>&#x200B; </p>
<p>&#x6BCF;&#x4E00;&#x500B;&#x53EF;&#x57F7;&#x884C;&#x6A94;&#x90FD;&#x9700;&#x8981; new &#x4E00;&#x500B;&#x65B0;&#x7684; thread &#x4F86;&#x57F7;&#x884C;&#x3002;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Kernel::Exec</span><span class="params">(<span class="keyword">char</span>* name)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    t[threadNum] = <span class="keyword">new</span> Thread(name, threadNum);</span><br><span class="line">    t[threadNum]-&gt;space = <span class="keyword">new</span> AddrSpace();    </span><br><span class="line">    t[threadNum]-&gt;Fork((VoidFunctionPtr)&amp;ForkExecute,</span><br><span class="line">                       (<span class="keyword">void</span>*)t[threadNum]);</span><br><span class="line">    threadNum++;</span><br><span class="line">    <span class="keyword">return</span> threadNum<span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h4 id="4-void-Thread-Fork-VoidFunctionPtr-func-void-arg"><a href="#4-void-Thread-Fork-VoidFunctionPtr-func-void-arg" class="headerlink" title="4. void Thread::Fork(VoidFunctionPtr func, void *arg)"></a>4. void Thread::Fork(VoidFunctionPtr func, void *arg)</h4><p><strong>threads/thread.cc</strong></p>
<p>&#x5EFA;&#x7ACB; thread &#x57F7;&#x884C;&#x6240;&#x9700;&#x8981;&#x7684; stack&#xFF0C;&#x4E26;&#x628A; thread &#x4E1F;&#x9032; readyList &#x7B49;&#x5F85;&#x57F7;&#x884C;&#x3002;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Thread::Fork</span><span class="params">(VoidFunctionPtr func, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Interrupt *interrupt = kernel-&gt;interrupt;</span><br><span class="line">    Scheduler *scheduler = kernel-&gt;scheduler;</span><br><span class="line">    IntStatus oldLevel;</span><br><span class="line">    </span><br><span class="line">    StackAllocate(func, arg);</span><br><span class="line"></span><br><span class="line">    oldLevel = interrupt-&gt;SetLevel(IntOff);</span><br><span class="line">    scheduler-&gt;ReadyToRun(<span class="keyword">this</span>);</span><br><span class="line">    (<span class="keyword">void</span>) interrupt-&gt;SetLevel(oldLevel);</span><br><span class="line">}   </span><br></pre></td></tr></table></figure>

<h4 id="5-void-Scheduler-ReadyToRun-Thread-thread"><a href="#5-void-Scheduler-ReadyToRun-Thread-thread" class="headerlink" title="5. void Scheduler::ReadyToRun (Thread *thread)"></a>5. void Scheduler::ReadyToRun (Thread *thread)</h4><p><strong>threads/scheduler.cc</strong></p>
<p>&#x5C07; thread &#x52A0;&#x5165; readyList&#xFF0C;&#x7576; scheduler &#x9700;&#x8981;&#x5B89;&#x6392; thread &#x4F86;&#x57F7;&#x884C;&#x7684;&#x6642;&#x5019;&#xFF0C;&#x5C31;&#x5F9E; readyList dequeue &#x4E00;&#x500B; thread &#x4F86;&#x57F7;&#x884C;&#x3002;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Scheduler::ReadyToRun</span> <span class="params">(Thread *thread)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ASSERT(kernel-&gt;interrupt-&gt;getLevel() == IntOff);</span><br><span class="line">    thread-&gt;setStatus(READY);</span><br><span class="line">    readyList-&gt;Append(thread);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scheduler</span> {</span></span><br><span class="line">    <span class="function">Thread* <span class="title">FindNextToRun</span><span class="params">()</span></span>;</span><br><span class="line">    List&lt;Thread *&gt; *readyList;	</span><br><span class="line">};</span><br></pre></td></tr></table></figure>

<h3 id="b-&#x201C;threads-thread-cc-thread-Sleep"><a href="#b-&#x201C;threads-thread-cc-thread-Sleep" class="headerlink" title="(b) &#x201C;threads/thread.cc thread::Sleep"></a>(b) &#x201C;threads/thread.cc thread::Sleep</h3><p>Starting from &#x201C;threads/thread.cc thread::Sleep&#x200B;&#x201D; is called.</p>
<h4 id="1-void-Thread-Sleep-bool-finishing"><a href="#1-void-Thread-Sleep-bool-finishing" class="headerlink" title="1. void Thread::Sleep (bool finishing)"></a>1. void Thread::Sleep (bool finishing)</h4><p><strong>threads/thread.cc</strong></p>
<p>&#x53EA;&#x6709; currentThread &#x53EF;&#x4EE5;&#x547C;&#x53EB; Sleep()&#xFF0C;currentThread &#x662F;&#x76EE;&#x524D;&#x6B63;&#x5728;&#x57F7;&#x884C;&#x7684; thread&#xFF0C;&#x7576;currentThread &#x5B8C;&#x6210;&#x4ED6;&#x7684;&#x5DE5;&#x4F5C;&#x6216;&#x662F;&#x5728;&#x7B49;&#x5F85; synchronization variable (Semaphore, Lock, or Condition)&#xFF0C;&#x6703;&#x9032;&#x5165; Sleep()&#x3002; &#x7576; currentThread &#x9032;&#x5165; Sleep()&#xFF0C;&#x5C31;&#x80FD;&#x5F9E; readyList &#x4E2D; dequeue &#x4E00;&#x500B; thread &#x6210;&#x70BA; currentThread&#xFF0C;&#x4F7F;&#x7528; CPU&#x3002;&#x6211;&#x5011;&#x5C07;&#x9032;&#x5165; Sleep() &#x7684; thread &#x7684; state &#x5B58;&#x8D77;&#x4F86;&#xFF0C;&#x4E26;&#x4E14;&#x9032;&#x884C; context switch &#x3002;&#x7576;&#x518D;&#x6B21;&#x8F2A;&#x5230;&#x5728; Sleep() &#x7684; thread &#x4F7F;&#x7528; CPU &#x6642;&#xFF0C;Run() &#x624D;&#x6703; return&#x3002;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Thread::Sleep</span> <span class="params">(<span class="keyword">bool</span> finishing)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Thread *nextThread;</span><br><span class="line">    ASSERT(<span class="keyword">this</span> == kernel-&gt;currentThread);</span><br><span class="line">    ASSERT(kernel-&gt;interrupt-&gt;getLevel() == IntOff);</span><br><span class="line">    status = BLOCKED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((nextThread = kernel-&gt;scheduler-&gt;FindNextToRun()) == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="comment">/* no one to run, wait for an interrupt */</span></span><br><span class="line">        kernel-&gt;interrupt-&gt;Idle();</span><br><span class="line">    }    </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* returns when it&apos;s time for us to run */</span></span><br><span class="line">    kernel-&gt;scheduler-&gt;Run(nextThread, finishing); </span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h4 id="2-void-Scheduler-Run-Thread-nextThread-bool-finishing"><a href="#2-void-Scheduler-Run-Thread-nextThread-bool-finishing" class="headerlink" title="2. void Scheduler::Run (Thread *nextThread, bool finishing)"></a>2. void Scheduler::Run (Thread *nextThread, bool finishing)</h4><p><strong>threads/scheduler.cc</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Scheduler::Run</span> <span class="params">(Thread *nextThread, <span class="keyword">bool</span> finishing)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Thread *oldThread = kernel-&gt;currentThread;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (finishing) {	</span><br><span class="line">        <span class="comment">/* mark that we need to delete current thread */</span></span><br><span class="line">        ASSERT(toBeDestroyed == <span class="literal">NULL</span>);</span><br><span class="line">	  toBeDestroyed = oldThread;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (oldThread-&gt;space &#xFF01;= <span class="literal">NULL</span>) {	</span><br><span class="line">        <span class="comment">/* save the user&apos;s state */</span></span><br><span class="line">        oldThread-&gt;SaveUserState();</span><br><span class="line">        oldThread-&gt;space-&gt;SaveState();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    oldThread-&gt;CheckOverflow();</span><br><span class="line">    <span class="comment">/* switch to the next thread */</span></span><br><span class="line">    kernel-&gt;currentThread = nextThread;      </span><br><span class="line">    <span class="comment">/* nextThread is now running */</span></span><br><span class="line">    nextThread-&gt;setStatus(RUNNING);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This is a machine-dependent assembly language routine defined </span></span><br><span class="line"><span class="comment">     * in switch.s */</span></span><br><span class="line">    SWITCH(oldThread, nextThread);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* we&apos;re back, running oldThread */</span></span><br><span class="line">    <span class="comment">/* check if thread we were running before this one has finished</span></span><br><span class="line"><span class="comment">     * and needs to be cleaned up */</span></span><br><span class="line">    CheckToBeDestroyed();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (oldThread-&gt;space != <span class="literal">NULL</span>) {	</span><br><span class="line">        <span class="comment">/* if there is an address space to restore, do it */</span></span><br><span class="line">        oldThread-&gt;RestoreUserState();</span><br><span class="line">	  oldThread-&gt;space-&gt;RestoreState();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>&#x547C;&#x53EB; SWITCH() &#x9032;&#x884C; context switch&#xFF0C;&#x5728; SWITCH() &#x5B8C;&#x6210;&#x4E4B;&#x5F8C;&#xFF0C;&#x4E26;&#x4E0D;&#x6703;&#x7E7C;&#x7E8C;&#x57F7;&#x884C; Run() &#x7684;&#x4E0B;&#x4E00;&#x884C;&#xFF0C;&#x56E0;&#x70BA;&#x63A7;&#x5236;&#x6B0A;&#x5DF2;&#x7D93;&#x50B3;&#x7D66; nextThread&#xFF0C;&#x4E0B;&#x4E00;&#x884C;&#x8981;&#x88AB;&#x57F7;&#x884C;&#x7684;&#x6307;&#x4EE4;&#x662F; nextThread &#x7684;&#x6307;&#x4EE4;&#xFF0C;&#x7576; CheckToBeDestroyed() &#x88AB;&#x57F7;&#x884C;&#xFF0C;&#x4EE3;&#x8868;&#x5DF2;&#x7D93;&#x53C8;&#x8F2A;&#x5230;&#x9019;&#x500B; thread &#x4F7F;&#x7528; CPU&#xFF0C;&#x9019;&#x4E2D;&#x9593;&#x53EF;&#x80FD;&#x5DF2;&#x7D93;&#x5728;&#x597D;&#x5E7E;&#x500B; thread &#x4E4B;&#x9593; context  switch &#x597D;&#x5E7E;&#x6B21;&#x4E86;&#x3002;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SWITCH(oldThread, nextThread);</span><br></pre></td></tr></table></figure>

<h3 id="c-machine-mipssim-cc-Machine-Run-&#x200B;"><a href="#c-machine-mipssim-cc-Machine-Run-&#x200B;" class="headerlink" title="(c) machine/mipssim.cc Machine::Run()&#x200B;"></a>(c) machine/mipssim.cc Machine::Run()&#x200B;</h3><p>Starting from &#x201C;machine/mipssim.cc Machine::Run()&#x200B;&#x201D; is called.</p>
<h4 id="1-void-Machine-Run"><a href="#1-void-Machine-Run" class="headerlink" title="1. void Machine::Run()"></a>1. void Machine::Run()</h4><p><strong>machine/mippsim.cc</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Machine::Run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/* storage for decoded instruction */</span></span><br><span class="line">    Instruction *instr = <span class="keyword">new</span> Instruction; /</span><br><span class="line"></span><br><span class="line">    kernel-&gt;interrupt-&gt;setStatus(UserMode);</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        OneInstruction(instr);</span><br><span class="line">        kernel-&gt;interrupt-&gt;OneTick();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h4 id="2-void-Machine-OneInstruction-Instruction-instr"><a href="#2-void-Machine-OneInstruction-Instruction-instr" class="headerlink" title="2. void Machine::OneInstruction(Instruction *instr)"></a>2. void Machine::OneInstruction(Instruction *instr)</h4><p><strong>machine/mippsim.cc</strong></p>
<p>OneInstruction() &#x8B80;&#x53D6;&#x7576;&#x524D;&#x6307;&#x4EE4;&#xFF0C;&#x7D93;&#x904E; decode()&#xFF0C;&#x6211;&#x5011;&#x53EF;&#x4EE5;&#x5F97;&#x5230; rs / rt / rd / opCode&#xFF0C;&#x4F9D;&#x7167; opCode &#x6211;&#x5011;&#x5C0D; register[rs] &#x548C; register[rt] &#x9032;&#x884C;&#x5C0D;&#x61C9;&#x7684;&#x64CD;&#x4F5C;&#xFF0C;&#x4E26;&#x4E14;&#x5C07;&#x7D50;&#x679C;&#x5BEB;&#x5165; register[rd]&#x3002;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Machine::OneInstruction</span><span class="params">(Instruction *instr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> raw;</span><br><span class="line">    <span class="comment">/* Fetch instruction */</span> </span><br><span class="line">    <span class="keyword">if</span> (!ReadMem(registers[PCReg], <span class="number">4</span>, &amp;raw))</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">/* exception occurred */</span></span><br><span class="line"></span><br><span class="line">    instr-&gt;value = raw;</span><br><span class="line">    instr-&gt;Decode();</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">int</span> pcAfter = registers[NextPCReg] + <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rs, rt, imm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Execute the instruction */</span></span><br><span class="line">    <span class="keyword">switch</span> (instr-&gt;opCode) {</span><br><span class="line">        <span class="keyword">case</span> OP_ADD:</span><br><span class="line">        sum = registers[instr-&gt;rs] + registers[instr-&gt;rt];</span><br><span class="line">	  registers[instr-&gt;rd] = sum;</span><br><span class="line">	  <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* Advance program counters */</span></span><br><span class="line">    registers[PrevPCReg] = registers[PCReg];</span><br><span class="line">    registers[PCReg] = registers[NextPCReg];</span><br><span class="line">    registers[NextPCReg] = pcAfter;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>&#x4E00;&#x500B; Instruction &#x662F; 4 &#x500B; byte&#xFF0C;&#x6070;&#x597D;&#x662F;&#x4E00;&#x500B; unsigned int &#x7684;&#x5927;&#x5C0F;&#xFF0C;&#x56E0;&#x6B64;&#x6211;&#x5011;&#x7528;&#x4E00;&#x500B; unsigned int &#x4F86;&#x5132;&#x5B58;&#x4ED6;&#x3002;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Instruction</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Decode</span><span class="params">()</span></span>;	</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">char</span> opCode; <span class="comment">/* Type of instruction */</span></span><br><span class="line">    <span class="keyword">char</span> rs, rt, rd; <span class="comment">/* Three registers from instruction */</span></span><br><span class="line">    <span class="keyword">int</span> extra; <span class="comment">/* Immediate or target or shamt field or offset */</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure>

<h4 id="3-void-Instruction-Decode"><a href="#3-void-Instruction-Decode" class="headerlink" title="3. void Instruction::Decode()"></a>3. void Instruction::Decode()</h4><p><strong>machine/mippsim.cc</strong></p>
<p>&#x5C07;&#x6211;&#x5011;&#x5B58;&#x5728; unsigned int value &#x88E1;&#x7684; instruction decode&#xFF0C;&#x6211;&#x5011;&#x53EF;&#x4EE5;&#x5F97;&#x5230;&#x9019;&#x4E00;&#x5230;&#x6307;&#x4EE4;&#x7684; rs / rt / rd / opCode&#x3002;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Instruction::Decode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    OpInfo *opPtr;</span><br><span class="line">    </span><br><span class="line">    rs = (value &gt;&gt; <span class="number">21</span>) &amp; <span class="number">0x1f</span>;</span><br><span class="line">    rt = (value &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x1f</span>;</span><br><span class="line">    rd = (value &gt;&gt; <span class="number">11</span>) &amp; <span class="number">0x1f</span>;</span><br><span class="line">    opPtr = &amp;opTable[(value &gt;&gt; <span class="number">26</span>) &amp; <span class="number">0x3f</span>];</span><br><span class="line">    opCode = opPtr-&gt;opCode;</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><h3 id="a-modify-pageTable-building"><a href="#a-modify-pageTable-building" class="headerlink" title="(a) modify pageTable building"></a>(a) modify pageTable building</h3><p>&#x5728;&#x4FEE;&#x6539;&#x4E4B;&#x524D;&#xFF0C;&#x5728; addrSpace &#x7269;&#x4EF6;&#x5EFA;&#x7ACB;&#x6642;&#x5C31;&#x6703;&#x5EFA;&#x7ACB; pageTable&#xFF0C;&#x9810;&#x8A2D; NachOS &#x53EA;&#x6703;&#x904B;&#x884C;&#x4E00;&#x500B;&#x53EF;&#x57F7;&#x884C;&#x6A94;&#xFF0C;&#x56E0;&#x6B64;&#x9019;&#x500B; pageTable &#x6DB5;&#x84CB;&#x6574;&#x500B; physical memory&#xFF0C;&#x56E0;&#x6B64;&#x4E0D;&#x9700;&#x8981;&#x505A;&#x4EFB;&#x4F55; virtualPage &#x548C; physicalPage &#x4E4B;&#x9593;&#x7684;&#x6620;&#x5C04;&#x3002; </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">AddrSpace::AddrSpace()</span><br><span class="line">{</span><br><span class="line">    pageTable = <span class="keyword">new</span> TranslationEntry[NumPhysPages];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NumPhysPages; i++) {</span><br><span class="line">        pageTable[i].virtualPage = i;	</span><br><span class="line">        pageTable[i].physicalPage = i;</span><br><span class="line">        pageTable[i].valid = TRUE;</span><br><span class="line">        pageTable[i].use = FALSE;</span><br><span class="line">        pageTable[i].dirty = FALSE;</span><br><span class="line">        pageTable[i].readOnly = FALSE;  </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* zero out the entire address space */</span></span><br><span class="line">    bzero(kernel-&gt;machine-&gt;mainMemory, MemorySize);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>&#x4F46;&#x662F;&#x7576;&#x6211;&#x5011;&#x60F3;&#x8981;&#x540C;&#x6642;&#x57F7;&#x884C;&#x4E00;&#x500B;&#x4EE5;&#x4E0A;&#x7684;&#x53EF;&#x57F7;&#x884C;&#x6A94;&#x6642;&#xFF0C;&#x6703;&#x767C;&#x751F;&#x554F;&#x984C;&#xFF0C;&#x56E0;&#x70BA;&#x55AE;&#x4E00;&#x500B; thread &#x4E0D;&#x80FD;&#x64C1;&#x6709;&#x6574;&#x500B; physical memory &#x7684;&#x6240;&#x6709;&#x6B0A;&#xFF0C;&#x6BCF;&#x500B; thread &#x90FD;&#x53EA;&#x80FD;&#x64C1;&#x6709;&#x90E8;&#x4EFD;&#x7684; physical memory&#xFF0C;&#x56E0;&#x6B64;&#x6211;&#x4FEE;&#x6539; pageTable &#x7684;&#x5EFA;&#x7ACB;&#xFF0C;&#x6BCF;&#x500B; thread &#x7684; pageTable &#x7684;&#x5C3A;&#x5BF8;&#x53EA;&#x5305;&#x542B;&#x4ED6;&#x6240;&#x9700;&#x8981;&#x7684;&#x90E8;&#x4EFD;&#x3002;&#x4F46;&#x662F;&#x5728;&#x6211;&#x5011;&#x5C07;&#x53EF;&#x57F7;&#x884C;&#x6A94; load &#x9032; memory &#x4E4B;&#x524D;&#xFF0C;&#x6211;&#x5011;&#x4E26;&#x4E0D;&#x77E5;&#x9053;&#x9019;&#x500B;&#x53EF;&#x57F7;&#x884C;&#x6A94;&#x9700;&#x8981;&#x591A;&#x5C11;&#x7A7A;&#x9593;&#xFF0C; &#x56E0;&#x6B64;&#x6211;&#x5C07; pageTable &#x7684;&#x5EFA;&#x7ACB;&#x5EF6;&#x5F8C;&#xFF0C;&#x76F4;&#x5230;&#x53EF;&#x57F7;&#x884C;&#x6A94;&#x7684; header &#x8B80;&#x5165;&#xFF0C;&#x6211;&#x5011;&#x77E5;&#x9053;&#x9019;&#x500B;&#x53EF;&#x57F7;&#x884C;&#x6A94;&#x7684;&#x5927;&#x5C0F;&#x4E4B;&#x5F8C;&#xFF0C;&#x624D;&#x5EFA;&#x7ACB; pageTable&#x3002;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AddrSpace::Load</span><span class="params">(<span class="keyword">char</span> *fileName)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ...</span><br><span class="line">    numPages = divRoundUp(size, PageSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* setup pageTable after we know how much space the program needs */</span></span><br><span class="line">    pageTable = <span class="keyword">new</span> TranslationEntry[numPages];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numPages; i++) {</span><br><span class="line">        pageTable[i].virtualPage = i;	</span><br><span class="line">        pageTable[i].physicalPage = kernel-&gt;usedPhyPage-&gt;checkAndSet();</span><br><span class="line">        pageTable[i].valid = <span class="literal">true</span>;</span><br><span class="line">        pageTable[i].use = <span class="literal">false</span>;</span><br><span class="line">        pageTable[i].dirty = <span class="literal">false</span>;</span><br><span class="line">        pageTable[i].readOnly = <span class="literal">false</span>; </span><br><span class="line"></span><br><span class="line">        <span class="comment">/* zero out this physical page */</span></span><br><span class="line">        bzero(kernel-&gt;machine-&gt;mainMemory + pageTable[i].physicalPage * </span><br><span class="line">              PageSize, PageSize);</span><br><span class="line">    }</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>&#x65B0;&#x589E; class UsedPhyPage &#x4F86;&#x7BA1;&#x7406; physical memory&#xFF0C;&#x4F7F;&#x7528;&#x4E00;&#x500B; array &#x7D00;&#x9304; physical page &#x662F;&#x5426;&#x5DF2;&#x7D93;&#x88AB;&#x4F7F;&#x7528;&#x3002;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UsedPhyPage</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> *pages; <span class="comment">/* 0 for unused, 1 for used */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">checkAndSet</span><span class="params">()</span></span>;</span><br><span class="line">...</span><br><span class="line">};</span><br></pre></td></tr></table></figure>

<p>checkAndSet() &#x56DE;&#x50B3;&#x4E00;&#x500B;&#x672A;&#x4F7F;&#x7528;&#x7684; physical page &#x7684; pageNum&#xFF0C;&#x5982;&#x679C;&#x6574;&#x500B; physical memory &#x90FD;&#x5DF2;&#x7D93;&#x88AB;&#x4F7F;&#x7528;&#xFF0C;&#x56DE;&#x50B3; -1&#x3002;&#x4F7F;&#x7528;&#x9019;&#x500B;&#x65B9;&#x6CD5;&#x5EFA;&#x7ACB; pageTable&#xFF0C;&#x6BCF;&#x500B; thread &#x7BA1;&#x7406;&#x81EA;&#x5DF1;&#x7684; pageTable&#xFF0C;&#x4F7F;&#x7528;&#x5C6C;&#x65BC;&#x81EA;&#x5DF1;&#x7684; memory space &#x3002;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pageTable[i].physicalPage = kernel-&gt;usedPhyPage-&gt;checkAndSet();</span><br></pre></td></tr></table></figure>

<h3 id="b-modify-executable-file-loading"><a href="#b-modify-executable-file-loading" class="headerlink" title="(b) modify executable file loading"></a>(b) modify executable file loading</h3><p>&#x7576;&#x6211;&#x5011;&#x8981;&#x57F7;&#x884C;&#x4E00;&#x500B;&#x53EF;&#x57F7;&#x884C;&#x6A94;&#xFF0C;&#x9996;&#x5148;&#x8981;&#x628A;&#x8A72;&#x6A94;&#x6848; load &#x9032; memory&#xFF0C;&#x4E00;&#x500B; NachOS &#x53EF;&#x57F7;&#x884C;&#x6A94;&#x5206;&#x6210;&#x56DB;&#x500B;&#x90E8;&#x4EFD;&#xFF0C;header / code / initData / readonlyData&#xFF0C;&#x6211;&#x5011;&#x9996;&#x5148;&#x8B80;&#x51FA; header &#x4F86;&#x7372;&#x53D6;&#x6A94;&#x6848;&#x7684; metadata&#xFF0C;&#x6839;&#x64DA;&#x6B64; metadata &#x6211;&#x5011;&#x53EF;&#x4EE5;&#x77E5;&#x9053; code / initData / readonlyData &#x5728;&#x6A94;&#x6848;&#x4E2D;&#x7684;&#x8D77;&#x59CB;&#x4F4D;&#x7F6E;&#x548C;&#x5927;&#x5C0F;&#x3002;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">noffHeader</span> {</span></span><br><span class="line">   <span class="keyword">int</span> noffMagic;	<span class="comment">/* should be NOFFMAGIC */</span></span><br><span class="line">   Segment code; <span class="comment">/* executable code segment */</span> </span><br><span class="line">   Segment initData; <span class="comment">/* initialized data segment */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RDATA</span></span><br><span class="line">   Segment readonlyData;	<span class="comment">/* read only data */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">   Segment uninitData; <span class="comment">/* uninitialized data segment, should be zero&apos;ed </span></span><br><span class="line"><span class="comment">                        * before use */</span></span><br><span class="line">} NoffHeader;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">segment</span> {</span></span><br><span class="line">    <span class="keyword">int</span> virtualAddr; <span class="comment">/* location of segment in virt addr space */</span></span><br><span class="line">    <span class="keyword">int</span> inFileAddr; <span class="comment">/* location of segment in this file */</span></span><br><span class="line">    <span class="keyword">int</span> size; <span class="comment">/* size of segment */</span></span><br><span class="line">} Segment;</span><br></pre></td></tr></table></figure>

<p>&#x6211;&#x5011;&#x7684;&#x76EE;&#x6A19;&#x662F;&#x628A;&#x6BCF;&#x4E00;&#x6BB5; segment &#x5F9E;&#x4ED6;&#x5728;&#x6A94;&#x6848;&#x88E1;&#x7684;&#x4F4D;&#x7F6E;&#xFF0C;load &#x5230;&#x4ED6;&#x7684; virtualAddr &#x6240;&#x5C0D;&#x61C9;&#x7684; physicalAddr&#x3002;&#x672A;&#x4FEE;&#x6539;&#x524D;&#x56E0;&#x70BA;&#x6574;&#x500B; memory &#x53EA;&#x6709;&#x4E00;&#x500B; thread  &#x5728;&#x4F7F;&#x7528;&#xFF0C;&#x6240;&#x4EE5; physicalAddr &#x548C; virtualAddr &#x76F8;&#x540C;&#xFF0C;&#x4E26;&#x4E14;&#x56E0;&#x70BA;&#x9019;&#x500B;&#x53EF;&#x57F7;&#x884C;&#x6A94;&#x662F;&#x7B2C;&#x4E00;&#x500B;&#x4E5F;&#x662F;&#x552F;&#x4E00;&#x4E00;&#x500B; load &#x9032; memory &#x7684;&#x6A94;&#x6848;&#xFF0C;&#x56E0;&#x6B64;&#x6574;&#x500B;&#x7A7A;&#x9593;&#x662F;&#x9023;&#x7E8C;&#x4E14;&#x7121;&#x4EBA;&#x4F7F;&#x7528;&#x7684;&#xFF0C;&#x628A;&#x53EF;&#x57F7;&#x884C;&#x6A94;&#x642C;&#x79FB;&#x5230; memory&#xFF0C;&#x6BCF;&#x4E00;&#x500B; segment &#x53EA;&#x8981;&#x642C;&#x79FB;&#x4E00;&#x6B21;&#x5373;&#x53EF;&#x3002;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AddrSpace::Load</span><span class="params">(<span class="keyword">char</span> *fileName)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/* read header file */</span></span><br><span class="line">    OpenFile *executable = kernel-&gt;fileSystem-&gt;Open(fileName);</span><br><span class="line">    NoffHeader noffH;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size;</span><br><span class="line">    executable-&gt;ReadAt((<span class="keyword">char</span> *)&amp;noffH, <span class="keyword">sizeof</span>(noffH), <span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RDATA</span></span><br><span class="line">    size = noffH.code.size + noffH.readonlyData.size +  </span><br><span class="line">           noffH.initData.size + noffH.uninitData.size + UserStackSize;	</span><br><span class="line">    ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    numPages = divRoundUp(size, PageSize);</span><br><span class="line">    size = numPages * PageSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (noffH.code.size &gt; <span class="number">0</span>) {</span><br><span class="line">        executable-&gt;ReadAt(</span><br><span class="line">                  &amp;(kernel-&gt;machine-&gt;mainMemory[noffH.code.virtualAddr]),</span><br><span class="line">                  noffH.code.size, noffH.code.inFileAddr);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (noffH.initData.size &gt; <span class="number">0</span>) {</span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RDATA</span></span><br><span class="line">    <span class="keyword">if</span> (noffH.readonlyData.size &gt; <span class="number">0</span>) {</span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>&#x5728;&#x4FEE;&#x6539;&#x4E4B;&#x5F8C;&#xFF0C;memory &#x7531;&#x591A;&#x500B; thread &#x5171;&#x7528;&#xFF0C;&#x56E0;&#x6B64;&#x5728;&#x5C07;&#x8CC7;&#x6599;&#x5F9E;&#x6A94;&#x6848; load &#x9032; memory &#x4E4B;&#x524D;&#xFF0C;&#x9700;&#x8981;&#x5148;&#x4F7F;&#x7528; Translate() &#x5C07; virtualAddr &#x8F49;&#x63DB;&#x6210;&#x5C0D;&#x61C9;&#x7684; physicalAddr&#x3002;&#x56E0;&#x70BA;&#x6709;&#x591A;&#x500B; thread &#x5171;&#x7528; memory&#xFF0C;memory &#x4E2D;&#x53EF;&#x80FD;&#x5DF2;&#x7D93;&#x6709;&#x4E9B; page &#x88AB;&#x5225;&#x7684; thread &#x4F54;&#x7528;&#x4E86;&#xFF0C;&#x56E0;&#x6B64;&#x8CC7;&#x6599;&#x9700;&#x8981;&#x4E00;&#x500B; page &#x4E00;&#x500B; page &#x7684; load &#x9032; memory &#xFF0C;&#x800C;&#x4E0D;&#x80FD;&#x6574;&#x6BB5; segment (&#x5305;&#x542B;&#x6578;&#x500B; page ) load &#x9032; memory &#x3002; &#x4EE5;&#x4E0B;&#x5716;&#x70BA;&#x4F8B;&#xFF0C;&#x9019;&#x500B;&#x6A94;&#x6848;&#x6709; 4 &#x500B; page&#xFF0C;&#x6BCF;&#x4E00;&#x500B; page &#x6709; 5 &#x500B; bytes&#xFF0C;virtal page &#x548C; physical page &#x7684;&#x5C0D;&#x61C9;&#x5982;&#x4E0B;&#xFF0C;&#x53EF;&#x4EE5;&#x770B;&#x5230; virtual page &#x662F;&#x9023;&#x7E8C;&#x7684; (0 , 1 , 2 , 3)&#xFF0C;&#x4F46; physical page &#x4E0D;&#x662F;&#x9023;&#x7E8C;&#x7684; (6 , 9 , 7 , 11)&#xFF0C;&#x56E0;&#x6B64;&#x6211;&#x5011;&#x5728;&#x642C;&#x79FB;&#x8CC7;&#x6599;&#x6642;&#xFF0C;&#x4E00;&#x6B21;&#x53EA;&#x80FD;&#x642C;&#x4E00;&#x500B; virtual page &#x7684;&#x8CC7;&#x6599;&#x3002;</p>
<p><img src="/2021/07/18/NachOS-MP2/image1.svg"></p>
<p>&#x5047;&#x8A2D;&#x6211;&#x5011;&#x6240;&#x8981;&#x642C;&#x79FB;&#x7684;&#x8CC7;&#x6599;&#x5F9E; virtual addr 8 - 17&#xFF0C;&#x53EF;&#x4EE5;&#x770B;&#x5230;&#x4ED6;&#x5305;&#x542B;&#x4E86; 3 &#x500B; page&#xFF0C;&#x56E0;&#x6B64;&#x6211;&#x5011;&#x9700;&#x8981;&#x5206;&#x6210; 3 &#x6B21;&#x8F49;&#x79FB;&#x8CC7;&#x6599;&#xFF0C;&#x8CC7;&#x6599;&#x5F9E; inFile addr &#x642C;&#x79FB;&#x5230;&#x6211;&#x5011;&#x6307;&#x5B9A;&#x7684; virtual addr &#x5C0D;&#x61C9;&#x5230;&#x7684; physical addr&#xFF0C;virtual addr &#x53EF;&#x4EE5;&#x81EA;&#x8A02;&#xFF0C;&#x5728; NachOS &#x88E1; virtual addr &#x548C; inFile addr &#x662F;&#x76F8;&#x540C;&#x7684;&#x3002; </p>
<p><img src="/2021/07/18/NachOS-MP2/image2.svg"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AddrSpace::Load</span><span class="params">(<span class="keyword">char</span> *fileName)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> virtualAddr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> physicalAddr;</span><br><span class="line">    <span class="keyword">int</span> unReadSize;</span><br><span class="line">    <span class="keyword">int</span> chunkStart;</span><br><span class="line">    <span class="keyword">int</span> chunkSize;</span><br><span class="line">    <span class="keyword">int</span> inFilePosiotion;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (noffH.code.size &gt; <span class="number">0</span>) {</span><br><span class="line">        unReadSize = noffH.code.size;</span><br><span class="line">        chunkStart = noffH.code.virtualAddr;</span><br><span class="line">        chunkSize = <span class="number">0</span>;</span><br><span class="line">        inFilePosiotion = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* while still unread code */</span></span><br><span class="line">        <span class="keyword">while</span>(unReadSize &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">/* first chunk and last chunk might not be full */</span></span><br><span class="line">            chunkSize =  calChunkSize(chunkStart, unReadSize); </span><br><span class="line">            <span class="comment">/* mapping from virtual addr to physical addr */</span></span><br><span class="line">            Translate(chunkStart, &amp;physicalAddr, <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            executable-&gt;ReadAt(                     </span><br><span class="line">                  &amp;(kernel-&gt;machine-&gt;mainMemorymainMemory[physicalAddr]), </span><br><span class="line">                  chunkSize, noffH.code.inFileAddr + inFilePosiotion);</span><br><span class="line"></span><br><span class="line">            unReadSize = unReadSize - chunkSize;</span><br><span class="line">            chunkStart = chunkStart + chunkSize;</span><br><span class="line">            inFilePosiotion = inFilePosiotion + chunkSize;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (noffH.initData.size &gt; <span class="number">0</span>) {</span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RDATA</span></span><br><span class="line">    <span class="keyword">if</span> (noffH.readonlyData.size &gt; <span class="number">0</span>) {</span><br><span class="line">        ...        </span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h2 id="Questions"><a href="#Questions" class="headerlink" title="Questions"></a>Questions</h2><h3 id="a-allocate-memory-space-amp-initiate-memory-content"><a href="#a-allocate-memory-space-amp-initiate-memory-content" class="headerlink" title="(a) allocate memory space &amp; initiate memory content"></a>(a) allocate memory space &amp; initiate memory content</h3><ul>
<li><strong>How Nachos allocates the memory space for new thread(process)?</strong></li>
<li><strong>How Nachos initializes the memory content of a thread(process), including loading the user binary code in the memory?</strong></li>
<li><strong>How Nachos initializes the machine status (registers, etc) before running a thread(process)?</strong></li>
</ul>
<p>&#x6BCF;&#x4E00;&#x500B;&#x53EF;&#x57F7;&#x884C;&#x6A94;&#x90FD;&#x9700;&#x8981; new &#x4E00;&#x500B;&#x65B0;&#x7684; thread &#x4F86;&#x57F7;&#x884C;&#x3002;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* threads/kernel.cc&#x200B; */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Kernel::Exec</span><span class="params">(<span class="keyword">char</span>* name)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    t[threadNum] = <span class="keyword">new</span> Thread(name, threadNum);</span><br><span class="line">    t[threadNum]-&gt;space = <span class="keyword">new</span> AddrSpace();    </span><br><span class="line">    t[threadNum]-&gt;Fork((VoidFunctionPtr)&amp;ForkExecute,</span><br><span class="line">                       (<span class="keyword">void</span>*)t[threadNum]);</span><br><span class="line">    threadNum++;</span><br><span class="line">    <span class="keyword">return</span> threadNum<span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>&#x9019;&#x500B; thread &#x6240;&#x8981;&#x57F7;&#x884C;&#x7684; function &#x548C;&#x4ED6;&#x6240;&#x9700;&#x8981;&#x7684; argument &#x4E1F;&#x9032; StackAllocate&#xFF0C;&#x6B64;&#x6642;&#x6211;&#x5011;&#x8981;&#x57F7;&#x884C;&#x7684; function &#x662F; ForkExecute&#x3002;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* threads/thread.cc */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Thread::Fork</span><span class="params">(VoidFunctionPtr func, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Interrupt *interrupt = kernel-&gt;interrupt;</span><br><span class="line">    Scheduler *scheduler = kernel-&gt;scheduler;</span><br><span class="line">    IntStatus oldLevel;</span><br><span class="line">    </span><br><span class="line">    StackAllocate(func, arg);</span><br><span class="line"></span><br><span class="line">    oldLevel = interrupt-&gt;SetLevel(IntOff);</span><br><span class="line">    scheduler-&gt;ReadyToRun(<span class="keyword">this</span>);</span><br><span class="line">    (<span class="keyword">void</span>) interrupt-&gt;SetLevel(oldLevel);</span><br><span class="line">}   </span><br></pre></td></tr></table></figure>

<p>&#x5EFA;&#x7ACB;&#x548C;&#x521D;&#x59CB;&#x5316;&#x9019;&#x500B; thread &#x7684; execution stack&#x3002;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* threads/thread.cc */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Thread::StackAllocate</span> <span class="params">(VoidFunctionPtr func, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">stack</span> = (<span class="keyword">int</span> *) AllocBoundedArray(StackSize * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    ...</span><br><span class="line">    machineState[PCState] = (<span class="keyword">void</span>*)ThreadRoot;</span><br><span class="line">    machineState[StartupPCState] = (<span class="keyword">void</span>*)ThreadBegin;</span><br><span class="line">    machineState[InitialPCState] = (<span class="keyword">void</span>*)func;</span><br><span class="line">    machineState[InitialArgState] = (<span class="keyword">void</span>*)arg;</span><br><span class="line">    machineState[WhenDonePCState] = (<span class="keyword">void</span>*)ThreadFinish;</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>func &#x662F;&#x4E4B;&#x5F8C;&#x8981;&#x57F7;&#x884C;&#x7684;&#x51FD;&#x5F0F;&#x3002;<br>machineState[InitialPCState] = (void*)func;</p>
<p>ForkExecute &#x662F;&#x6211;&#x5011;&#x60F3;&#x57F7;&#x884C;&#x7684; func&#xFF0C;&#x5C07;&#x6211;&#x5011;&#x6307;&#x5B9A;&#x7684;&#x53EF;&#x57F7;&#x884C;&#x6A94; load &#x9032; memory&#xFF0C;&#x7136;&#x5F8C;&#x57F7;&#x884C;&#x4ED6;&#x3002;&#x6B64;&#x6642;&#x5206;&#x914D;&#x7A7A;&#x9593;&#x4E26;&#x4E14;&#x5EFA;&#x7ACB; pageTable&#x3002;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* threads/kernel.cc */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ForkExecute</span><span class="params">(Thread *t)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/* allocate pageTable for this process */</span></span><br><span class="line">    <span class="keyword">if</span> ( !t-&gt;space-&gt;Load(t-&gt;getName()) ) {</span><br><span class="line">    	<span class="keyword">return</span>; <span class="comment">/* executable not found */</span></span><br><span class="line">    }</span><br><span class="line">    t-&gt;space-&gt;Execute(t-&gt;getName());</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>&#x5C07;&#x53EF;&#x57F7;&#x884C;&#x6A94;&#x8B80;&#x5165; memory&#x3002;&#x9996;&#x5148;&#x8B80;&#x5165;&#x53EF;&#x57F7;&#x884C;&#x6A94;&#x7684; header&#xFF0C;&#x8B80;&#x53D6; header &#x4E4B;&#x5F8C;&#x5C31;&#x80FD;&#x77E5;&#x9053;&#x6A94;&#x6848;&#x5927;&#x5C0F;&#xFF0C;&#x5EFA;&#x7ACB; pageTable&#x3002;&#x5EFA;&#x7ACB; pageTable &#x6642;&#x6703;&#x628A;&#x8A72; thread &#x5206;&#x914D;&#x5230;&#x7684; physical page &#x6E05;&#x7A7A;&#x3002;&#x6709;&#x4E86; pageTable &#x4E4B;&#x5F8C;&#x5C31;&#x80FD;&#x628A;&#x53EF;&#x57F7;&#x884C;&#x6A94;&#x7684;&#x5176;&#x4ED6;&#x90E8;&#x4EFD; load &#x9032; memory &#x4E86;&#x3002;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t-&gt;space-&gt;Load(t-&gt;getName())</span><br></pre></td></tr></table></figure>

<h3 id="b-page-table-amp-address-translation"><a href="#b-page-table-amp-address-translation" class="headerlink" title="(b) page table &amp; address translation"></a>(b) page table &amp; address translation</h3><ul>
<li><strong>How Nachos creates and manages the page table?</strong></li>
<li><strong>How Nachos translates address?</strong></li>
</ul>
<p>class UsedPhyPage &#x53EF;&#x4EE5;&#x5E6B;&#x52A9;&#x5EFA;&#x7ACB;&#x548C;&#x7BA1;&#x7406; physical memory&#xFF0C;&#x5728;&#x5B8C;&#x6210; pageTable &#x4E4B;&#x5F8C;&#x4F7F;&#x7528; Translate &#x5373;&#x53EF;&#x5C07; virtual addr &#x8F49;&#x63DB;&#x70BA; physical addr&#x3002;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* machine/translate.cc */</span></span><br><span class="line"></span><br><span class="line"><span class="function">ExceptionType</span></span><br><span class="line"><span class="function"><span class="title">Machine::Translate</span><span class="params">(<span class="keyword">int</span> virtAddr, <span class="keyword">int</span>* physAddr, <span class="keyword">int</span> size, <span class="keyword">bool</span> writing)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> vpn, offset;</span><br><span class="line">    TranslationEntry *entry;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> pageFrame;</span><br><span class="line"></span><br><span class="line">    vpn = (<span class="keyword">unsigned</span>) virtAddr / PageSize; <span class="comment">/* virtual page number */</span></span><br><span class="line">    offset = (<span class="keyword">unsigned</span>) virtAddr % PageSize; <span class="comment">/* offset within the page */</span></span><br><span class="line">    ...</span><br><span class="line">    entry = &amp;pageTable[vpn]; <span class="comment">/* translate using pageTable */</span></span><br><span class="line">    ...</span><br><span class="line">    pageFrame = entry-&gt;physicalPage;</span><br><span class="line">    ...</span><br><span class="line">    *physAddr = pageFrame * PageSize + offset;</span><br><span class="line">    <span class="keyword">return</span> NoException;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TranslationEntry</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> virtualPage;</span><br><span class="line">    <span class="keyword">int</span> physicalPage;</span><br><span class="line">    ...</span><br><span class="line">};</span><br></pre></td></tr></table></figure>

<h3 id="c-process-control-block"><a href="#c-process-control-block" class="headerlink" title="(c) process control block"></a>(c) process control block</h3><ul>
<li><strong>Which object&#x200B; in Nachos acts the role of &#x200B; process control block?</strong></li>
</ul>
<p>PCB (process control block) &#x5305;&#x542B;&#x548C; process / thread &#x76F8;&#x95DC;&#x7684;&#x4E00;&#x4E9B;&#x8CC7;&#x8A0A;&#xFF0C;&#x4F8B;&#x5982; :</p>
<ul>
<li>process state</li>
<li>program counter</li>
<li>CPU register</li>
<li>CPU scheduling info (e.g. priority)</li>
<li>memory management info (e.g. base / limit register)</li>
<li>and more</li>
</ul>
<p>class Thread &#x6709;&#x5F88;&#x591A; PCB &#x61C9;&#x8A72;&#x5305;&#x542B;&#x7684;&#x8CC7;&#x8A0A;&#xFF0C;&#x4F8B;&#x5982; :</p>
<ul>
<li>process state &#x2013;&gt; status</li>
<li>memory management &#x2013;&gt; space</li>
<li>CPU register &#x2013;&gt; machineState</li>
<li>and more</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span> {</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> *stackTop;	 <span class="comment">/* the current stack pointer */</span></span><br><span class="line">    <span class="keyword">void</span> *machineState[MachineStateSize]; <span class="comment">/* all registers except for </span></span><br><span class="line"><span class="comment">                                           * stackTop */</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> *<span class="built_in">stack</span>; <span class="comment">/* bottom of the stack */</span> </span><br><span class="line">    ThreadStatus status;	 <span class="comment">/* ready, running or blocked */</span></span><br><span class="line">    <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span> ID;</span><br><span class="line">    <span class="keyword">int</span> userRegisters[NumTotalRegs]; <span class="comment">/* user-level CPU register state */</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    AddrSpace *space; <span class="comment">/* user code this thread is running */</span></span><br><span class="line">    ...</span><br><span class="line">};</span><br></pre></td></tr></table></figure>

<h3 id="d-ReadyToRun-queue"><a href="#d-ReadyToRun-queue" class="headerlink" title="(d) ReadyToRun queue"></a>(d) ReadyToRun queue</h3><ul>
<li><strong>When and how does a thread get added into the ReadyToRun queue of Nachos CPU scheduler?</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* threads/thread.cc */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Thread::Fork</span><span class="params">(VoidFunctionPtr func, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Interrupt *interrupt = kernel-&gt;interrupt;</span><br><span class="line">    Scheduler *scheduler = kernel-&gt;scheduler;</span><br><span class="line">    IntStatus oldLevel;</span><br><span class="line">    </span><br><span class="line">    StackAllocate(func, arg);</span><br><span class="line"></span><br><span class="line">    oldLevel = interrupt-&gt;SetLevel(IntOff);</span><br><span class="line">    scheduler-&gt;ReadyToRun(<span class="keyword">this</span>);</span><br><span class="line">    (<span class="keyword">void</span>) interrupt-&gt;SetLevel(oldLevel);</span><br><span class="line">}   </span><br></pre></td></tr></table></figure>

<p>&#x7576;&#x4E00;&#x500B; thread &#x5DF2;&#x7D93;&#x5EFA;&#x7ACB;&#x597D;&#x4ED6;&#x7684; stack&#xFF0C;&#x5C07;&#x4ED6;&#x52A0;&#x5165; readyList&#xFF0C;&#x7576; scheduler &#x9700;&#x8981;&#x5B89;&#x6392; thread &#x4F86;&#x57F7;&#x884C;&#x7684;&#x6642;&#x5019;&#xFF0C;&#x5C31;&#x5F9E; readyList dequeue &#x4E00;&#x500B; thread &#x4F86;&#x57F7;&#x884C;&#x3002;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheduler-&gt;ReadyToRun(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>

<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>[1] shawn2000100/10810CS_342301_OperatingSystem<br><a target="_blank" rel="noopener" href="https://github.com/shawn2000100/10810CS_342301_OperatingSystem">https://github.com/shawn2000100/10810CS_342301_OperatingSystem</a><br>[2] OS::NachOS::HW1<br><a target="_blank" rel="noopener" href="http://blog.terrynini.tw/tw/OS-NachOS-HW1/">http://blog.terrynini.tw/tw/OS-NachOS-HW1/</a><br>[3] Nachos Project 3<br><a target="_blank" rel="noopener" href="https://www.csie.ntu.edu.tw/~b96201044/Project3_Slide_2010.pdf">https://www.csie.ntu.edu.tw/~b96201044/Project3_Slide_2010.pdf</a></p>
</div></article></div></main><footer><div class="paginator"><a class="next" href="../../14/NachOS-MP1/">NEXT</a></div><div class="copyright"><p>Â© 2019 - 2021 <a href="http://example.com">John Doe</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/claymcleod/hexo-theme-hermes" target="_blank">hexo-theme-hermes</a>. </p><p>Logo made by <a target="_blank" rel="noopener" href="https://www.flaticon.com/authors/freepik">Freepik</a> from <a target="_blank" rel="noopener" href="https://flaticon.com">www.flaticon.com</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>