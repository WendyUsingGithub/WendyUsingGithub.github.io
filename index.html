<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Hexo</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="favicon.png"><link rel="stylesheet" href="css/hermes.css"><link rel="search" type="application/opensearchdescription+xml" href="http://example.com/atom.xml" title="Hexo"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="atom.xml" title="Hexo" type="application/atom+xml">
</head><body><div class="wrap"><header><a class="logo-link" href="index.html"><img src="favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link active" href="index.html" target="_self">BLOG</a></li><li class="nav-list-item"><a class="nav-list-link" href="https://github.com/WendyUsingGithub" target="_blank">GITHUB</a></li><li class="nav-list-item"><a class="nav-list-link" href="archives/" target="_self">ARCHIVE</a></li></ul></header><main class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a class="post-title-link" href="2021/07/18/NachOS-MP2/">NachOS MP2</a></h2><div class="post-info">Jul 18, 2021</div><div class="post-content"><h2 id="Trace-code"><a href="#Trace-code" class="headerlink" title="Trace code"></a>Trace code</h2><h3 id="a-threads-kernel-cc&#x200B;-Kernel-ExecAll-&#x200B;"><a href="#a-threads-kernel-cc&#x200B;-Kernel-ExecAll-&#x200B;" class="headerlink" title="(a) threads/kernel.cc&#x200B; Kernel::ExecAll()&#x200B;"></a>(a) threads/kernel.cc&#x200B; Kernel::ExecAll()&#x200B;</h3><p>Starting from &#x201C;threads/kernel.cc&#x200B; Kernel::ExecAll()&#x200B;&#x201D; is called.</p>
<h4 id="1-int-main-int-argc-char-argv"><a href="#1-int-main-int-argc-char-argv" class="headerlink" title="1. int main(int argc, char **argv)"></a>1. int main(int argc, char **argv)</h4><p><strong>threads/main.cc</strong></p>
<p>kernel &#x5BA3;&#x544A;&#x70BA;&#x5168;&#x57DF;&#x8B8A;&#x6578;&#xFF0C;&#x6574;&#x500B; NachOS file &#x90FD;&#x53EF;&#x4EE5;&#x5171;&#x4EAB;&#x3002;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Kernel *kernel; <span class="comment">/* global variable */</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    kernel = <span class="keyword">new</span> Kernel(argc, argv);</span><br><span class="line">    kernel-&gt;Initialize();</span><br><span class="line">    ... </span><br><span class="line">    kernel-&gt;ExecAll();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>&#x7576;&#x6211;&#x5011;&#x5728;&#x547D;&#x4EE4;&#x5217;&#x4E0B;&#x6307;&#x4EE4; -e halt&#xFF0C;halt &#x5373;&#x662F;&#x6211;&#x5011;&#x60F3;&#x57F7;&#x884C;&#x7684;&#x53EF;&#x57F7;&#x884C;&#x6A94;&#x3002;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* threads/kernel.cc */</span></span><br><span class="line"></span><br><span class="line">Kernel::Kernel(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argc; i++) {</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[i], <span class="string">&quot;-e&quot;</span>) == <span class="number">0</span>) {</span><br><span class="line">            execfile[++execfileNum]= argv[++i];</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; execfile[execfileNum] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        }     </span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* threads/kernel.h */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Kernel</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Thread *currentThread; <span class="comment">/* the thread holding CPU */</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	  Thread* t[<span class="number">10</span>]; <span class="comment">/* 10 threads at most */</span></span><br><span class="line">	  <span class="keyword">char</span>* execfile[<span class="number">10</span>]; <span class="comment">/* executable file name */</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* threads/kernel.cc */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kernel::Initialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    currentThread = <span class="keyword">new</span> Thread(<span class="string">&quot;main&quot;</span>, threadNum++);		</span><br><span class="line">    currentThread-&gt;setStatus(RUNNING); </span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h4 id="2-void-Kernel-ExecAll"><a href="#2-void-Kernel-ExecAll" class="headerlink" title="2. void Kernel::ExecAll()"></a>2. void Kernel::ExecAll()</h4><p><strong>threads/kernel.cc</strong>&#x200B; </p>
<p>&#x628A;&#x6240;&#x6709;&#x53EF;&#x57F7;&#x884C;&#x6A94;&#x4E1F;&#x9032; Exec() &#x57F7;&#x884C;&#x3002;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kernel::ExecAll</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= execfileNum; i++) {</span><br><span class="line">        <span class="keyword">int</span> a = Exec(execfile[i]);</span><br><span class="line">    }</span><br><span class="line">    currentThread-&gt;Finish();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h4 id="3-int-Kernel-Exec-char-name"><a href="#3-int-Kernel-Exec-char-name" class="headerlink" title="3. int Kernel::Exec(char* name)"></a>3. int Kernel::Exec(char* name)</h4><p><strong>threads/kernel.cc</strong>&#x200B; </p>
<p>&#x6BCF;&#x4E00;&#x500B;&#x53EF;&#x57F7;&#x884C;&#x6A94;&#x90FD;&#x9700;&#x8981; new &#x4E00;&#x500B;&#x65B0;&#x7684; thread &#x4F86;&#x57F7;&#x884C;&#x3002;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Kernel::Exec</span><span class="params">(<span class="keyword">char</span>* name)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    t[threadNum] = <span class="keyword">new</span> Thread(name, threadNum);</span><br><span class="line">    t[threadNum]-&gt;space = <span class="keyword">new</span> AddrSpace();    </span><br><span class="line">    t[threadNum]-&gt;Fork((VoidFunctionPtr)&amp;ForkExecute,</span><br><span class="line">                       (<span class="keyword">void</span>*)t[threadNum]);</span><br><span class="line">    threadNum++;</span><br><span class="line">    <span class="keyword">return</span> threadNum<span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h4 id="4-void-Thread-Fork-VoidFunctionPtr-func-void-arg"><a href="#4-void-Thread-Fork-VoidFunctionPtr-func-void-arg" class="headerlink" title="4. void Thread::Fork(VoidFunctionPtr func, void *arg)"></a>4. void Thread::Fork(VoidFunctionPtr func, void *arg)</h4><p><strong>threads/thread.cc</strong></p>
<p>&#x5EFA;&#x7ACB; thread &#x57F7;&#x884C;&#x6240;&#x9700;&#x8981;&#x7684; stack&#xFF0C;&#x4E26;&#x628A; thread &#x4E1F;&#x9032; readyList &#x7B49;&#x5F85;&#x57F7;&#x884C;&#x3002;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Thread::Fork</span><span class="params">(VoidFunctionPtr func, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Interrupt *interrupt = kernel-&gt;interrupt;</span><br><span class="line">    Scheduler *scheduler = kernel-&gt;scheduler;</span><br><span class="line">    IntStatus oldLevel;</span><br><span class="line">    </span><br><span class="line">    StackAllocate(func, arg);</span><br><span class="line"></span><br><span class="line">    oldLevel = interrupt-&gt;SetLevel(IntOff);</span><br><span class="line">    scheduler-&gt;ReadyToRun(<span class="keyword">this</span>);</span><br><span class="line">    (<span class="keyword">void</span>) interrupt-&gt;SetLevel(oldLevel);</span><br><span class="line">}   </span><br></pre></td></tr></table></figure>

<h4 id="5-void-Scheduler-ReadyToRun-Thread-thread"><a href="#5-void-Scheduler-ReadyToRun-Thread-thread" class="headerlink" title="5. void Scheduler::ReadyToRun (Thread *thread)"></a>5. void Scheduler::ReadyToRun (Thread *thread)</h4><p><strong>threads/scheduler.cc</strong></p>
<p>&#x5C07; thread &#x52A0;&#x5165; readyList&#xFF0C;&#x7576; scheduler &#x9700;&#x8981;&#x5B89;&#x6392; thread &#x4F86;&#x57F7;&#x884C;&#x7684;&#x6642;&#x5019;&#xFF0C;&#x5C31;&#x5F9E; readyList dequeue &#x4E00;&#x500B; thread &#x4F86;&#x57F7;&#x884C;&#x3002;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Scheduler::ReadyToRun</span> <span class="params">(Thread *thread)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ASSERT(kernel-&gt;interrupt-&gt;getLevel() == IntOff);</span><br><span class="line">    thread-&gt;setStatus(READY);</span><br><span class="line">    readyList-&gt;Append(thread);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scheduler</span> {</span></span><br><span class="line">    <span class="function">Thread* <span class="title">FindNextToRun</span><span class="params">()</span></span>;</span><br><span class="line">    List&lt;Thread *&gt; *readyList;	</span><br><span class="line">};</span><br></pre></td></tr></table></figure>

<h3 id="b-&#x201C;threads-thread-cc-thread-Sleep"><a href="#b-&#x201C;threads-thread-cc-thread-Sleep" class="headerlink" title="(b) &#x201C;threads/thread.cc thread::Sleep"></a>(b) &#x201C;threads/thread.cc thread::Sleep</h3><p>Starting from &#x201C;threads/thread.cc thread::Sleep&#x200B;&#x201D; is called.</p>
<h4 id="1-void-Thread-Sleep-bool-finishing"><a href="#1-void-Thread-Sleep-bool-finishing" class="headerlink" title="1. void Thread::Sleep (bool finishing)"></a>1. void Thread::Sleep (bool finishing)</h4><p><strong>threads/thread.cc</strong></p>
<p>&#x53EA;&#x6709; currentThread &#x53EF;&#x4EE5;&#x547C;&#x53EB; Sleep()&#xFF0C;currentThread &#x662F;&#x76EE;&#x524D;&#x6B63;&#x5728;&#x57F7;&#x884C;&#x7684; thread&#xFF0C;&#x7576;currentThread &#x5B8C;&#x6210;&#x4ED6;&#x7684;&#x5DE5;&#x4F5C;&#x6216;&#x662F;&#x5728;&#x7B49;&#x5F85; synchronization variable (Semaphore, Lock, or Condition)&#xFF0C;&#x6703;&#x9032;&#x5165; Sleep()&#x3002; &#x7576; currentThread &#x9032;&#x5165; Sleep()&#xFF0C;&#x5C31;&#x80FD;&#x5F9E; readyList &#x4E2D; dequeue &#x4E00;&#x500B; thread &#x6210;&#x70BA; currentThread&#xFF0C;&#x4F7F;&#x7528; CPU&#x3002;&#x6211;&#x5011;&#x5C07;&#x9032;&#x5165; Sleep() &#x7684; thread &#x7684; state &#x5B58;&#x8D77;&#x4F86;&#xFF0C;&#x4E26;&#x4E14;&#x9032;&#x884C; context switch &#x3002;&#x7576;&#x518D;&#x6B21;&#x8F2A;&#x5230;&#x5728; Sleep() &#x7684; thread &#x4F7F;&#x7528; CPU &#x6642;&#xFF0C;Run() &#x624D;&#x6703; return&#x3002;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Thread::Sleep</span> <span class="params">(<span class="keyword">bool</span> finishing)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Thread *nextThread;</span><br><span class="line">    ASSERT(<span class="keyword">this</span> == kernel-&gt;currentThread);</span><br><span class="line">    ASSERT(kernel-&gt;interrupt-&gt;getLevel() == IntOff);</span><br><span class="line">    status = BLOCKED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((nextThread = kernel-&gt;scheduler-&gt;FindNextToRun()) == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="comment">/* no one to run, wait for an interrupt */</span></span><br><span class="line">        kernel-&gt;interrupt-&gt;Idle();</span><br><span class="line">    }    </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* returns when it&apos;s time for us to run */</span></span><br><span class="line">    kernel-&gt;scheduler-&gt;Run(nextThread, finishing); </span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h4 id="2-void-Scheduler-Run-Thread-nextThread-bool-finishing"><a href="#2-void-Scheduler-Run-Thread-nextThread-bool-finishing" class="headerlink" title="2. void Scheduler::Run (Thread *nextThread, bool finishing)"></a>2. void Scheduler::Run (Thread *nextThread, bool finishing)</h4><p><strong>threads/scheduler.cc</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Scheduler::Run</span> <span class="params">(Thread *nextThread, <span class="keyword">bool</span> finishing)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Thread *oldThread = kernel-&gt;currentThread;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (finishing) {	</span><br><span class="line">        <span class="comment">/* mark that we need to delete current thread */</span></span><br><span class="line">        ASSERT(toBeDestroyed == <span class="literal">NULL</span>);</span><br><span class="line">	  toBeDestroyed = oldThread;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (oldThread-&gt;space &#xFF01;= <span class="literal">NULL</span>) {	</span><br><span class="line">        <span class="comment">/* save the user&apos;s state */</span></span><br><span class="line">        oldThread-&gt;SaveUserState();</span><br><span class="line">        oldThread-&gt;space-&gt;SaveState();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    oldThread-&gt;CheckOverflow();</span><br><span class="line">    <span class="comment">/* switch to the next thread */</span></span><br><span class="line">    kernel-&gt;currentThread = nextThread;      </span><br><span class="line">    <span class="comment">/* nextThread is now running */</span></span><br><span class="line">    nextThread-&gt;setStatus(RUNNING);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This is a machine-dependent assembly language routine defined </span></span><br><span class="line"><span class="comment">     * in switch.s */</span></span><br><span class="line">    SWITCH(oldThread, nextThread);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* we&apos;re back, running oldThread */</span></span><br><span class="line">    <span class="comment">/* check if thread we were running before this one has finished</span></span><br><span class="line"><span class="comment">     * and needs to be cleaned up */</span></span><br><span class="line">    CheckToBeDestroyed();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (oldThread-&gt;space != <span class="literal">NULL</span>) {	</span><br><span class="line">        <span class="comment">/* if there is an address space to restore, do it */</span></span><br><span class="line">        oldThread-&gt;RestoreUserState();</span><br><span class="line">	  oldThread-&gt;space-&gt;RestoreState();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>&#x547C;&#x53EB; SWITCH() &#x9032;&#x884C; context switch&#xFF0C;&#x5728; SWITCH() &#x5B8C;&#x6210;&#x4E4B;&#x5F8C;&#xFF0C;&#x4E26;&#x4E0D;&#x6703;&#x7E7C;&#x7E8C;&#x57F7;&#x884C; Run() &#x7684;&#x4E0B;&#x4E00;&#x884C;&#xFF0C;&#x56E0;&#x70BA;&#x63A7;&#x5236;&#x6B0A;&#x5DF2;&#x7D93;&#x50B3;&#x7D66; nextThread&#xFF0C;&#x4E0B;&#x4E00;&#x884C;&#x8981;&#x88AB;&#x57F7;&#x884C;&#x7684;&#x6307;&#x4EE4;&#x662F; nextThread &#x7684;&#x6307;&#x4EE4;&#xFF0C;&#x7576; CheckToBeDestroyed() &#x88AB;&#x57F7;&#x884C;&#xFF0C;&#x4EE3;&#x8868;&#x5DF2;&#x7D93;&#x53C8;&#x8F2A;&#x5230;&#x9019;&#x500B; thread &#x4F7F;&#x7528; CPU&#xFF0C;&#x9019;&#x4E2D;&#x9593;&#x53EF;&#x80FD;&#x5DF2;&#x7D93;&#x5728;&#x597D;&#x5E7E;&#x500B; thread &#x4E4B;&#x9593; context  switch &#x597D;&#x5E7E;&#x6B21;&#x4E86;&#x3002;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SWITCH(oldThread, nextThread);</span><br></pre></td></tr></table></figure>

<h3 id="c-machine-mipssim-cc-Machine-Run-&#x200B;"><a href="#c-machine-mipssim-cc-Machine-Run-&#x200B;" class="headerlink" title="(c) machine/mipssim.cc Machine::Run()&#x200B;"></a>(c) machine/mipssim.cc Machine::Run()&#x200B;</h3><p>Starting from &#x201C;machine/mipssim.cc Machine::Run()&#x200B;&#x201D; is called.</p>
<h4 id="1-void-Machine-Run"><a href="#1-void-Machine-Run" class="headerlink" title="1. void Machine::Run()"></a>1. void Machine::Run()</h4><p><strong>machine/mippsim.cc</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Machine::Run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/* storage for decoded instruction */</span></span><br><span class="line">    Instruction *instr = <span class="keyword">new</span> Instruction; /</span><br><span class="line"></span><br><span class="line">    kernel-&gt;interrupt-&gt;setStatus(UserMode);</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        OneInstruction(instr);</span><br><span class="line">        kernel-&gt;interrupt-&gt;OneTick();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h4 id="2-void-Machine-OneInstruction-Instruction-instr"><a href="#2-void-Machine-OneInstruction-Instruction-instr" class="headerlink" title="2. void Machine::OneInstruction(Instruction *instr)"></a>2. void Machine::OneInstruction(Instruction *instr)</h4><p><strong>machine/mippsim.cc</strong></p>
<p>OneInstruction() &#x8B80;&#x53D6;&#x7576;&#x524D;&#x6307;&#x4EE4;&#xFF0C;&#x7D93;&#x904E; decode()&#xFF0C;&#x6211;&#x5011;&#x53EF;&#x4EE5;&#x5F97;&#x5230; rs / rt / rd / opCode&#xFF0C;&#x4F9D;&#x7167; opCode &#x6211;&#x5011;&#x5C0D; register[rs] &#x548C; register[rt] &#x9032;&#x884C;&#x5C0D;&#x61C9;&#x7684;&#x64CD;&#x4F5C;&#xFF0C;&#x4E26;&#x4E14;&#x5C07;&#x7D50;&#x679C;&#x5BEB;&#x5165; register[rd]&#x3002;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Machine::OneInstruction</span><span class="params">(Instruction *instr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> raw;</span><br><span class="line">    <span class="comment">/* Fetch instruction */</span> </span><br><span class="line">    <span class="keyword">if</span> (!ReadMem(registers[PCReg], <span class="number">4</span>, &amp;raw))</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">/* exception occurred */</span></span><br><span class="line"></span><br><span class="line">    instr-&gt;value = raw;</span><br><span class="line">    instr-&gt;Decode();</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">int</span> pcAfter = registers[NextPCReg] + <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rs, rt, imm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Execute the instruction */</span></span><br><span class="line">    <span class="keyword">switch</span> (instr-&gt;opCode) {</span><br><span class="line">        <span class="keyword">case</span> OP_ADD:</span><br><span class="line">        sum = registers[instr-&gt;rs] + registers[instr-&gt;rt];</span><br><span class="line">	  registers[instr-&gt;rd] = sum;</span><br><span class="line">	  <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* Advance program counters */</span></span><br><span class="line">    registers[PrevPCReg] = registers[PCReg];</span><br><span class="line">    registers[PCReg] = registers[NextPCReg];</span><br><span class="line">    registers[NextPCReg] = pcAfter;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>&#x4E00;&#x500B; Instruction &#x662F; 4 &#x500B; byte&#xFF0C;&#x6070;&#x597D;&#x662F;&#x4E00;&#x500B; unsigned int &#x7684;&#x5927;&#x5C0F;&#xFF0C;&#x56E0;&#x6B64;&#x6211;&#x5011;&#x7528;&#x4E00;&#x500B; unsigned int &#x4F86;&#x5132;&#x5B58;&#x4ED6;&#x3002;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Instruction</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Decode</span><span class="params">()</span></span>;	</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">char</span> opCode; <span class="comment">/* Type of instruction */</span></span><br><span class="line">    <span class="keyword">char</span> rs, rt, rd; <span class="comment">/* Three registers from instruction */</span></span><br><span class="line">    <span class="keyword">int</span> extra; <span class="comment">/* Immediate or target or shamt field or offset */</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure>

<h4 id="3-void-Instruction-Decode"><a href="#3-void-Instruction-Decode" class="headerlink" title="3. void Instruction::Decode()"></a>3. void Instruction::Decode()</h4><p><strong>machine/mippsim.cc</strong></p>
<p>&#x5C07;&#x6211;&#x5011;&#x5B58;&#x5728; unsigned int value &#x88E1;&#x7684; instruction decode&#xFF0C;&#x6211;&#x5011;&#x53EF;&#x4EE5;&#x5F97;&#x5230;&#x9019;&#x4E00;&#x5230;&#x6307;&#x4EE4;&#x7684; rs / rt / rd / opCode&#x3002;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Instruction::Decode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    OpInfo *opPtr;</span><br><span class="line">    </span><br><span class="line">    rs = (value &gt;&gt; <span class="number">21</span>) &amp; <span class="number">0x1f</span>;</span><br><span class="line">    rt = (value &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x1f</span>;</span><br><span class="line">    rd = (value &gt;&gt; <span class="number">11</span>) &amp; <span class="number">0x1f</span>;</span><br><span class="line">    opPtr = &amp;opTable[(value &gt;&gt; <span class="number">26</span>) &amp; <span class="number">0x3f</span>];</span><br><span class="line">    opCode = opPtr-&gt;opCode;</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><h3 id="a-modify-pageTable-building"><a href="#a-modify-pageTable-building" class="headerlink" title="(a) modify pageTable building"></a>(a) modify pageTable building</h3><p>&#x5728;&#x4FEE;&#x6539;&#x4E4B;&#x524D;&#xFF0C;&#x5728; addrSpace &#x7269;&#x4EF6;&#x5EFA;&#x7ACB;&#x6642;&#x5C31;&#x6703;&#x5EFA;&#x7ACB; pageTable&#xFF0C;&#x9810;&#x8A2D; NachOS &#x53EA;&#x6703;&#x904B;&#x884C;&#x4E00;&#x500B;&#x53EF;&#x57F7;&#x884C;&#x6A94;&#xFF0C;&#x56E0;&#x6B64;&#x9019;&#x500B; pageTable &#x6DB5;&#x84CB;&#x6574;&#x500B; physical memory&#xFF0C;&#x56E0;&#x6B64;&#x4E0D;&#x9700;&#x8981;&#x505A;&#x4EFB;&#x4F55; virtualPage &#x548C; physicalPage &#x4E4B;&#x9593;&#x7684;&#x6620;&#x5C04;&#x3002; </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">AddrSpace::AddrSpace()</span><br><span class="line">{</span><br><span class="line">    pageTable = <span class="keyword">new</span> TranslationEntry[NumPhysPages];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NumPhysPages; i++) {</span><br><span class="line">        pageTable[i].virtualPage = i;	</span><br><span class="line">        pageTable[i].physicalPage = i;</span><br><span class="line">        pageTable[i].valid = TRUE;</span><br><span class="line">        pageTable[i].use = FALSE;</span><br><span class="line">        pageTable[i].dirty = FALSE;</span><br><span class="line">        pageTable[i].readOnly = FALSE;  </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* zero out the entire address space */</span></span><br><span class="line">    bzero(kernel-&gt;machine-&gt;mainMemory, MemorySize);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>&#x4F46;&#x662F;&#x7576;&#x6211;&#x5011;&#x60F3;&#x8981;&#x540C;&#x6642;&#x57F7;&#x884C;&#x4E00;&#x500B;&#x4EE5;&#x4E0A;&#x7684;&#x53EF;&#x57F7;&#x884C;&#x6A94;&#x6642;&#xFF0C;&#x6703;&#x767C;&#x751F;&#x554F;&#x984C;&#xFF0C;&#x56E0;&#x70BA;&#x55AE;&#x4E00;&#x500B; thread &#x4E0D;&#x80FD;&#x64C1;&#x6709;&#x6574;&#x500B; physical memory &#x7684;&#x6240;&#x6709;&#x6B0A;&#xFF0C;&#x6BCF;&#x500B; thread &#x90FD;&#x53EA;&#x80FD;&#x64C1;&#x6709;&#x90E8;&#x4EFD;&#x7684; physical memory&#xFF0C;&#x56E0;&#x6B64;&#x6211;&#x4FEE;&#x6539; pageTable &#x7684;&#x5EFA;&#x7ACB;&#xFF0C;&#x6BCF;&#x500B; thread &#x7684; pageTable &#x7684;&#x5C3A;&#x5BF8;&#x53EA;&#x5305;&#x542B;&#x4ED6;&#x6240;&#x9700;&#x8981;&#x7684;&#x90E8;&#x4EFD;&#x3002;&#x4F46;&#x662F;&#x5728;&#x6211;&#x5011;&#x5C07;&#x53EF;&#x57F7;&#x884C;&#x6A94; load &#x9032; memory &#x4E4B;&#x524D;&#xFF0C;&#x6211;&#x5011;&#x4E26;&#x4E0D;&#x77E5;&#x9053;&#x9019;&#x500B;&#x53EF;&#x57F7;&#x884C;&#x6A94;&#x9700;&#x8981;&#x591A;&#x5C11;&#x7A7A;&#x9593;&#xFF0C; &#x56E0;&#x6B64;&#x6211;&#x5C07; pageTable &#x7684;&#x5EFA;&#x7ACB;&#x5EF6;&#x5F8C;&#xFF0C;&#x76F4;&#x5230;&#x53EF;&#x57F7;&#x884C;&#x6A94;&#x7684; header &#x8B80;&#x5165;&#xFF0C;&#x6211;&#x5011;&#x77E5;&#x9053;&#x9019;&#x500B;&#x53EF;&#x57F7;&#x884C;&#x6A94;&#x7684;&#x5927;&#x5C0F;&#x4E4B;&#x5F8C;&#xFF0C;&#x624D;&#x5EFA;&#x7ACB; pageTable&#x3002;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AddrSpace::Load</span><span class="params">(<span class="keyword">char</span> *fileName)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ...</span><br><span class="line">    numPages = divRoundUp(size, PageSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* setup pageTable after we know how much space the program needs */</span></span><br><span class="line">    pageTable = <span class="keyword">new</span> TranslationEntry[numPages];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numPages; i++) {</span><br><span class="line">        pageTable[i].virtualPage = i;	</span><br><span class="line">        pageTable[i].physicalPage = kernel-&gt;usedPhyPage-&gt;checkAndSet();</span><br><span class="line">        pageTable[i].valid = <span class="literal">true</span>;</span><br><span class="line">        pageTable[i].use = <span class="literal">false</span>;</span><br><span class="line">        pageTable[i].dirty = <span class="literal">false</span>;</span><br><span class="line">        pageTable[i].readOnly = <span class="literal">false</span>; </span><br><span class="line"></span><br><span class="line">        <span class="comment">/* zero out this physical page */</span></span><br><span class="line">        bzero(kernel-&gt;machine-&gt;mainMemory + pageTable[i].physicalPage * </span><br><span class="line">              PageSize, PageSize);</span><br><span class="line">    }</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>&#x65B0;&#x589E; class UsedPhyPage &#x4F86;&#x7BA1;&#x7406; physical memory&#xFF0C;&#x4F7F;&#x7528;&#x4E00;&#x500B; array &#x7D00;&#x9304; physical page &#x662F;&#x5426;&#x5DF2;&#x7D93;&#x88AB;&#x4F7F;&#x7528;&#x3002;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UsedPhyPage</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> *pages; <span class="comment">/* 0 for unused, 1 for used */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">checkAndSet</span><span class="params">()</span></span>;</span><br><span class="line">...</span><br><span class="line">};</span><br></pre></td></tr></table></figure>

<p>checkAndSet() &#x56DE;&#x50B3;&#x4E00;&#x500B;&#x672A;&#x4F7F;&#x7528;&#x7684; physical page &#x7684; pageNum&#xFF0C;&#x5982;&#x679C;&#x6574;&#x500B; physical memory &#x90FD;&#x5DF2;&#x7D93;&#x88AB;&#x4F7F;&#x7528;&#xFF0C;&#x56DE;&#x50B3; -1&#x3002;&#x4F7F;&#x7528;&#x9019;&#x500B;&#x65B9;&#x6CD5;&#x5EFA;&#x7ACB; pageTable&#xFF0C;&#x6BCF;&#x500B; thread &#x7BA1;&#x7406;&#x81EA;&#x5DF1;&#x7684; pageTable&#xFF0C;&#x4F7F;&#x7528;&#x5C6C;&#x65BC;&#x81EA;&#x5DF1;&#x7684; memory space &#x3002;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pageTable[i].physicalPage = kernel-&gt;usedPhyPage-&gt;checkAndSet();</span><br></pre></td></tr></table></figure>

<h3 id="b-modify-executable-file-loading"><a href="#b-modify-executable-file-loading" class="headerlink" title="(b) modify executable file loading"></a>(b) modify executable file loading</h3><p>&#x7576;&#x6211;&#x5011;&#x8981;&#x57F7;&#x884C;&#x4E00;&#x500B;&#x53EF;&#x57F7;&#x884C;&#x6A94;&#xFF0C;&#x9996;&#x5148;&#x8981;&#x628A;&#x8A72;&#x6A94;&#x6848; load &#x9032; memory&#xFF0C;&#x4E00;&#x500B; NachOS &#x53EF;&#x57F7;&#x884C;&#x6A94;&#x5206;&#x6210;&#x56DB;&#x500B;&#x90E8;&#x4EFD;&#xFF0C;header / code / initData / readonlyData&#xFF0C;&#x6211;&#x5011;&#x9996;&#x5148;&#x8B80;&#x51FA; header &#x4F86;&#x7372;&#x53D6;&#x6A94;&#x6848;&#x7684; metadata&#xFF0C;&#x6839;&#x64DA;&#x6B64; metadata &#x6211;&#x5011;&#x53EF;&#x4EE5;&#x77E5;&#x9053; code / initData / readonlyData &#x5728;&#x6A94;&#x6848;&#x4E2D;&#x7684;&#x8D77;&#x59CB;&#x4F4D;&#x7F6E;&#x548C;&#x5927;&#x5C0F;&#x3002;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">noffHeader</span> {</span></span><br><span class="line">   <span class="keyword">int</span> noffMagic;	<span class="comment">/* should be NOFFMAGIC */</span></span><br><span class="line">   Segment code; <span class="comment">/* executable code segment */</span> </span><br><span class="line">   Segment initData; <span class="comment">/* initialized data segment */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RDATA</span></span><br><span class="line">   Segment readonlyData;	<span class="comment">/* read only data */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">   Segment uninitData; <span class="comment">/* uninitialized data segment, should be zero&apos;ed </span></span><br><span class="line"><span class="comment">                        * before use */</span></span><br><span class="line">} NoffHeader;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">segment</span> {</span></span><br><span class="line">    <span class="keyword">int</span> virtualAddr; <span class="comment">/* location of segment in virt addr space */</span></span><br><span class="line">    <span class="keyword">int</span> inFileAddr; <span class="comment">/* location of segment in this file */</span></span><br><span class="line">    <span class="keyword">int</span> size; <span class="comment">/* size of segment */</span></span><br><span class="line">} Segment;</span><br></pre></td></tr></table></figure>

<p>&#x6211;&#x5011;&#x7684;&#x76EE;&#x6A19;&#x662F;&#x628A;&#x6BCF;&#x4E00;&#x6BB5; segment &#x5F9E;&#x4ED6;&#x5728;&#x6A94;&#x6848;&#x88E1;&#x7684;&#x4F4D;&#x7F6E;&#xFF0C;load &#x5230;&#x4ED6;&#x7684; virtualAddr &#x6240;&#x5C0D;&#x61C9;&#x7684; physicalAddr&#x3002;&#x672A;&#x4FEE;&#x6539;&#x524D;&#x56E0;&#x70BA;&#x6574;&#x500B; memory &#x53EA;&#x6709;&#x4E00;&#x500B; thread  &#x5728;&#x4F7F;&#x7528;&#xFF0C;&#x6240;&#x4EE5; physicalAddr &#x548C; virtualAddr &#x76F8;&#x540C;&#xFF0C;&#x4E26;&#x4E14;&#x56E0;&#x70BA;&#x9019;&#x500B;&#x53EF;&#x57F7;&#x884C;&#x6A94;&#x662F;&#x7B2C;&#x4E00;&#x500B;&#x4E5F;&#x662F;&#x552F;&#x4E00;&#x4E00;&#x500B; load &#x9032; memory &#x7684;&#x6A94;&#x6848;&#xFF0C;&#x56E0;&#x6B64;&#x6574;&#x500B;&#x7A7A;&#x9593;&#x662F;&#x9023;&#x7E8C;&#x4E14;&#x7121;&#x4EBA;&#x4F7F;&#x7528;&#x7684;&#xFF0C;&#x628A;&#x53EF;&#x57F7;&#x884C;&#x6A94;&#x642C;&#x79FB;&#x5230; memory&#xFF0C;&#x6BCF;&#x4E00;&#x500B; segment &#x53EA;&#x8981;&#x642C;&#x79FB;&#x4E00;&#x6B21;&#x5373;&#x53EF;&#x3002;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AddrSpace::Load</span><span class="params">(<span class="keyword">char</span> *fileName)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/* read header file */</span></span><br><span class="line">    OpenFile *executable = kernel-&gt;fileSystem-&gt;Open(fileName);</span><br><span class="line">    NoffHeader noffH;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size;</span><br><span class="line">    executable-&gt;ReadAt((<span class="keyword">char</span> *)&amp;noffH, <span class="keyword">sizeof</span>(noffH), <span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RDATA</span></span><br><span class="line">    size = noffH.code.size + noffH.readonlyData.size +  </span><br><span class="line">           noffH.initData.size + noffH.uninitData.size + UserStackSize;	</span><br><span class="line">    ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    numPages = divRoundUp(size, PageSize);</span><br><span class="line">    size = numPages * PageSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (noffH.code.size &gt; <span class="number">0</span>) {</span><br><span class="line">        executable-&gt;ReadAt(</span><br><span class="line">                  &amp;(kernel-&gt;machine-&gt;mainMemory[noffH.code.virtualAddr]),</span><br><span class="line">                  noffH.code.size, noffH.code.inFileAddr);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (noffH.initData.size &gt; <span class="number">0</span>) {</span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RDATA</span></span><br><span class="line">    <span class="keyword">if</span> (noffH.readonlyData.size &gt; <span class="number">0</span>) {</span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>&#x5728;&#x4FEE;&#x6539;&#x4E4B;&#x5F8C;&#xFF0C;memory &#x7531;&#x591A;&#x500B; thread &#x5171;&#x7528;&#xFF0C;&#x56E0;&#x6B64;&#x5728;&#x5C07;&#x8CC7;&#x6599;&#x5F9E;&#x6A94;&#x6848; load &#x9032; memory &#x4E4B;&#x524D;&#xFF0C;&#x9700;&#x8981;&#x5148;&#x4F7F;&#x7528; Translate() &#x5C07; virtualAddr &#x8F49;&#x63DB;&#x6210;&#x5C0D;&#x61C9;&#x7684; physicalAddr&#x3002;&#x56E0;&#x70BA;&#x6709;&#x591A;&#x500B; thread &#x5171;&#x7528; memory&#xFF0C;memory &#x4E2D;&#x53EF;&#x80FD;&#x5DF2;&#x7D93;&#x6709;&#x4E9B; page &#x88AB;&#x5225;&#x7684; thread &#x4F54;&#x7528;&#x4E86;&#xFF0C;&#x56E0;&#x6B64;&#x8CC7;&#x6599;&#x9700;&#x8981;&#x4E00;&#x500B; page &#x4E00;&#x500B; page &#x7684; load &#x9032; memory &#xFF0C;&#x800C;&#x4E0D;&#x80FD;&#x6574;&#x6BB5; segment (&#x5305;&#x542B;&#x6578;&#x500B; page ) load &#x9032; memory &#x3002; &#x4EE5;&#x4E0B;&#x5716;&#x70BA;&#x4F8B;&#xFF0C;&#x9019;&#x500B;&#x6A94;&#x6848;&#x6709; 4 &#x500B; page&#xFF0C;&#x6BCF;&#x4E00;&#x500B; page &#x6709; 5 &#x500B; bytes&#xFF0C;virtal page &#x548C; physical page &#x7684;&#x5C0D;&#x61C9;&#x5982;&#x4E0B;&#xFF0C;&#x53EF;&#x4EE5;&#x770B;&#x5230; virtual page &#x662F;&#x9023;&#x7E8C;&#x7684; (0 , 1 , 2 , 3)&#xFF0C;&#x4F46; physical page &#x4E0D;&#x662F;&#x9023;&#x7E8C;&#x7684; (6 , 9 , 7 , 11)&#xFF0C;&#x56E0;&#x6B64;&#x6211;&#x5011;&#x5728;&#x642C;&#x79FB;&#x8CC7;&#x6599;&#x6642;&#xFF0C;&#x4E00;&#x6B21;&#x53EA;&#x80FD;&#x642C;&#x4E00;&#x500B; virtual page &#x7684;&#x8CC7;&#x6599;&#x3002;</p>
<p><img src="/2021/07/18/NachOS-MP2/image1.svg"></p>
<p>&#x5047;&#x8A2D;&#x6211;&#x5011;&#x6240;&#x8981;&#x642C;&#x79FB;&#x7684;&#x8CC7;&#x6599;&#x5F9E; virtual addr 8 - 17&#xFF0C;&#x53EF;&#x4EE5;&#x770B;&#x5230;&#x4ED6;&#x5305;&#x542B;&#x4E86; 3 &#x500B; page&#xFF0C;&#x56E0;&#x6B64;&#x6211;&#x5011;&#x9700;&#x8981;&#x5206;&#x6210; 3 &#x6B21;&#x8F49;&#x79FB;&#x8CC7;&#x6599;&#xFF0C;&#x8CC7;&#x6599;&#x5F9E; inFile addr &#x642C;&#x79FB;&#x5230;&#x6211;&#x5011;&#x6307;&#x5B9A;&#x7684; virtual addr &#x5C0D;&#x61C9;&#x5230;&#x7684; physical addr&#xFF0C;virtual addr &#x53EF;&#x4EE5;&#x81EA;&#x8A02;&#xFF0C;&#x5728; NachOS &#x88E1; virtual addr &#x548C; inFile addr &#x662F;&#x76F8;&#x540C;&#x7684;&#x3002; </p>
<p><img src="/2021/07/18/NachOS-MP2/image2.svg"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AddrSpace::Load</span><span class="params">(<span class="keyword">char</span> *fileName)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> virtualAddr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> physicalAddr;</span><br><span class="line">    <span class="keyword">int</span> unReadSize;</span><br><span class="line">    <span class="keyword">int</span> chunkStart;</span><br><span class="line">    <span class="keyword">int</span> chunkSize;</span><br><span class="line">    <span class="keyword">int</span> inFilePosiotion;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (noffH.code.size &gt; <span class="number">0</span>) {</span><br><span class="line">        unReadSize = noffH.code.size;</span><br><span class="line">        chunkStart = noffH.code.virtualAddr;</span><br><span class="line">        chunkSize = <span class="number">0</span>;</span><br><span class="line">        inFilePosiotion = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* while still unread code */</span></span><br><span class="line">        <span class="keyword">while</span>(unReadSize &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">/* first chunk and last chunk might not be full */</span></span><br><span class="line">            chunkSize =  calChunkSize(chunkStart, unReadSize); </span><br><span class="line">            <span class="comment">/* mapping from virtual addr to physical addr */</span></span><br><span class="line">            Translate(chunkStart, &amp;physicalAddr, <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            executable-&gt;ReadAt(                     </span><br><span class="line">                  &amp;(kernel-&gt;machine-&gt;mainMemorymainMemory[physicalAddr]), </span><br><span class="line">                  chunkSize, noffH.code.inFileAddr + inFilePosiotion);</span><br><span class="line"></span><br><span class="line">            unReadSize = unReadSize - chunkSize;</span><br><span class="line">            chunkStart = chunkStart + chunkSize;</span><br><span class="line">            inFilePosiotion = inFilePosiotion + chunkSize;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (noffH.initData.size &gt; <span class="number">0</span>) {</span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RDATA</span></span><br><span class="line">    <span class="keyword">if</span> (noffH.readonlyData.size &gt; <span class="number">0</span>) {</span><br><span class="line">        ...        </span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h2 id="Questions"><a href="#Questions" class="headerlink" title="Questions"></a>Questions</h2><h3 id="a-allocate-memory-space-amp-initiate-memory-content"><a href="#a-allocate-memory-space-amp-initiate-memory-content" class="headerlink" title="(a) allocate memory space &amp; initiate memory content"></a>(a) allocate memory space &amp; initiate memory content</h3><ul>
<li><strong>How Nachos allocates the memory space for new thread(process)?</strong></li>
<li><strong>How Nachos initializes the memory content of a thread(process), including loading the user binary code in the memory?</strong></li>
<li><strong>How Nachos initializes the machine status (registers, etc) before running a thread(process)?</strong></li>
</ul>
<p>&#x6BCF;&#x4E00;&#x500B;&#x53EF;&#x57F7;&#x884C;&#x6A94;&#x90FD;&#x9700;&#x8981; new &#x4E00;&#x500B;&#x65B0;&#x7684; thread &#x4F86;&#x57F7;&#x884C;&#x3002;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* threads/kernel.cc&#x200B; */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Kernel::Exec</span><span class="params">(<span class="keyword">char</span>* name)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    t[threadNum] = <span class="keyword">new</span> Thread(name, threadNum);</span><br><span class="line">    t[threadNum]-&gt;space = <span class="keyword">new</span> AddrSpace();    </span><br><span class="line">    t[threadNum]-&gt;Fork((VoidFunctionPtr)&amp;ForkExecute,</span><br><span class="line">                       (<span class="keyword">void</span>*)t[threadNum]);</span><br><span class="line">    threadNum++;</span><br><span class="line">    <span class="keyword">return</span> threadNum<span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>&#x9019;&#x500B; thread &#x6240;&#x8981;&#x57F7;&#x884C;&#x7684; function &#x548C;&#x4ED6;&#x6240;&#x9700;&#x8981;&#x7684; argument &#x4E1F;&#x9032; StackAllocate&#xFF0C;&#x6B64;&#x6642;&#x6211;&#x5011;&#x8981;&#x57F7;&#x884C;&#x7684; function &#x662F; ForkExecute&#x3002;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* threads/thread.cc */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Thread::Fork</span><span class="params">(VoidFunctionPtr func, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Interrupt *interrupt = kernel-&gt;interrupt;</span><br><span class="line">    Scheduler *scheduler = kernel-&gt;scheduler;</span><br><span class="line">    IntStatus oldLevel;</span><br><span class="line">    </span><br><span class="line">    StackAllocate(func, arg);</span><br><span class="line"></span><br><span class="line">    oldLevel = interrupt-&gt;SetLevel(IntOff);</span><br><span class="line">    scheduler-&gt;ReadyToRun(<span class="keyword">this</span>);</span><br><span class="line">    (<span class="keyword">void</span>) interrupt-&gt;SetLevel(oldLevel);</span><br><span class="line">}   </span><br></pre></td></tr></table></figure>

<p>&#x5EFA;&#x7ACB;&#x548C;&#x521D;&#x59CB;&#x5316;&#x9019;&#x500B; thread &#x7684; execution stack&#x3002;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* threads/thread.cc */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Thread::StackAllocate</span> <span class="params">(VoidFunctionPtr func, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">stack</span> = (<span class="keyword">int</span> *) AllocBoundedArray(StackSize * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    ...</span><br><span class="line">    machineState[PCState] = (<span class="keyword">void</span>*)ThreadRoot;</span><br><span class="line">    machineState[StartupPCState] = (<span class="keyword">void</span>*)ThreadBegin;</span><br><span class="line">    machineState[InitialPCState] = (<span class="keyword">void</span>*)func;</span><br><span class="line">    machineState[InitialArgState] = (<span class="keyword">void</span>*)arg;</span><br><span class="line">    machineState[WhenDonePCState] = (<span class="keyword">void</span>*)ThreadFinish;</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>func &#x662F;&#x4E4B;&#x5F8C;&#x8981;&#x57F7;&#x884C;&#x7684;&#x51FD;&#x5F0F;&#x3002;<br>machineState[InitialPCState] = (void*)func;</p>
<p>ForkExecute &#x662F;&#x6211;&#x5011;&#x60F3;&#x57F7;&#x884C;&#x7684; func&#xFF0C;&#x5C07;&#x6211;&#x5011;&#x6307;&#x5B9A;&#x7684;&#x53EF;&#x57F7;&#x884C;&#x6A94; load &#x9032; memory&#xFF0C;&#x7136;&#x5F8C;&#x57F7;&#x884C;&#x4ED6;&#x3002;&#x6B64;&#x6642;&#x5206;&#x914D;&#x7A7A;&#x9593;&#x4E26;&#x4E14;&#x5EFA;&#x7ACB; pageTable&#x3002;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* threads/kernel.cc */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ForkExecute</span><span class="params">(Thread *t)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/* allocate pageTable for this process */</span></span><br><span class="line">    <span class="keyword">if</span> ( !t-&gt;space-&gt;Load(t-&gt;getName()) ) {</span><br><span class="line">    	<span class="keyword">return</span>; <span class="comment">/* executable not found */</span></span><br><span class="line">    }</span><br><span class="line">    t-&gt;space-&gt;Execute(t-&gt;getName());</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>&#x5C07;&#x53EF;&#x57F7;&#x884C;&#x6A94;&#x8B80;&#x5165; memory&#x3002;&#x9996;&#x5148;&#x8B80;&#x5165;&#x53EF;&#x57F7;&#x884C;&#x6A94;&#x7684; header&#xFF0C;&#x8B80;&#x53D6; header &#x4E4B;&#x5F8C;&#x5C31;&#x80FD;&#x77E5;&#x9053;&#x6A94;&#x6848;&#x5927;&#x5C0F;&#xFF0C;&#x5EFA;&#x7ACB; pageTable&#x3002;&#x5EFA;&#x7ACB; pageTable &#x6642;&#x6703;&#x628A;&#x8A72; thread &#x5206;&#x914D;&#x5230;&#x7684; physical page &#x6E05;&#x7A7A;&#x3002;&#x6709;&#x4E86; pageTable &#x4E4B;&#x5F8C;&#x5C31;&#x80FD;&#x628A;&#x53EF;&#x57F7;&#x884C;&#x6A94;&#x7684;&#x5176;&#x4ED6;&#x90E8;&#x4EFD; load &#x9032; memory &#x4E86;&#x3002;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t-&gt;space-&gt;Load(t-&gt;getName())</span><br></pre></td></tr></table></figure>

<h3 id="b-page-table-amp-address-translation"><a href="#b-page-table-amp-address-translation" class="headerlink" title="(b) page table &amp; address translation"></a>(b) page table &amp; address translation</h3><ul>
<li><strong>How Nachos creates and manages the page table?</strong></li>
<li><strong>How Nachos translates address?</strong></li>
</ul>
<p>class UsedPhyPage &#x53EF;&#x4EE5;&#x5E6B;&#x52A9;&#x5EFA;&#x7ACB;&#x548C;&#x7BA1;&#x7406; physical memory&#xFF0C;&#x5728;&#x5B8C;&#x6210; pageTable &#x4E4B;&#x5F8C;&#x4F7F;&#x7528; Translate &#x5373;&#x53EF;&#x5C07; virtual addr &#x8F49;&#x63DB;&#x70BA; physical addr&#x3002;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* machine/translate.cc */</span></span><br><span class="line"></span><br><span class="line"><span class="function">ExceptionType</span></span><br><span class="line"><span class="function"><span class="title">Machine::Translate</span><span class="params">(<span class="keyword">int</span> virtAddr, <span class="keyword">int</span>* physAddr, <span class="keyword">int</span> size, <span class="keyword">bool</span> writing)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> vpn, offset;</span><br><span class="line">    TranslationEntry *entry;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> pageFrame;</span><br><span class="line"></span><br><span class="line">    vpn = (<span class="keyword">unsigned</span>) virtAddr / PageSize; <span class="comment">/* virtual page number */</span></span><br><span class="line">    offset = (<span class="keyword">unsigned</span>) virtAddr % PageSize; <span class="comment">/* offset within the page */</span></span><br><span class="line">    ...</span><br><span class="line">    entry = &amp;pageTable[vpn]; <span class="comment">/* translate using pageTable */</span></span><br><span class="line">    ...</span><br><span class="line">    pageFrame = entry-&gt;physicalPage;</span><br><span class="line">    ...</span><br><span class="line">    *physAddr = pageFrame * PageSize + offset;</span><br><span class="line">    <span class="keyword">return</span> NoException;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TranslationEntry</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> virtualPage;</span><br><span class="line">    <span class="keyword">int</span> physicalPage;</span><br><span class="line">    ...</span><br><span class="line">};</span><br></pre></td></tr></table></figure>

<h3 id="c-process-control-block"><a href="#c-process-control-block" class="headerlink" title="(c) process control block"></a>(c) process control block</h3><ul>
<li><strong>Which object&#x200B; in Nachos acts the role of &#x200B; process control block?</strong></li>
</ul>
<p>PCB (process control block) &#x5305;&#x542B;&#x548C; process / thread &#x76F8;&#x95DC;&#x7684;&#x4E00;&#x4E9B;&#x8CC7;&#x8A0A;&#xFF0C;&#x4F8B;&#x5982; :</p>
<ul>
<li>process state</li>
<li>program counter</li>
<li>CPU register</li>
<li>CPU scheduling info (e.g. priority)</li>
<li>memory management info (e.g. base / limit register)</li>
<li>and more</li>
</ul>
<p>class Thread &#x6709;&#x5F88;&#x591A; PCB &#x61C9;&#x8A72;&#x5305;&#x542B;&#x7684;&#x8CC7;&#x8A0A;&#xFF0C;&#x4F8B;&#x5982; :</p>
<ul>
<li>process state &#x2013;&gt; status</li>
<li>memory management &#x2013;&gt; space</li>
<li>CPU register &#x2013;&gt; machineState</li>
<li>and more</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span> {</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> *stackTop;	 <span class="comment">/* the current stack pointer */</span></span><br><span class="line">    <span class="keyword">void</span> *machineState[MachineStateSize]; <span class="comment">/* all registers except for </span></span><br><span class="line"><span class="comment">                                           * stackTop */</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> *<span class="built_in">stack</span>; <span class="comment">/* bottom of the stack */</span> </span><br><span class="line">    ThreadStatus status;	 <span class="comment">/* ready, running or blocked */</span></span><br><span class="line">    <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span> ID;</span><br><span class="line">    <span class="keyword">int</span> userRegisters[NumTotalRegs]; <span class="comment">/* user-level CPU register state */</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    AddrSpace *space; <span class="comment">/* user code this thread is running */</span></span><br><span class="line">    ...</span><br><span class="line">};</span><br></pre></td></tr></table></figure>

<h3 id="d-ReadyToRun-queue"><a href="#d-ReadyToRun-queue" class="headerlink" title="(d) ReadyToRun queue"></a>(d) ReadyToRun queue</h3><ul>
<li><strong>When and how does a thread get added into the ReadyToRun queue of Nachos CPU scheduler?</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* threads/thread.cc */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Thread::Fork</span><span class="params">(VoidFunctionPtr func, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Interrupt *interrupt = kernel-&gt;interrupt;</span><br><span class="line">    Scheduler *scheduler = kernel-&gt;scheduler;</span><br><span class="line">    IntStatus oldLevel;</span><br><span class="line">    </span><br><span class="line">    StackAllocate(func, arg);</span><br><span class="line"></span><br><span class="line">    oldLevel = interrupt-&gt;SetLevel(IntOff);</span><br><span class="line">    scheduler-&gt;ReadyToRun(<span class="keyword">this</span>);</span><br><span class="line">    (<span class="keyword">void</span>) interrupt-&gt;SetLevel(oldLevel);</span><br><span class="line">}   </span><br></pre></td></tr></table></figure>

<p>&#x7576;&#x4E00;&#x500B; thread &#x5DF2;&#x7D93;&#x5EFA;&#x7ACB;&#x597D;&#x4ED6;&#x7684; stack&#xFF0C;&#x5C07;&#x4ED6;&#x52A0;&#x5165; readyList&#xFF0C;&#x7576; scheduler &#x9700;&#x8981;&#x5B89;&#x6392; thread &#x4F86;&#x57F7;&#x884C;&#x7684;&#x6642;&#x5019;&#xFF0C;&#x5C31;&#x5F9E; readyList dequeue &#x4E00;&#x500B; thread &#x4F86;&#x57F7;&#x884C;&#x3002;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheduler-&gt;ReadyToRun(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>

<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>[1] shawn2000100/10810CS_342301_OperatingSystem<br><a target="_blank" rel="noopener" href="https://github.com/shawn2000100/10810CS_342301_OperatingSystem">https://github.com/shawn2000100/10810CS_342301_OperatingSystem</a><br>[2] OS::NachOS::HW1<br><a target="_blank" rel="noopener" href="http://blog.terrynini.tw/tw/OS-NachOS-HW1/">http://blog.terrynini.tw/tw/OS-NachOS-HW1/</a><br>[3] Nachos Project 3<br><a target="_blank" rel="noopener" href="https://www.csie.ntu.edu.tw/~b96201044/Project3_Slide_2010.pdf">https://www.csie.ntu.edu.tw/~b96201044/Project3_Slide_2010.pdf</a></p>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a class="post-title-link" href="2021/07/14/NachOS-MP1/">NachOS MP1</a></h2><div class="post-info">Jul 14, 2021</div><div class="post-content"><h2 id="Trace-code"><a href="#Trace-code" class="headerlink" title="Trace code"></a>Trace code</h2><h3 id="a-SC-Halt"><a href="#a-SC-Halt" class="headerlink" title="(a) SC_Halt"></a>(a) SC_Halt</h3><p>Trace the SC_Halt system call to understand the implementation of a system call. (Sample code : halt.c)</p>
<h4 id="void-Halt"><a href="#void-Halt" class="headerlink" title="void Halt();"></a>void Halt();</h4><p><strong>userprog/syscall.h</strong></p>
<p>trace code 的目標是 syscall.h 的 Halt()。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SC_Halt 0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Halt</span><span class="params">()</span></span>;	</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* test/start.s */</span><br><span class="line"></span><br><span class="line">	.globl Halt</span><br><span class="line">	.ent	Halt</span><br><span class="line">Halt:</span><br><span class="line">	addiu $2,$0,SC_Halt</span><br><span class="line">	syscall</span><br><span class="line">	j	$31</span><br><span class="line">	.end Halt</span><br></pre></td></tr></table></figure>

<p>執行指令 addiu，SC_Halt 是定義在 “syscall.h” 的常數，MIPS 架構的 register(0) 永遠是 0 ，將兩者相加後存到 register(2) 中，即將 SC_Halt 的值 assign 給 register(2)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addiu $2,$0,SC_Halt</span><br></pre></td></tr></table></figure>

<p>執行指令 syscall，進入Exception handler。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">syscall</span><br></pre></td></tr></table></figure>

<p>在 machine.h 定義常數 RetAddrReg 的值是 31。跳到 register(31) 所儲存的位置，表示回到 frame 的上一層。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">j	$31</span><br></pre></td></tr></table></figure>

<h4 id="1-void-Machine-Run"><a href="#1-void-Machine-Run" class="headerlink" title="1. void Machine::Run()"></a>1. void Machine::Run()</h4><p><strong>machine/mipssim.cc</strong> </p>
<p>程式開始執行，kernel 呼叫 Machine::Run()，Machine::Run() 在無窮迴圈呼叫OneInstruction()，不停的執行指令。”mipssim.h” 定義了 MIPS 架構支援的 63 個operation，OneInstruction() 負責處理這 63 個 operation 組成的指令。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Machine::Run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;) </span><br><span class="line">    &#123;</span><br><span class="line">        OneInstruction(instr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-void-Machine-OneInstruction-Instruction-instr"><a href="#2-void-Machine-OneInstruction-Instruction-instr" class="headerlink" title="2. void Machine::OneInstruction(Instruction *instr)"></a>2. void Machine::OneInstruction(Instruction *instr)</h4><p><strong>machine/mipssim.cc</strong></p>
<p>machine.h 定義常數PCReg 值 34，register(34) 放有當前指令的位址。不同指令進入不同的 switch case，當指令是 addiu，不會發生 interrupt，但當指令是 syscall，interupt 發生，呼叫 RaiseException()。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Void <span class="title">Machine::OneInstruction</span><span class="params">(Instruction *instr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> raw;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* fetch instruction */</span></span><br><span class="line">    <span class="keyword">if</span> (!ReadMem(registers[PCReg], <span class="number">4</span>, &amp;raw)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;	</span><br><span class="line">    &#125;	</span><br><span class="line">	</span><br><span class="line">    instr-&gt;value = raw;</span><br><span class="line">    instr-&gt;Decode();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (instr-&gt;opCode) &#123;</span><br><span class="line">    <span class="keyword">case</span> OP_SYSCALL:</span><br><span class="line">        RaiseException(SyscallException, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NachOS 定義了 9 種 exception 類型，在 case OP_SYSCALL 發生的是SyscallException 類型的 exception。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* machine/machine.h */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ExceptionType</span> &#123;</span> </span><br><span class="line">    NoException,           </span><br><span class="line">    SyscallException,      </span><br><span class="line">    PageFaultException,   </span><br><span class="line">    ReadOnlyException,     </span><br><span class="line">    BusErrorException,     </span><br><span class="line">    AddressErrorException, </span><br><span class="line">    OverflowException,     </span><br><span class="line">    IllegalInstrException, </span><br><span class="line">    NumExceptionTypes</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-Void-Machine-RaiseException-ExceptionType-which-int-badVAddr"><a href="#3-Void-Machine-RaiseException-ExceptionType-which-int-badVAddr" class="headerlink" title="3. Void Machine::RaiseException(ExceptionType which, int badVAddr)"></a>3. Void Machine::RaiseException(ExceptionType which, int badVAddr)</h4><p><strong>machine/machine.cc</strong></p>
<p>把程式從 user mode 改成 kernel mode，呼叫 ExceptionHandler。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Void <span class="title">Machine::RaiseException</span><span class="params">(ExceptionType which, <span class="keyword">int</span> badVAddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    kernel-&gt;interrupt-&gt;setStatus(SystemMode);</span><br><span class="line">    ExceptionHandler(which);		</span><br><span class="line">    kernel-&gt;interrupt-&gt;setStatus(UserMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-void-ExceptionHandler-ExceptionType-which"><a href="#4-void-ExceptionHandler-ExceptionType-which" class="headerlink" title="4. void ExceptionHandler(ExceptionType which)"></a>4. void ExceptionHandler(ExceptionType which)</h4><p><strong>userprog/exception .cc</strong></p>
<p>ExceptionHandler() 讀取 register(2) 的值，先前已經把 SC_Halt 的值 assign 給register(2)，因此進入 SC_Halt 的 switch case，呼叫 SysHalt()。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExceptionHandler</span><span class="params">(ExceptionType which)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> type = kernel-&gt;machine-&gt;ReadRegister(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">switch</span>(type) &#123;</span><br><span class="line">    <span class="keyword">case</span> SC_Halt:</span><br><span class="line">        SysHalt(); </span><br><span class="line">        <span class="keyword">break</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-void-SysHalt"><a href="#5-void-SysHalt" class="headerlink" title="5. void SysHalt()"></a>5. void SysHalt()</h4><p><strong>userprog/ksyscall.h</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SysHalt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    kernel-&gt;interrupt-&gt;Halt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="6-Void-Interrupt-Halt"><a href="#6-Void-Interrupt-Halt" class="headerlink" title="6. Void Interrupt::Halt()"></a>6. Void Interrupt::Halt()</h4><p><strong>machine/interrupt.cc</strong></p>
<p>將物件 kernel 所佔用的記憶體釋放，即關機。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Void <span class="title">Interrupt::Halt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Machine halting!\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;This is halt\n&quot;</span>;</span><br><span class="line">    kernel-&gt;stats-&gt;Print();</span><br><span class="line">    <span class="keyword">delete</span> kernel; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="b-SC-Create"><a href="#b-SC-Create" class="headerlink" title="(b) SC_Create"></a>(b) SC_Create</h3><p>Trace the SC_Create system call to understand the basic operations and data structure in a file system. (Sample code : createFile.c)</p>
<h4 id="void-Create"><a href="#void-Create" class="headerlink" title="void Create();"></a>void Create();</h4><p><strong>userprog/syscall.h</strong></p>
<p>trace code 的目標是 syscall.h 的 Create()。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SC_Create	4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Create</span><span class="params">(<span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* test/start.s */</span><br><span class="line"></span><br><span class="line">#include &quot;syscall.h&quot;</span><br><span class="line"></span><br><span class="line">	.globl Create</span><br><span class="line">	.ent	Create</span><br><span class="line">Create:</span><br><span class="line">	addiu $2,$0,SC_Create</span><br><span class="line">	syscall</span><br><span class="line">	j	$31</span><br><span class="line">	.end Create</span><br></pre></td></tr></table></figure>

<h4 id="1-OneInstruction-Instruction-instr"><a href="#1-OneInstruction-Instruction-instr" class="headerlink" title="1. OneInstruction(Instruction *instr)"></a>1. OneInstruction(Instruction *instr)</h4><p><strong>machine/mipssim</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;machine.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mipssim.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">Void <span class="title">Machine::OneInstruction</span><span class="params">(Instruction *instr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (instr-&gt;opCode) &#123;</span><br><span class="line">    	<span class="keyword">case</span> OP_SYSCALL:</span><br><span class="line">    	   RaiseException(SyscallException, <span class="number">0</span>);</span><br><span class="line">    	   <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-RaiseException-ExceptionType-which-int-badVAddr"><a href="#2-RaiseException-ExceptionType-which-int-badVAddr" class="headerlink" title="2. RaiseException(ExceptionType which, int badVAddr)"></a>2. RaiseException(ExceptionType which, int badVAddr)</h4><p><strong>machine/machine.cc</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;machine.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">Void <span class="title">Machine::RaiseException</span><span class="params">(ExceptionType which, <span class="keyword">int</span> badVAddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    kernel-&gt;interrupt-&gt;setStatus(SystemMode);</span><br><span class="line">    ExceptionHandler(which);		</span><br><span class="line">    kernel-&gt;interrupt-&gt;setStatus(UserMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-ExceptionHandler-ExceptionType-which"><a href="#3-ExceptionHandler-ExceptionType-which" class="headerlink" title="3. ExceptionHandler(ExceptionType which)"></a>3. ExceptionHandler(ExceptionType which)</h4><p><strong>userprog/exception.cc</strong></p>
<p>從 register(4) 讀出呼叫 Create 時傳入的參數，即 filename 的位置。Syscreate 回傳是否有成功的 create file，成功回傳 1，失敗回傳 0。完成 SysCreate 後必須修改 PCReg 讓 PCReg 指向下一個指令，如果沒有加上這一行，程式會不停的執行同一道指令。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;syscall.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ksyscall.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExceptionHandler</span><span class="params">(ExceptionType which)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> type = kernel-&gt;machine-&gt;ReadRegister(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">switch</span>(type) </span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">case</span> SC_Create:</span><br><span class="line">          val = kernel-&gt;machine-&gt;ReadRegister(<span class="number">4</span>);</span><br><span class="line">          <span class="keyword">char</span> *filename = &amp;(kernel-&gt;machine-&gt;mainMemory[val]);</span><br><span class="line">          status = SysCreate(filename);</span><br><span class="line">          <span class="keyword">if</span>(status != <span class="number">-1</span>) status = <span class="number">1</span>;</span><br><span class="line">          kernel-&gt;machine-&gt;WriteRegister(<span class="number">2</span>, (<span class="keyword">int</span>) status);</span><br><span class="line"></span><br><span class="line">	    kernel-&gt;machine-&gt;WriteRegister(PrevPCReg, </span><br><span class="line">                              kernel-&gt;machine-&gt;ReadRegister(PCReg));</span><br><span class="line">	    kernel-&gt;machine-&gt;WriteRegister(PCReg, </span><br><span class="line">                              kernel-&gt;machine-&gt;ReadRegister(PCReg) + <span class="number">4</span>);</span><br><span class="line">	    kernel-&gt;machine-&gt;WriteRegister(NextPCReg, </span><br><span class="line">                              kernel-&gt;machine-&gt;ReadRegister(PCReg)+<span class="number">4</span>);</span><br><span class="line">	    <span class="keyword">return</span>;</span><br><span class="line">	    ASSERTNOTREACHED();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-int-SysCreate-char-filename"><a href="#4-int-SysCreate-char-filename" class="headerlink" title="4. int SysCreate(char *filename)"></a>4. int SysCreate(char *filename)</h4><p><strong>userprog/ksyscall.h</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Interrupt::CreateFile</span><span class="params">(<span class="keyword">char</span> *filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> kernel-&gt;CreateFile(filename);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-int-Interrupt-CreateFile-char-filename"><a href="#5-int-Interrupt-CreateFile-char-filename" class="headerlink" title="5. int Interrupt::CreateFile(char *filename)"></a>5. int Interrupt::CreateFile(char *filename)</h4><p><strong>machine/interrupt.cc</strong></p>
<p>class FileSystem 是 NachOS 的 file system API。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Kernel::CreateFile</span><span class="params">(<span class="keyword">char</span> *filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fileSystem-&gt;Create(filename);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 filesys.cc 的開頭有一段 #ifdef #else，有沒有 #define FILESYS_STUB 使用的是不同的檔案系統，如果有 #define FILESYS_STUB，並不是使用真正的 NachOS 檔案系統，只是借用了 linux 的檔案系統，如果沒有 #define FILESYS_STUB，才是使用 NachOS 的檔案系統。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> FILESYS_STUB</span></span><br></pre></td></tr></table></figure>

<p>Makefile 裡有下 DFILESYS_STUB 的 flag，代表目前 NachOS 只是借用了 linux 的檔案系統。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEFINES =  -DFILESYS_STUB -DRDATA -DSIM_FIX</span><br></pre></td></tr></table></figure>

<h4 id="6-bool-Filesystem-OpenForWrite-char-name"><a href="#6-bool-Filesystem-OpenForWrite-char-name" class="headerlink" title="6. bool Filesystem::OpenForWrite(char *name)"></a>6. bool Filesystem::OpenForWrite(char *name)</h4><p><strong>filesys/filesys.cc</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> FILESYS_STUB 		</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Create</span><span class="params">(<span class="keyword">char</span> *name)</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> fileDescriptor = OpenForWrite(name);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (fileDescriptor == <span class="number">-1</span>) <span class="keyword">return</span> FALSE;</span><br><span class="line">		Close(fileDescriptor); </span><br><span class="line">		<span class="keyword">return</span> TRUE; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-int-OpenForWrite-char-name"><a href="#7-int-OpenForWrite-char-name" class="headerlink" title="7. int OpenForWrite(char *name)"></a>7. int OpenForWrite(char *name)</h4><p><strong>lib/sysdep.c</strong></p>
<p>目前的檔案系統是借用 linux 的檔案系統，Create 的實做是呼叫了 linux 提供的 open()，open() 失敗回傳 -1，成功回傳非負整數。NachOS 目前沒有真正的檔案系統，如果我們要使用真正的 NachOS 檔案系統，就要在 File System 的 API 之下，自己寫一個檔案系統。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/file.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">OpenForWrite</span><span class="params">(<span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(name, O_RDWR|O_CREAT|O_TRUNC, <span class="number">0666</span>);</span><br><span class="line">    ASSERT(fd &gt;= <span class="number">0</span>); </span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="c-PrintInt"><a href="#c-PrintInt" class="headerlink" title="(c) PrintInt"></a>(c) PrintInt</h3><p>Trace the SC_PrintInt system call to understand how NachOS implements asynchronized I/O using CallBack functions and register schedule events. (Sample code : add.c)</p>
<h4 id="void-PrintInt-int-number"><a href="#void-PrintInt-int-number" class="headerlink" title="void PrintInt(int number);"></a>void PrintInt(int number);</h4><p><strong>userprog/syscall.h</strong></p>
<p>trace code 的目標是 syscall.h 的 PrintInt()。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SC_PrintInt 16</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintInt</span><span class="params">(<span class="keyword">int</span> number)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* test/start.s */</span><br><span class="line"></span><br><span class="line">#include &quot;syscall.h&quot;</span><br><span class="line"></span><br><span class="line">	.globl PrintInt</span><br><span class="line">	.ent	PrintInt</span><br><span class="line">PrintInt:</span><br><span class="line">	addiu $2,$0,SC_PrintInt</span><br><span class="line">	syscall</span><br><span class="line">	j	$31</span><br><span class="line">	.end PrintInt</span><br></pre></td></tr></table></figure>

<h4 id="1-OneInstruction-Instruction-instr-1"><a href="#1-OneInstruction-Instruction-instr-1" class="headerlink" title="1. OneInstruction(Instruction *instr)"></a>1. OneInstruction(Instruction *instr)</h4><p><strong>machine/mipssim</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Void <span class="title">Machine::OneInstruction</span><span class="params">(Instruction *instr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> raw;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ReadMem(registers[PCReg], <span class="number">4</span>, &amp;raw))</span><br><span class="line">	<span class="keyword">return</span>;			</span><br><span class="line">	</span><br><span class="line">    instr-&gt;value = raw;</span><br><span class="line">    instr-&gt;Decode();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (instr-&gt;opCode) &#123;</span><br><span class="line">    <span class="keyword">case</span> OP_SYSCALL:</span><br><span class="line">        RaiseException(SyscallException, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-RaiseException-ExceptionType-which-int-badVAddr-1"><a href="#2-RaiseException-ExceptionType-which-int-badVAddr-1" class="headerlink" title="2. RaiseException(ExceptionType which, int badVAddr)"></a>2. RaiseException(ExceptionType which, int badVAddr)</h4><p><strong>machine/machine.cc</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Void <span class="title">Machine::RaiseException</span><span class="params">(ExceptionType which, <span class="keyword">int</span> badVAddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    kernel-&gt;interrupt-&gt;setStatus(SystemMode);</span><br><span class="line">    ExceptionHandler(which);		</span><br><span class="line">    kernel-&gt;interrupt-&gt;setStatus(UserMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-ExceptionHandler-ExceptionType-which-1"><a href="#3-ExceptionHandler-ExceptionType-which-1" class="headerlink" title="3. ExceptionHandler(ExceptionType which)"></a>3. ExceptionHandler(ExceptionType which)</h4><p><strong>userprog/exception .cc</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;syscall.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ksyscall.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExceptionHandler</span><span class="params">(ExceptionType which)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> type = kernel-&gt;machine-&gt;ReadRegister(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">switch</span>(type) </span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">case</span> SC_PrintInt:</span><br><span class="line">          val = kernel-&gt;machine-&gt;ReadRegister(<span class="number">4</span>);</span><br><span class="line">          SysPrintInt(val); </span><br><span class="line">	    kernel-&gt;machine-&gt;WriteRegister(PrevPCReg, </span><br><span class="line">                              kernel-&gt;machine-&gt;ReadRegister(PCReg));</span><br><span class="line">	    kernel-&gt;machine-&gt;WriteRegister(PCReg, </span><br><span class="line">                              kernel-&gt;machine-&gt;ReadRegister(PCReg) + <span class="number">4</span>);</span><br><span class="line">	    kernel-&gt;machine-&gt;WriteRegister(NextPCReg, </span><br><span class="line">                              kernel-&gt;machine-&gt;ReadRegister(PCReg)+<span class="number">4</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-SysPrintInt"><a href="#4-SysPrintInt" class="headerlink" title="4. SysPrintInt()"></a>4. SysPrintInt()</h4><p><strong>userprog/ksyscall.h</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SysPrintInt</span><span class="params">(<span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    kernel-&gt;synchConsoleOut-&gt;PutInt(number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-void-SynchConsoleOutput-PutInt-int-number"><a href="#5-void-SynchConsoleOutput-PutInt-int-number" class="headerlink" title="5. void SynchConsoleOutput::PutInt(int number)"></a>5. void SynchConsoleOutput::PutInt(int number)</h4><p><strong>userprog/synchconsole.cc</strong></p>
<p>只有一個 console，因此必須要 sync，輸出的過程是 critical section，一次只能有一個 thread 做 console output。使用 while 迴圈，將字串中的字元一個一個的印出。在此使用 do while 迴圈，因為第一個輸出的字元不需要等待，他既然可以成功 acquire 到 lock 代表目前沒有人在進行輸出，但接下來的字元輸出都要等前一個字元輸出完成才能進行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SynchConsoleOutput::PutInt</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">15</span>];</span><br><span class="line">    <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(str, <span class="string">&quot;%d\n\0&quot;</span>, value); <span class="comment">/* convert int into string */</span></span><br><span class="line">    lock-&gt;Acquire();  <span class="comment">/* enter critical section */</span></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        consoleOutput-&gt;PutChar(str[idx]);</span><br><span class="line">        idx++;</span><br><span class="line">	  waitFor-&gt;P();</span><br><span class="line">    &#125; <span class="keyword">while</span>(str[idx] != <span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line">    lock-&gt;Release(); <span class="comment">/* leave critical section */</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SynchConsoleOutput</span> :</span> <span class="keyword">public</span> CallBackObj &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ConsoleOutput *consoleOutput; <span class="comment">/* the hardware display */</span></span><br><span class="line">    Lock *lock; <span class="comment">/* only one writer at a time */</span></span><br><span class="line">    Semaphore *waitFor; <span class="comment">/* wait for callBack */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CallBack</span><span class="params">()</span></span>; <span class="comment">/* called when more data can be written */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>waitFor 是 class Semaphore 的物件，當呼叫 P() 時，若 waitFor.value &lt; 0 ，thread 會被加入 waitFor.queue 中等待。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">waitFor-&gt;P();</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* threads/synch.h */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">P</span><span class="params">()</span></span>; <span class="comment">/* waits until value &gt; 0, then decrement */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">V</span><span class="params">()</span></span>; <span class="comment">/* increment, waking up a thread waiting in P() if </span></span><br><span class="line"><span class="comment">               * necessary */</span></span><br><span class="line"><span class="keyword">private</span>:      </span><br><span class="line">    <span class="keyword">int</span> value;             </span><br><span class="line">    List&lt;Thread *&gt; *<span class="built_in">queue</span>; <span class="comment">/* threads waiting in P() for the value to be </span></span><br><span class="line"><span class="comment">                            * &gt; 0 */</span>      </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在 value &gt; 0 之前都會卡在迴圈裡，在前一個字元做輸出時，thread 會進入 Sleep() 中，scheduler 會安排正在readyList 的 thread 使用 CPU。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* threads/synch.cc */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Semaphore::P</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">while</span> (value == <span class="number">0</span>) &#123; 	</span><br><span class="line">        <span class="built_in">queue</span>-&gt;Append(currentThread);	</span><br><span class="line">        currentThread-&gt;Sleep(FALSE);</span><br><span class="line">    &#125; </span><br><span class="line">    value--; 	       		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-ConsoleOutput-PutChar"><a href="#6-ConsoleOutput-PutChar" class="headerlink" title="6. ConsoleOutput::PutChar()"></a>6. ConsoleOutput::PutChar()</h4><p><strong>machine/console.cc</strong></p>
<p>呼叫 WriteFile() 對螢幕進行輸出，呼叫 Schedule() 模擬螢幕完成輸出後發出 interrupt。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConsoleOutput::PutChar</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WriteFile(writeFileNo, &amp;ch, <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    kernel-&gt;interrupt-&gt;Schedule(<span class="keyword">this</span>, ConsoleTime, ConsoleWriteInt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WriteFile() 的實做是呼叫 linux 提供的 write()，fd 是被寫入檔案的 file descriptor，writeFileNo 的值在 console.cc 中被 assign 為 1。 在 linux 系統中，file descriptor 為 1 即是 stdout，字元會被輸出到螢幕。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* lib/sysdep.cc */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WriteFile</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *buffer, <span class="keyword">int</span> nBytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retVal = write(fd, buffer, nBytes);</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一個真正的作業系統會在輸出完成的時候發出 interrupt，由於這不是真的作業系統，所以他只能預估輸出時間然後自己發出 interrupt 。NachOS 預估字元輸出需要 100 單位時間，因此安排在 100 個單位時間後發出 interrupt 。關鍵字 this 通常被用在一個 class 內部，this 是一個指標，指向正在被執行的 class 的物件，this 在此處是 ConsoleOutput。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel-&gt;interrupt-&gt;Schedule(<span class="keyword">this</span>, ConsoleTime, ConsoleWriteInt);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* machine/stats.h */</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ConsoleTime =	<span class="number">100</span>; <span class="comment">/* time to read or write one character */</span></span><br></pre></td></tr></table></figure>

<p>IntType 紀錄這個 interrupt 是由哪個硬體發出，NachOS支援六種硬體相關 interrupt 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* machine/interrupt.h */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IntType</span> &#123;</span> TimerInt, DiskInt, ConsoleWriteInt, ConsoleReadInt, </span><br><span class="line">               NetworkSendInt, NetworkRecvInt&#125;;</span><br></pre></td></tr></table></figure>

<p>writeFileNo 的值在 console.cc 中被 assign 為 1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* machine/console.cc */</span></span><br><span class="line"></span><br><span class="line">ConsoleOutput::ConsoleOutput(<span class="keyword">char</span> *writeFile, CallBackObj *toCall)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (writeFile == <span class="literal">NULL</span>)</span><br><span class="line">        writeFileNo = <span class="number">1</span>;			</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        writeFileNo = OpenForWrite(writeFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* threads/kernel.cc */</span></span><br><span class="line"></span><br><span class="line">synchConsoleOut = <span class="keyword">new</span> SynchConsoleOutput(consoleOut);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* threads/kernel.cc */</span></span><br><span class="line"></span><br><span class="line">consoleOut = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<h4 id="7-void-Interrupt-Schedule-CallBackObj-toCall-int-fromNow-IntType-type"><a href="#7-void-Interrupt-Schedule-CallBackObj-toCall-int-fromNow-IntType-type" class="headerlink" title="7. void Interrupt::Schedule(CallBackObj *toCall, int fromNow, IntType type)"></a>7. void Interrupt::Schedule(CallBackObj *toCall, int fromNow, IntType type)</h4><p><strong>machine/interrupt.cc</strong></p>
<p>把待發生的 interrupt 放進 pending，當排定的時間到達時才會發生。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Interrupt::Schedule</span><span class="params">(CallBackObj *toCall, <span class="keyword">int</span> fromNow, IntType type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> when = kernel-&gt;stats-&gt;totalTicks + fromNow;</span><br><span class="line">    PendingInterrupt *toOccur = <span class="keyword">new</span> PendingInterrupt(toCall, when, type);</span><br><span class="line">    pending-&gt;Insert(toOccur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interrupt</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    SortedList&lt;PendingInterrupt *&gt; *pending;		</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>當排定的時間到達，interrupt 發生，回報發出 interrupt 的物件，即 ConsoleOutput，讓他進行 interrupt 的處理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PendingInterrupt *toOccur = <span class="keyword">new</span> PendingInterrupt(toCall, when, type);</span><br></pre></td></tr></table></figure>

<p>when 是 interrupt 排定要發生的時間，totalTicks 是當前時間，fromNow 的值為 ConsoleTime，即 100。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> when = kernel-&gt;stats-&gt;totalTicks + fromNow;</span><br></pre></td></tr></table></figure>

<h4 id="8-void-Machine-Run"><a href="#8-void-Machine-Run" class="headerlink" title="8. void Machine::Run()"></a>8. void Machine::Run()</h4><p><strong>machine/mipssim.cc</strong></p>
<p>Onetick() 將系統時間推進一個單位，並且檢查是否有 interrupt 正要發生。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Machine::Run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Instruction *instr = <span class="keyword">new</span> Instruction;</span><br><span class="line">    kernel-&gt;interrupt-&gt;setStatus(UserMode);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        OneInstruction(instr);</span><br><span class="line">        kernel-&gt;interrupt-&gt;OneTick();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-Interrupt-OneTick"><a href="#9-Interrupt-OneTick" class="headerlink" title="9. Interrupt::OneTick()"></a>9. Interrupt::OneTick()</h4><p><strong>machine/interrupt.cc</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Interrupt::OneTick</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (status == SystemMode) &#123;</span><br><span class="line">        stats-&gt;totalTicks += SystemTick;</span><br><span class="line">        stats-&gt;systemTicks += SystemTick;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        stats-&gt;totalTicks += UserTick;</span><br><span class="line">        stats-&gt;userTicks += UserTick;</span><br><span class="line">    &#125;</span><br><span class="line">    CheckIfDue(FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="10-Interrupt-CheckIfDue"><a href="#10-Interrupt-CheckIfDue" class="headerlink" title="10. Interrupt::CheckIfDue"></a>10. Interrupt::CheckIfDue</h4><p><strong>machine/interrupt.cc</strong></p>
<p>如果沒有interrupt 要發生，回傳 false，若有 interrupt 要發生，執行並且回傳 true，若 advanceClock 為 true，表示目前已經沒有任何指令要執行，則直接執行一個 interrupt。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Interrupt::CheckIfDue</span><span class="params">(<span class="keyword">bool</span> advanceClock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PendingInterrupt *next;</span><br><span class="line">    Statistics *stats = kernel-&gt;stats;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pending-&gt;IsEmpty()) &#123;</span><br><span class="line">	<span class="keyword">return</span> FALSE;	</span><br><span class="line">    &#125;		</span><br><span class="line">    next = pending-&gt;Front();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next-&gt;when &gt; stats-&gt;totalTicks) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!advanceClock) &#123; </span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; </span><br><span class="line">	    stats-&gt;idleTicks += (next-&gt;when - stats-&gt;totalTicks);</span><br><span class="line">	    stats-&gt;totalTicks = next-&gt;when;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    inHandler = TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        next = pending-&gt;RemoveFront();    </span><br><span class="line">        next-&gt;callOnInterrupt-&gt;CallBack();</span><br><span class="line">	  <span class="keyword">delete</span> next;</span><br><span class="line">    &#125; <span class="keyword">while</span>(!pending-&gt;IsEmpty()</span><br><span class="line">            &amp;&amp; (pending-&gt;Front()-&gt;when &lt;= stats-&gt;totalTicks));</span><br><span class="line">    inHandler = FALSE;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若目前有要發生的 interrupt，把 interrupt 從 pending 中取出，呼叫發出此 interrupt<br>物件的 callBack()，在 interrupt 處理完之後，回傳 true。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    next = pending-&gt;RemoveFront();    </span><br><span class="line">    next-&gt;callOnInterrupt-&gt;CallBack();</span><br><span class="line">    <span class="keyword">delete</span> next;</span><br><span class="line">&#125; <span class="keyword">while</span>(!pending-&gt;IsEmpty()</span><br><span class="line">        &amp;&amp; (pending-&gt;Front()-&gt;when &lt;= stats-&gt;totalTicks));</span><br></pre></td></tr></table></figure>

<h4 id="11-void-ConsoleOutput-CallBack"><a href="#11-void-ConsoleOutput-CallBack" class="headerlink" title="11. void ConsoleOutput::CallBack()"></a>11. void ConsoleOutput::CallBack()</h4><p><strong>machine/console.cc</strong></p>
<p>當螢幕輸出完成，ConsoleOutput 呼叫 SynchConsoleOutput物件的 callBack()。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConsoleOutput::CallBack</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    putBusy = FALSE;</span><br><span class="line">    kernel-&gt;stats-&gt;numConsoleCharsWritten++;</span><br><span class="line">    callWhenDone-&gt;CallBack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>consoleOutput 的 callWhenDone 是 SynchConsoleOutput。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* machine/console.h */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsoleOutput</span> :</span> <span class="keyword">public</span> CallBackObj &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CallBackObj *callWhenDone;		</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* machine/console.cc */</span></span><br><span class="line"></span><br><span class="line">ConsoleOutput::ConsoleOutput(<span class="keyword">char</span> *writeFile, CallBackObj *toCall)</span><br><span class="line">&#123;</span><br><span class="line">    callWhenDone = toCall;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* userprog/synchconsole.cc */</span></span><br><span class="line"></span><br><span class="line">SynchConsoleOutput::SynchConsoleOutput(<span class="keyword">char</span> *outputFile)</span><br><span class="line">&#123;</span><br><span class="line">    consoleOutput = <span class="keyword">new</span> ConsoleOutput(outputFile, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="11-SynchConsoleOutput-CallBack"><a href="#11-SynchConsoleOutput-CallBack" class="headerlink" title="11. SynchConsoleOutput::CallBack()"></a>11. SynchConsoleOutput::CallBack()</h4><p><strong>userprog/synchconsole.cc</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SynchConsoleOutput::CallBack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    waitFor-&gt;V();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>V() 釋放一個 semaphore 資源，並且 pop 出下一個在 semaphore.queue 的 thread 放進 readyList，等到 scheduler 安排此 thread 可以使用 CPU 時，才能輸出下一個字元。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* threads/synch.cc */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Semaphore::V</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">queue</span>-&gt;IsEmpty()) &#123; </span><br><span class="line">	kernel-&gt;scheduler-&gt;ReadyToRun(<span class="built_in">queue</span>-&gt;RemoveFront());</span><br><span class="line">    &#125;</span><br><span class="line">    value++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><p><strong>Implement four I/O system calls in NachOS</strong></p>
<ul>
<li>OpenFileId Open(char *name);</li>
<li>int Write(char *buffer, int size, OpenFileId id);</li>
<li>int Read(char *buffer, int size, OpenFileId id);</li>
<li>int Close(OpenFileId id);</li>
</ul>
<p>Open / Close / Read / Write 四者非常像，因此我以 Write 為例子進行實做解說 ，唯有比較需要說明的部份會將 Open / Close / Read 一起說明。</p>
<h4 id="int-Write-char-buffer-int-size-OpenFileId-id"><a href="#int-Write-char-buffer-int-size-OpenFileId-id" class="headerlink" title="int Write(char *buffer, int size, OpenFileId id);"></a>int Write(char *buffer, int size, OpenFileId id);</h4><p><strong>userprog/syscall.h</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SC_Write 8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> *buffer, <span class="keyword">int</span> size, OpenFileId id)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* test/start.s */</span><br><span class="line"></span><br><span class="line">#include &quot;syscall.h&quot;</span><br><span class="line"></span><br><span class="line">	.globl Write</span><br><span class="line">	.ent	Write</span><br><span class="line">Write:</span><br><span class="line">	addiu $2,$0,SC_Write</span><br><span class="line">	syscall</span><br><span class="line">	j	$31</span><br><span class="line">	.end Write</span><br></pre></td></tr></table></figure>

<h4 id="1-Void-Machine-OneInstruction-Instruction-instr"><a href="#1-Void-Machine-OneInstruction-Instruction-instr" class="headerlink" title="1. Void Machine::OneInstruction(Instruction *instr)"></a>1. Void Machine::OneInstruction(Instruction *instr)</h4><p><strong>machine/mipssim</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;machine.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mipssim.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">Void <span class="title">Machine::OneInstruction</span><span class="params">(Instruction *instr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (instr-&gt;opCode) &#123;</span><br><span class="line">    <span class="keyword">case</span> OP_SYSCALL:</span><br><span class="line">        RaiseException(SyscallException, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-RaiseException-ExceptionType-which-int-badVAddr-2"><a href="#2-RaiseException-ExceptionType-which-int-badVAddr-2" class="headerlink" title="2. RaiseException(ExceptionType which, int badVAddr)"></a>2. RaiseException(ExceptionType which, int badVAddr)</h4><p><strong>machine/machine.cc</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;machine.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">Void <span class="title">Machine::RaiseException</span><span class="params">(ExceptionType which, <span class="keyword">int</span> badVAddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    kernel-&gt;interrupt-&gt;setStatus(SystemMode);</span><br><span class="line">    ExceptionHandler(which);		</span><br><span class="line">    kernel-&gt;interrupt-&gt;setStatus(UserMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-ExceptionHandler-ExceptionType-which-2"><a href="#3-ExceptionHandler-ExceptionType-which-2" class="headerlink" title="3. ExceptionHandler(ExceptionType which)"></a>3. ExceptionHandler(ExceptionType which)</h4><p><strong>userprog/exception.cc</strong></p>
<p>依照我們傳入參數的順序 (char *buffer, int size, OpenFileId id) 依序從 register $a0 $a1 $a2，即從 register(4) register(5) register(6) 讀出呼叫 system call Write 時所傳入的參數。SysWrite 會回傳寫入是否成功。依照 MIPS 慣例，函式回傳值應放在 register $v0，即 register(4)。完成 SysWrite 之後要修改 PCReg 讓 PCReg 指向下一個指令，如果沒有加上這一行的話，程式會不停的執行當前指令。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;syscall.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ksyscall.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExceptionHandler</span><span class="params">(ExceptionType which)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> type = kernel-&gt;machine-&gt;ReadRegister(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> SC_Write:</span><br><span class="line">	    val = kernel-&gt;machine-&gt;ReadRegister(<span class="number">4</span>);</span><br><span class="line">	    <span class="keyword">char</span> *buffer = &amp;(kernel-&gt;machine-&gt;mainMemory[val]);</span><br><span class="line">	    size = kernel-&gt;machine-&gt;ReadRegister(<span class="number">5</span>); </span><br><span class="line">	    id = kernel-&gt;machine-&gt;ReadRegister(<span class="number">6</span>); </span><br><span class="line">	    status = SysWrite(buffer, size, id);</span><br><span class="line">	    kernel-&gt;machine-&gt;WriteRegister(<span class="number">2</span>, (<span class="keyword">int</span>) status);</span><br><span class="line">	    kernel-&gt;machine-&gt;WriteRegister(PrevPCReg, </span><br><span class="line">                              kernel-&gt;machine-&gt;ReadRegister(PCReg));</span><br><span class="line">	    kernel-&gt;machine-&gt;WriteRegister(PCReg, </span><br><span class="line">                              kernel-&gt;machine-&gt;ReadRegister(PCReg) + <span class="number">4</span>);</span><br><span class="line">	    kernel-&gt;machine-&gt;WriteRegister(NextPCReg, </span><br><span class="line">        kernel-&gt;machine-&gt;ReadRegister(PCReg)+<span class="number">4</span>);</span><br><span class="line">	    <span class="keyword">return</span>;	</span><br><span class="line">	    ASSERTNOTREACHED();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-int-SysWrite-char-buffer-int-size-int-id"><a href="#4-int-SysWrite-char-buffer-int-size-int-id" class="headerlink" title="4. int SysWrite(char *buffer, int size, int id)"></a>4. int SysWrite(char *buffer, int size, int id)</h4><p><strong>userprog/ksyscall.h</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SysWrite</span><span class="params">(<span class="keyword">char</span> *buffer, <span class="keyword">int</span> size, <span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> kernel-&gt;WriteFile(buffer, size, id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-int-Kernel-WriteFile-char-buffer-int-size-int-id"><a href="#5-int-Kernel-WriteFile-char-buffer-int-size-int-id" class="headerlink" title="5. int Kernel::WriteFile(char *buffer, int size, int id)"></a>5. int Kernel::WriteFile(char *buffer, int size, int id)</h4><p><strong>machine/interrupt.cc</strong></p>
<p>class FileSystem 是 NachOS 的 file system API。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Kernel::WriteFile</span><span class="params">(<span class="keyword">char</span> *buffer, <span class="keyword">int</span> size, <span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> fileSystem-&gt;WriteF(buffer, size, id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-int-Filesystem-WriteField-char-name"><a href="#6-int-Filesystem-WriteField-char-name" class="headerlink" title="6. int Filesystem::WriteField(char *name)"></a>6. int Filesystem::WriteField(char *name)</h4><p><strong>filesys/filesys.cc</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> FILESYS_STUB 		</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">WriteF</span><span class="params">(<span class="keyword">char</span> *buffer, <span class="keyword">int</span> size, <span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> status = WriteFile(id, buffer, size);</span><br><span class="line">        <span class="keyword">return</span> status; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-1-int-WriteFile-int-fd-char-buffer-int-nBytes"><a href="#7-1-int-WriteFile-int-fd-char-buffer-int-nBytes" class="headerlink" title="7_1.  int WriteFile(int fd, char *buffer, int nBytes)"></a>7_1.  int WriteFile(int fd, char *buffer, int nBytes)</h4><p><strong>lib/sysdep.cc</strong></p>
<p>class FileSystem 是 NachOS 的檔案系統 API，由於目前的檔案系統是依賴 linux 的檔案系統，system call Write 的實做是呼叫 linux 提供的 write()，write() 失敗回傳 -1，成功回傳成功寫入的字元數。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WriteFile</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *buffer, <span class="keyword">int</span> nBytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retVal = write(fd, buffer, nBytes);</span><br><span class="line">    ASSERT(retVal == nBytes);</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-2-int-OpenForReadWrite-char-name-bool-crashOnError"><a href="#7-2-int-OpenForReadWrite-char-name-bool-crashOnError" class="headerlink" title="7_2. int OpenForReadWrite(char *name, bool crashOnError)"></a>7_2. int OpenForReadWrite(char *name, bool crashOnError)</h4><p><strong>lib/sysdep.cc</strong></p>
<p>system call Open 的實做是呼叫 linux 提供的 open()，open() 失敗回傳 -1，成功回傳 file description。需要注意的是，如果使用 fopen() 開啟檔案，他回傳的是 FILE*，是一個指標，而 open() 回傳的是一個整數。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">OpenForReadWrite</span><span class="params">(<span class="keyword">char</span> *name, <span class="keyword">bool</span> crashOnError)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(name, O_RDWR, <span class="number">0</span>);</span><br><span class="line">    ASSERT(!crashOnError || fd &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-3-int-Read-int-fd-char-buffer-int-nBytes"><a href="#7-3-int-Read-int-fd-char-buffer-int-nBytes" class="headerlink" title="7_3. int Read(int fd, char *buffer, int nBytes)"></a>7_3. int Read(int fd, char *buffer, int nBytes)</h4><p><strong>lib/sysdep.cc</strong></p>
<p>system call Read 的實做是呼叫 linux 提供的 read()，read() 失敗回傳 -1，成功回傳成功讀出的字元數。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *buffer, <span class="keyword">int</span> nBytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retVal = read(fd, buffer, nBytes);</span><br><span class="line">    ASSERT(retVal == nBytes);</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-4-int-Close-int-fd"><a href="#7-4-int-Close-int-fd" class="headerlink" title="7_4. int Close(int fd)"></a>7_4. int Close(int fd)</h4><p><strong>lib/sysdep.cc</strong></p>
<p>system call Close 的實做是呼叫 linux 提供的 read()，read() 失敗回傳 -1，成功回傳 0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Close</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retVal = close(fd);</span><br><span class="line">    ASSERT(retVal &gt;= <span class="number">0</span>); </span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h3><h4 id="Compile-Rebuild-NachOS"><a href="#Compile-Rebuild-NachOS" class="headerlink" title="Compile / Rebuild NachOS"></a>Compile / Rebuild NachOS</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; cd NachOS-4.0_MP1/code/build.linux</span><br><span class="line">&gt; make clean</span><br><span class="line">&gt; make depend</span><br><span class="line">&gt; make</span><br></pre></td></tr></table></figure>

<h4 id="Test-NachOS"><a href="#Test-NachOS" class="headerlink" title="Test NachOS"></a>Test NachOS</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; cd NachOS-4.0_MP1/code/test</span><br><span class="line">&gt; make clean</span><br><span class="line">&gt; make halt</span><br><span class="line">&gt; ../build.linux/nachos -e halt</span><br></pre></td></tr></table></figure>


<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>[1] shawn2000100/10810CS_342301_OperatingSystem<br><a target="_blank" rel="noopener" href="https://github.com/shawn2000100/10810CS_342301_OperatingSystem">https://github.com/shawn2000100/10810CS_342301_OperatingSystem</a></p>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a class="post-title-link" href="2021/06/25/%E5%AD%B8%E6%9C%9F%E7%B5%90%E6%9D%9F%E4%BA%86/">學期結束了</a></h2><div class="post-info">Jun 25, 2021</div><div class="post-content"><p>大概六個小時之前完成了這學期的最後一場考試，雖然明天還有一份報告和一份補交的作業，但我的心已經在放暑假了，作業什麼的就算了吧。畢竟是工作過的人，對於暑假，因為曾經失去過所以更加珍貴。學期間就有慢慢在想暑假要做什麼，程式方面的進度都會在這裡更新的。但是夏天，除了寫程式，還是得要出去玩的吧，誰知道疫情突然變得嚴重，到底暑假結束前能不能去沙灘呢，實在好想去沙灘呀。</p>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a class="post-title-link" href="2020/12/04/%E8%B7%A8%E7%B3%BB%E6%8E%A8%E7%94%84%E5%8C%97%E7%A7%91%E8%B3%87%E5%B7%A5%E6%89%80/">跨系推甄北科資工所</a></h2><div class="post-info">Dec 4, 2020</div><div class="post-content"><h2 id="推甄資工所"><a href="#推甄資工所" class="headerlink" title="推甄資工所"></a>推甄資工所</h2><p>碩二上原本是應該加快論文進度的時期，但我因一些不可抗力因素休學了一個學期，不過我從暑假就開始準備推甄。通常跨系推甄的人就算沒有輔系也會先去修一些主要課程，例如資料結構演算法等等，但我完全沒有修過任何資工系大學部課程，機械系畢業時系排只有 70％，想要推清交顯然沒有機會，因為有回台北的急迫需要，只申請了中央和台科和北科的資工所，中央和台科沒有過書審，北科正取。</p>
<h2 id="北科資工面試"><a href="#北科資工面試" class="headerlink" title="北科資工面試"></a>北科資工面試</h2><p>北科資工分成甲組和乙組，乙組名額比較少，是開給非本科學生的組別。面試分成三關，各一位教授。第一關是自我介紹，第二關是英文，一張英文的授課大綱讓你翻譯，第三關一進去教授問我，知不知道物件導向的三大特性是什麼，我想了一下說不知道，接著他就問我有沒有資工相關的工作經驗或專題，我有把我碩一的研究成果整理成一份小專題放在備審資料裡，所以我就簡單介紹我的專題內容。</p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>跨系申請不容易，如果對什麼系有興趣，就去修一些他們的必修課，推甄本來就是長期的累積。大學的時候不一定要很認真讀書，但至少要好好找興趣，覺得自己開始的有點晚。</p>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a class="post-title-link" href="2020/10/02/%E6%B8%85%E5%A4%A7%E8%B3%87%E5%B7%A5%E4%BF%AE%E8%AA%B2%E7%B4%80%E9%8C%84/">清大資工修課紀錄</a></h2><div class="post-info">Oct 2, 2020</div><div class="post-content"><h2 id="第一次修資工系的課"><a href="#第一次修資工系的課" class="headerlink" title="第一次修資工系的課"></a>第一次修資工系的課</h2><p>雖然是機械所，但想往資工走，所以也修了一些資工系的課。為了湊足畢業學分，雖然知道自己的能力也就只有資工系大一而已，還是得要修研究所的課，修得很辛苦，每天都在寫作業，但學期結束的時候有種，我好像真的會寫程式了的感覺 (但也不排除是錯覺)。</p>
<h2 id="上學期"><a href="#上學期" class="headerlink" title="上學期"></a>上學期</h2><p>平行程式 - 周致遠：老師很認真，助教也很認真，四次作業，是MPI / Pthread / OpenMP / CUDA 的實做，每次作業之前會先有一個 lab 課，學期末要做一個專題，每次作業我都要寫兩個星期以上，全班要競賽，以效能在班上的百分比做評分，大神很多，我總是在墊底，給分甜度我無法評價，因為這門課開學的時候有大約五十個人，學期末只剩大約三十五個，這是一門修了也不一定過的課，但能學到很多。</p>
<h2 id="下學期"><a href="#下學期" class="headerlink" title="下學期"></a>下學期</h2><p>雲端計算 - 李哲榮：老師很認真，簡介一些雲端運算上的技術，第一次作業是使用 QEMU 裝 Ubuntu 虛擬機，剩下兩次作業都是在分散架構上訓練機器學習網路，作業不難，期末要論文報告，期末考可以選擇實做或紙筆 (但老師有說因為這學期修的人太多電腦資源所以才開放紙筆考試)，紙筆考試簡單，給分很甜。</p>
<p>人工智慧與藝術導論 - 吳中浩：雖然是資工系的課但內容大多是在教藝術相關，我發現事情怪怪的時候已經來不急了，老師開課是希望藝術系的人也來修課，所以實做相關非常少，三份作業都是藝術相關的報告，學期末要做一個專題，給分很甜。</p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>清大資工好課不少，想修的人也很多，對於非本科學生，要搶到課也不容易，挺羨慕資工系的大學部學生可以有四年好好修課些課。</p>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a class="post-title-link" href="2019/03/23/%E5%B7%A5%E4%BD%9C%E5%85%A9%E5%B9%B4%E8%BE%AD%E8%81%B7%E6%BA%96%E5%82%99%E7%A0%94%E7%A9%B6%E6%89%80/">工作兩年辭職準備研究所</a></h2><div class="post-info">Mar 23, 2019</div><div class="post-content"><h2 id="辭職準備研究所"><a href="#辭職準備研究所" class="headerlink" title="辭職準備研究所"></a>辭職準備研究所</h2><p>我從某四大機械系畢業後就去工作了，因為我的系排只有 70% 左右，也不想要準備考試，當時我對念書這件事情已經非常厭倦，我對機械系也不是真的非常有熱忱，所以就想，那就出去工作吧，至少可以看看自己到底能不能獨立生活，當時也想好再過一兩年如果改變心意想念研究所那就去吧。</p>
<h2 id="推甄和考試"><a href="#推甄和考試" class="headerlink" title="推甄和考試"></a>推甄和考試</h2><p>我從 2018 年的三月開始慢慢的讀起書來， 但因為是邊上班邊念書，一天大約只能唸到兩個小時左右的書，中間還經歷約末一個月常常加班的日子， 因此進度完全暫停，直到六月時決定提出辭呈，七月正式離職，之後就在補習班上了一暑假的課，約莫九月的時候開始準備推甄，推甄資料包含自傳推薦信都要花一定的時間準備，錄取之後找教授的時間也需要一個星期左右，我一直很擔心如果沒有推上任何一所學校，那準備的時間就浪費掉了，但因我覺得我在推甄上有一定優勢 (工作經驗)，所以不想放棄這個管道，最後我在十二月備上成大，一月備上交大，然後參加二月的研究所考試，清大的考試入學其實也是推甄的方式 (只是要考一科英文)，台大是普通考試方式，最後這兩間都正取了。我最後決定要在清大讀碩士，因為我對清大的實驗室比較感興趣。</p>
<h2 id="工作兩年再念研究所有什麼好處"><a href="#工作兩年再念研究所有什麼好處" class="headerlink" title="工作兩年再念研究所有什麼好處"></a>工作兩年再念研究所有什麼好處</h2><p>我覺得現在的我比大四的時候更知道自己想要什麼，我跟的實驗室有很大部分需要寫程式，所以我找了好幾個資工背景的朋友諮詢我要如何在最短時間內把我的程式能力拉起來，而我也希望可以試試看能不能趁此機會培養程式能力之後能朝資工領域發展。</p>
<p>因為工作過的關係，實驗室可以培養我什麼能力是我選實驗室的第一準則，因為我知道我的能力會影響我的下一份工作，學歷會影響一個人的第一份工作，第一份工作的內容會影響第二份工作，一個實驗室或一份工作，對現在的我來說最重要的是它能讓我變成更有能力的人，帶給我更好的機會，帶我去更好的地方。</p>
<h2 id="工作兩年再念研究所有什麼壞處"><a href="#工作兩年再念研究所有什麼壞處" class="headerlink" title="工作兩年再念研究所有什麼壞處"></a>工作兩年再念研究所有什麼壞處</h2><p>我說了這麼多先工作再念書的好處，但不在大四應屆考取研究所還是有一定的風險，就是不知道到底回不回的去學校，好幾年沒有認真念書了，推甄不確定推得上，考試又怕自己太久沒唸書不知道還行不行，這半年真的是過的非常焦慮，辭掉工作之後就不會每個月有錢進帳，存款只會一直減少，擔心半年後沒有考上回去找工作會找不到好公司，尤其我在補習班時發現似乎有些學生是準備一年到一年半去考試，而我只有半年還要同時準備推甄，一直都很擔心時間不夠。大約在成大備上後我陷入一段很糟的時間，因為我沒有在成大找到理想的老師，交大在可能會備上的邊緣，清大的考入入學不考試只做推甄可是我在清大推甄時已經落榜過一次，再來一次難道就會上嗎 (結果再來一次真的就上了)，從備上成大到備上交大中間的這段時間我真的一直很焦慮，直到我在交大找到了我覺得很不錯的教授，我才比較恢復平常心繼續準備台大的考試。</p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>我可以收到四間大學的錄取單很大一部分還是要歸功我以前的努力，於推甄而言大學校名當然是重要的，工作兩年我覺得我的積極度和對於人生規劃的想法都多了很多，我覺得先工作一定是有很大的好處，也或許你工作之後才發現這份工作你根本一點也不喜歡，那也很好，可以在還年輕時就想方法轉換工作領域 (當然念研究所也是一種很好的轉換工作領域的方法)，(和科系相關的) 工作經歷對推甄來說是一個大大的加分項，但不論什麼方法，辭職是一件不可逆的事情，多少有一點賭自己上榜的意味在，除了辭職之外，半年的空白期我最害怕的事情，所以我在辭職之前已經在下班後念書，把自己對念書這件事情的熟悉感找回來，當我正式提出辭職時我的上司還問我要不要再考慮一下不要衝動辭職，但那時候其實我已經做好決定很久了，所以非常堅定的辭職了。</p>
</div></article></li></ul></main><footer><div class="paginator"></div><div class="copyright"><p>© 2019 - 2021 <a href="http://example.com">John Doe</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/claymcleod/hexo-theme-hermes" target="_blank">hexo-theme-hermes</a>. </p><p>Logo made by <a target="_blank" rel="noopener" href="https://www.flaticon.com/authors/freepik">Freepik</a> from <a target="_blank" rel="noopener" href="https://flaticon.com">www.flaticon.com</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>