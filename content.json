{"meta":{"title":"Wendy","subtitle":"","description":"","author":"Wendy","url":"http://example.com","root":"/"},"pages":[{"title":"About","date":"2021-08-26T04:19:32.645Z","updated":"2021-08-26T04:18:03.780Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-08-15T11:45:51.000Z","updated":"2021-08-15T11:48:30.955Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"NachOS MP3 - CPU scheduling","slug":"NachOS-MP3-CPU-scheduling","date":"2021-08-14T14:49:56.000Z","updated":"2021-08-26T13:07:18.320Z","comments":true,"path":"2021/08/14/NachOS-MP3-CPU-scheduling/","link":"","permalink":"http://example.com/2021/08/14/NachOS-MP3-CPU-scheduling/","excerpt":"","text":"&#x9019;&#x662F;&#x6E05;&#x5927;&#x5468;&#x5FD7;&#x9060;&#x6559;&#x6388;&#x4F5C;&#x696D;&#x7CFB;&#x7D71;&#x7684;&#x4F5C;&#x696D;&#xFF0C;&#x6211;&#x5728;&#x7DB2;&#x8DEF;&#x4E0A;&#x627E;&#x5230;&#x9019;&#x4EFD;&#x4F5C;&#x696D;&#x7684;&#x76F8;&#x95DC;&#x8CC7;&#x6599;&#xFF0C;&#x6211;&#x4E26;&#x6C92;&#x6709;&#x4E0A;&#x904E;&#x9019;&#x9580;&#x8AB2;&#xFF0C;&#x9019;&#x53EA;&#x662F;&#x6211;&#x7684;&#x81EA;&#x5B78;&#x7DF4;&#x7FD2;&#xFF0C;&#x76EE;&#x524D;&#x6211;&#x9084;&#x6C92;&#x6709;&#x5B8C;&#x6210;&#x9019;&#x4EFD;&#x4F5C;&#x696D;&#x7684;&#x5BE6;&#x4F5C;&#x3002; Code Study New -&gt; Ready 1. Kernel::ExecAll threads/kernel.cc&#x200B; &#x628A;&#x6240;&#x6709;&#x53EF;&#x57F7;&#x884C;&#x6A94;&#x4E1F;&#x9032; Exec &#x57F7;&#x884C;&#x3002; 1234567void Kernel::ExecAll(){ for (int i = 1; i &lt;= execfileNum; i++) { int a = Exec(execfile[i]); } currentThread-&gt;Finish();} thread &#x5B8C;&#x6210;&#x6240;&#x6709;&#x5DE5;&#x4F5C;&#x4E4B;&#x5F8C;&#xFF0C;&#x547C;&#x53EB; finish&#xFF0C;&#x5728;&#x63A7;&#x5236;&#x6B0A;&#x4EA4;&#x51FA;&#x53BB;&#x4E4B;&#x5F8C;&#xFF0C;&#x88AB; destroy&#x3002; 123456void Thread::Finish(){ (void) kernel-&gt;interrupt-&gt;SetLevel(IntOff); Sleep(TRUE); /* invokes SWITCH */ /* not reached */} 2. Kernel::Exec threads/kernel.cc&#x200B; &#x6BCF;&#x4E00;&#x500B;&#x53EF;&#x57F7;&#x884C;&#x6A94;&#x90FD;&#x9700;&#x8981; new &#x4E00;&#x500B;&#x65B0;&#x7684; thread &#x4F86;&#x57F7;&#x884C;&#x3002; 123456789int Kernel::Exec(char* name){ t[threadNum] = new Thread(name, threadNum); t[threadNum]-&gt;space = new AddrSpace(); t[threadNum]-&gt;Fork((VoidFunctionPtr)&amp;ForkExecute, (void*)t[threadNum]); threadNum++; return threadNum-1;} 3. Thread::Fork threads/thread.cc 1234567891011void Thread::Fork(VoidFunctionPtr func, void *arg){ Interrupt *interrupt = kernel-&gt;interrupt; Scheduler *scheduler = kernel-&gt;scheduler; IntStatus oldLevel; StackAllocate(func, arg); oldLevel = interrupt-&gt;SetLevel(IntOff); scheduler-&gt;ReadyToRun(this); (void) interrupt-&gt;SetLevel(oldLevel);} StackAllocate() &#x5EFA;&#x7ACB; thread stack &#x4EE5;&#x53CA;&#x521D;&#x59CB;&#x5316; machine register&#xFF0C;machine register &#x662F;&#x4E00;&#x500B; array&#xFF0C;NachOS &#x6703;&#x628A; machine register &#x5BEB;&#x5165;&#x4F60;&#x7684;&#x96FB;&#x8166;&#x88E1;&#x7684; CPU register&#xFF0C;&#x5373; host register&#xFF0C;&#x4ED6;&#x4E0D;&#x662F;&#x6A21;&#x64EC;&#x7684; register&#xFF0C;&#x4ED6;&#x662F;&#x771F;&#x7684;&#x6703;&#x628A;&#x9019;&#x4E9B;&#x503C;&#x5BEB;&#x9032;&#x4F60;&#x7684;&#x96FB;&#x8166;&#x7684; CPU register &#x88E1;&#x9762;&#xFF0C;&#x4E0D;&#x904E;&#x4E0D;&#x662F;&#x73FE;&#x5728;&#xFF0C;&#x662F;&#x5728;&#x505A; context switch &#x7684;&#x6642;&#x5019;&#x3002; 12345678910111213141516171819/* threads/thread.cc */void Thread::StackAllocate (VoidFunctionPtr func, void *arg){ stack = (int *) AllocBoundedArray(StackSize * sizeof(int)); ...#ifdef x86 stackTop = stack + StackSize - 4; /* -4 to be on the safe side */ *(--stackTop) = (int) ThreadRoot; *stack = STACK_FENCEPOST;#endif ... machineState[PCState] = (void*)ThreadRoot; machineState[StartupPCState] = (void*)ThreadBegin; machineState[InitialPCState] = (void*)func; machineState[InitialArgState] = (void*)arg; machineState[WhenDonePCState] = (void*)ThreadFinish;} 123456789/* lib/sysdep.cc */char *AllocBoundedArray(int size){#ifdef NO_MPROT return new char[size];#else ...} 1234567891011121314151617181920#ifdef x86/* the offsets of the registers from the beginning of the thread object */#define _ESP 0#define _EAX 4#define _EBX 8#define _ECX 12#define _EDX 16#define _EBP 20#define _ESI 24#define _EDI 28#define _PC 32/* These definitions are used in Thread::AllocateStack(). */#define PCState (_PC/4-1)#define FPState (_EBP/4-1)#define InitialPCState (_ESI/4-1)#define InitialArgState (_EDX/4-1)#define WhenDonePCState (_EDI/4-1)#define StartupPCState (_ECX/4-1) 4. Scheduler::ReadyToRun threads/scheduler.cc &#x5C07; thread &#x52A0;&#x5165; readyList&#xFF0C;&#x7576; scheduler &#x9700;&#x8981;&#x5B89;&#x6392; thread &#x4F86;&#x57F7;&#x884C;&#x7684;&#x6642;&#x5019;&#xFF0C;&#x5C31;&#x5F9E; readyList dequeue &#x4E00;&#x500B; thread &#x4F86;&#x57F7;&#x884C;&#x3002; 12345void Scheduler::ReadyToRun (Thread *thread){ thread-&gt;setStatus(READY); readyList-&gt;Append(thread);} 1234class Scheduler { Thread* FindNextToRun(); List&lt;Thread *&gt; *readyList; }; Running --&gt; Ready 1. Machine::Run machine/mippsim.cc 1234567891011void Machine::Run(){ /* storage for decoded instruction */ Instruction *instr = new Instruction; / kernel-&gt;interrupt-&gt;setStatus(UserMode); for (;;) { OneInstruction(instr); kernel-&gt;interrupt-&gt;OneTick(); }} 2. Interrupt::OneTick machine/interrupt.cc Onetick() &#x5C07;&#x7CFB;&#x7D71;&#x6642;&#x9593;&#x63A8;&#x9032;&#x4E00;&#x500B;&#x55AE;&#x4F4D;&#xFF0C;&#x82E5;&#x6709; context switch &#x61C9;&#x8A72;&#x767C;&#x751F;&#xFF0C;&#x547C;&#x53EB; Yield()&#x3002; 1234567891011121314151617181920212223242526void Interrupt::OneTick(){ MachineStatus oldStatus = status; Statistics *stats = kernel-&gt;stats; if (status == SystemMode) { stats-&gt;totalTicks += SystemTick; stats-&gt;systemTicks += SystemTick; } else { stats-&gt;totalTicks += UserTick; stats-&gt;userTicks += UserTick; } /* check for pending interrupts */ CheckIfDue(FALSE); /* if the timer device handler asked for a context switch, ok to do * it now */ if (yieldOnReturn) { yieldOnReturn = FALSE; status = SystemMode; /* yield is a kernel routine */ kernel-&gt;currentThread-&gt;Yield(); status = oldStatus; }} 12345class Interrupt {private: bool yieldOnReturn; /* TRUE if we are to context switch */ MachineStatus status; /* idle, kernel mode, user mode */} 3. Thread::Yield threads/thread.cc currentThread &#x547C;&#x53EB; Yield() &#x628A;&#x63A7;&#x5236;&#x6B0A;&#x8B93;&#x7D66;&#x5176;&#x4ED6; thread&#xFF0C;&#x547C;&#x53EB; FindNextToRun() &#x4F86;&#x6C7A;&#x5B9A;&#x8981;&#x628A;&#x63A7;&#x5236;&#x6B0A;&#x8B93;&#x7D66;&#x54EA;&#x500B; thread&#xFF0C;&#x5728;&#x4EA4;&#x51FA;&#x63A7;&#x5236;&#x6B0A;&#x524D;&#x5148;&#x628A;&#x81EA;&#x5DF1; schedule &#x9032; readyList &#x88E1;&#x9762;&#xFF0C;&#x624D;&#x547C;&#x53EB; Run() &#x8B93; nextThread &#x958B;&#x59CB;&#x4F7F;&#x7528; CPU&#x3002; 123456789101112void Thread::Yield(){ Thread *nextThread; IntStatus oldLevel = kernel-&gt;interrupt-&gt;SetLevel(IntOff); nextThread = kernel-&gt;scheduler-&gt;FindNextToRun(); if (nextThread != NULL) { kernel-&gt;scheduler-&gt;ReadyToRun(this); kernel-&gt;scheduler-&gt;Run(nextThread, FALSE); } (void) kernel-&gt;interrupt-&gt;SetLevel(oldLevel);} 4. Scheduler::FindNextToRun threads/scheduler.cc &#x5F9E; readyList &#x53D6;&#x51FA;&#x6700;&#x524D;&#x9762;&#x7684; thread&#xFF0C;&#x662F;&#x4E0B;&#x4E00;&#x500B;&#x8981;&#x57F7;&#x884C;&#x7684; thread&#x3002; 123456789Thread *Scheduler::FindNextToRun(){ if (readyList-&gt;IsEmpty()) { return NULL; } else { return readyList-&gt;RemoveFront(); }} 5. Scheduler::ReadyToRun threads/scheduler.cc 12345void Scheduler::ReadyToRun(Thread *thread){ thread-&gt;setStatus(READY); readyList-&gt;Append(thread);} 6. Scheduler::Run threads/scheduler.cc 123456789101112131415161718192021222324252627282930313233343536void Scheduler::Run (Thread *nextThread, bool finishing){ Thread *oldThread = kernel-&gt;currentThread; if (finishing) { /* mark that we need to delete old thread */ toBeDestroyed = oldThread; } if (oldThread-&gt;space &#xFF01;= NULL) { /* save the user&apos;s state */ oldThread-&gt;SaveUserState(); oldThread-&gt;space-&gt;SaveState(); } oldThread-&gt;CheckOverflow(); /* switch to the next thread */ kernel-&gt;currentThread = nextThread; /* nextThread is now running */ nextThread-&gt;setStatus(RUNNING); /* This is a machine-dependent assembly language routine defined * in switch.s */ SWITCH(oldThread, nextThread); /* we&apos;re back, running oldThread */ /* check if thread we were running before this one has finished * and needs to be cleaned up */ CheckToBeDestroyed(); if (oldThread-&gt;space != NULL) { /* if there is an address space to restore, do it */ oldThread-&gt;RestoreUserState(); oldThread-&gt;space-&gt;RestoreState(); }} &#x5982;&#x679C; finishing &#x70BA;&#x771F;&#xFF0C;&#x4EE3;&#x8868; old thread &#x61C9;&#x8A72;&#x88AB; destroy&#xFF0C;&#x56E0;&#x70BA;&#x4E00;&#x500B; thread &#x4E0D;&#x80FD;&#x81EA;&#x5DF1; destroy &#x81EA;&#x5DF1;&#xFF0C;&#x56E0;&#x6B64;&#x8981;&#x7B49; context switch &#x4E4B;&#x5F8C;&#x8B93;&#x4E0B;&#x4E00;&#x500B; thread destroy old thread&#x3002; 1234if (finishing) { /* mark that we need to delete old thread */ toBeDestroyed = oldThread;} 1234567void Scheduler::CheckToBeDestroyed(){ if (toBeDestroyed != NULL) { delete toBeDestroyed; toBeDestroyed = NULL; }} NachOS &#x6709;&#x5169;&#x5957; register&#xFF0C;&#x4E00;&#x5957;&#x662F; machineState&#xFF0C;&#x7528;&#x4F86;&#x5132;&#x5B58;&#x4F60;&#x7684;&#x96FB;&#x8166;&#x7684;&#x771F;&#x6B63;&#x7684; CPU register&#xFF0C;&#x5373; host register&#xFF0C;&#x53E6;&#x4E00;&#x5957; userRegisters &#x662F; NachOS &#x81EA;&#x5DF1;&#x6A21;&#x64EC;&#x7684; register&#xFF0C;&#x7528;&#x4F86;&#x5132;&#x5B58;&#x5728; OneInstruction() &#x6A21;&#x64EC;&#x6307;&#x4EE4;&#x57F7;&#x884C;&#x6642;&#x4F7F;&#x7528;&#x7684; register&#x3002; 12345if (oldThread-&gt;space &#xFF01;= NULL) { /* save the user&apos;s state */ oldThread-&gt;SaveUserState(); oldThread-&gt;space-&gt;SaveState();} 123456void Thread::SaveUserState(){ for (int i = 0; i &lt; NumTotalRegs; i++) { userRegisters[i] = kernel-&gt;machine-&gt;ReadRegister(i); }} 1234567891011121314void Machine::OneInstruction(Instruction *instr){ ... /* Execute the instruction */ switch (instr-&gt;opCode) { case OP_ADD: /* manipulate userRegisters */ sum = registers[instr-&gt;rs] + registers[instr-&gt;rt]; registers[instr-&gt;rd] = sum; break; ... } ...} &#x547C;&#x53EB; SWITCH() &#x9032;&#x884C; context switch&#xFF0C;&#x5728; SWITCH() &#x5B8C;&#x6210;&#x4E4B;&#x5F8C;&#xFF0C;&#x4E26;&#x4E0D;&#x6703;&#x7E7C;&#x7E8C;&#x57F7;&#x884C; Run() &#x7684;&#x4E0B;&#x4E00;&#x884C;&#xFF0C;&#x56E0;&#x70BA;&#x63A7;&#x5236;&#x6B0A;&#x5DF2;&#x7D93;&#x50B3;&#x7D66; nextThread&#xFF0C;&#x4E0B;&#x4E00;&#x884C;&#x8981;&#x88AB;&#x57F7;&#x884C;&#x7684;&#x6307;&#x4EE4;&#x662F; nextThread &#x7684;&#x6307;&#x4EE4;&#xFF0C;&#x7576; CheckToBeDestroyed() &#x88AB;&#x57F7;&#x884C;&#xFF0C;&#x4EE3;&#x8868;&#x5DF2;&#x7D93;&#x53C8;&#x8F2A;&#x5230;&#x9019;&#x500B; thread &#x4F7F;&#x7528; CPU&#xFF0C;&#x9019;&#x4E2D;&#x9593;&#x53EF;&#x80FD;&#x5DF2;&#x7D93;&#x5728;&#x597D;&#x5E7E;&#x500B; thread &#x4E4B;&#x9593; context switch &#x597D;&#x5E7E;&#x6B21;&#x4E86;&#x3002; 1SWITCH(oldThread, nextThread); SWITCH 1. SWITCH threads/switch.S &#x547C;&#x53EB; SWITCH() &#x9032;&#x884C; context switch&#xFF0C;oldThread &#x7684;&#x57F7;&#x884C;&#x505C;&#x6B62;&#xFF0C;newThread &#x958B;&#x59CB;&#x57F7;&#x884C;&#x3002;&#x7576;&#x4E00;&#x500B; thread &#x7B2C;&#x4E00;&#x6B21;&#x547C;&#x53EB; SWITCH() &#x6642;&#xFF0C;&#x4ED6;&#x6703;&#x5148;&#x57F7;&#x884C; ThreadRoot&#xFF0C;SWITCH() &#x4EE5;&#x7D44;&#x8A9E;&#x7DE8;&#x5BEB;&#xFF0C;&#x6211;&#x5011;&#x5FC5;&#x9808;&#x5F9E; StackAllocate() &#x958B;&#x59CB; trace code &#x624D;&#x80FD;&#x77E5;&#x9053;&#x70BA;&#x4EC0;&#x9EBC;&#x7B2C;&#x4E00;&#x6B21;&#x547C;&#x53EB; SWITCH() &#x6642;&#x6703;&#x57F7;&#x884C; ThreadRoot&#x3002; 123/* threads/thread.h */void SWITCH(Thread *oldThread, Thread *newThread); StackAllocate() &#x5EFA;&#x7ACB; thread stack &#x4EE5;&#x53CA;&#x521D;&#x59CB;&#x5316; machine register &#x7684;&#x503C;&#x3002; 123456789101112131415161718/* threads/thread.cc */void Thread::StackAllocate (VoidFunctionPtr func, void *arg){ stack = (int *) AllocBoundedArray(StackSize * sizeof(int)); ...#ifdef x86 stackTop = stack + StackSize - 4; /* -4 to be on the safe side */ *(--stackTop) = (int) ThreadRoot; *stack = STACK_FENCEPOST;#endif ... machineState[PCState] = (void*)ThreadRoot; machineState[StartupPCState] = (void*)ThreadBegin; machineState[InitialPCState] = (void*)func; machineState[InitialArgState] = (void*)arg; machineState[WhenDonePCState] = (void*)ThreadFinish;} 12345678class Thread {private: /* NOTE: DO NOT CHANGE the order of these first two members. * THEY MUST be in this position for SWITCH to work. */ int *stackTop; /* the current stack pointer */ void *machineState[MachineStateSize]; /* all registers except for * stackTop */} 1234567891011121314151617181920212223242526272829303132/* threads/switch.h */#ifdef x86/* the offsets of the registers from the beginning of the thread object */#define _ESP 0#define _EAX 4#define _EBX 8#define _ECX 12#define _EDX 16#define _EBP 20#define _ESI 24#define _EDI 28#define _PC 32/* These definitions are used in Thread::AllocateStack(). *//* Translate from offset to machineState index */#define PCState (_PC/4-1) /* 7 */#define FPState (_EBP/4-1) /* 1 */#define InitialPCState (_ESI/4-1) /* 5 */#define InitialArgState (_EDX/4-1) /* 3 */#define WhenDonePCState (_EDI/4-1) /* 6 */#define StartupPCState (_ECX/4-1) /* 2 */#define InitialPC %esi#define InitialArg %edx#define WhenDonePC %edi#define StartupPC %ecx#endif // x86 class Thread &#x7684;&#x8A3B;&#x89E3;&#x8981;&#x6C42;&#x6211;&#x5011;&#x4E0D;&#x80FD;&#x66F4;&#x52D5; stackTop &#x548C; machineState &#x7684;&#x9806;&#x5E8F;&#xFF0C;&#x76EE;&#x524D; Thread &#x7269;&#x4EF6;&#x7684;&#x8D77;&#x59CB;&#x4F4D;&#x7F6E;&#x548C; stackTop &#x7684; offset &#x70BA; 0&#xFF0C;&#x548C; machineState &#x7684;&#x8D77;&#x59CB;&#x4F4D;&#x7F6E; offset &#x70BA; 4&#xFF0C;&#x5982;&#x679C; offset &#x6709;&#x6240;&#x8B8A;&#x52D5;&#xFF0C;SWITCH() &#x7684;&#x5BE6;&#x505A;&#x5FC5;&#x9808;&#x6709;&#x76F8;&#x5C0D;&#x61C9;&#x7684;&#x8B8A;&#x52D5;&#x3002;&#x547C;&#x53EB; StackAllocate() &#x662F;&#x5C0D; Thread &#x7269;&#x4EF6;&#x9032;&#x884C;&#x521D;&#x59CB;&#x8A2D;&#x5B9A;&#xFF0C;&#x82E5;&#x6307;&#x5411; Thread &#x7269;&#x4EF6;&#x7684;&#x6307;&#x6A19;&#x70BA; t&#xFF0C;&#x4E0B;&#x5716;&#x662F;&#x547C;&#x53EB; StackAllocate() &#x5F8C; Thread &#x7269;&#x4EF6;&#x7684;&#x72C0;&#x614B;&#x3002; address thread member data value t + _ESP stackTop t + _EAX machineState[0] t + _EBX machineState[1] t + _ECX machineState[2] ThreadBegin t + _EDX machineState[3] arg t + _EBP machineState[4] t + _ESI machineState[5] ForkExecute t + _EDI machineState[6] ThreadFinish t + _PC machineState[7] ThreadRoot x86 &#x7684; compiler &#x6703;&#x5C07; c &#x8A9E;&#x8A00;&#x5C0D; SWITCH() &#x7684; function call &#x7DE8;&#x8B6F;&#x6210;&#x5148; push argument &#x548C; return address&#xFF0C;&#x518D;&#x8DF3;&#x5230; assembly &#x88E1; SWITCH &#x7684; label&#xFF0C;&#x6B64;&#x6642; stack &#x7684;&#x5167;&#x5BB9;&#x5982;&#x4E0B;&#x3002; address value stack pointer + 8 new thread *t2 stack pointer + 4 old thread *t1 stack pointer return address &#x6211;&#x5011;&#x547C;&#x53EB; SWITCH() &#x662F;&#x70BA;&#x4E86;&#x9032;&#x884C; context switch&#xFF0C;SWITCH() &#x7684;&#x5BE6;&#x505A;&#x662F;&#x4FDD;&#x5B58;&#x7576;&#x4E0B; host register &#x5167;&#x5BB9;&#xFF0C;&#x4E26;&#x8F09;&#x5165;&#x4E0B;&#x4E00;&#x500B;&#x8981;&#x57F7;&#x884C;&#x7684; thread &#x7684; host register&#x3002;&#x6211;&#x5011;&#x5C07;&#x7576;&#x4E0B;&#x7684; host register &#x5167;&#x5BB9;&#x4FDD;&#x5B58;&#x5728;&#x7269;&#x4EF6; thread &#x88E1;&#x7684; stackTop &#x548C; machineState&#xFF0C;&#x5C07;&#x4E0B;&#x4E00;&#x500B;&#x8981;&#x57F7;&#x884C;&#x7684; thread&#x7269;&#x4EF6;&#x7684; stackTop &#x548C; machineState &#x8F09;&#x5165; register&#x3002;&#x89C0;&#x5BDF; SWITCH &#x7D44;&#x8A9E;&#xFF0C;&#x53EF;&#x4EE5;&#x770B;&#x5230;&#x6211;&#x5011;&#x6709; 8 &#x500B; register &#x9700;&#x8981;&#x88AB;&#x4FDD;&#x5B58;&#xFF0C;&#x9664;&#x4E86;&#x9019; 8 &#x500B; register &#x4E4B;&#x5916;&#xFF0C;&#x9084;&#x8981;&#x4FDD;&#x5B58; return address&#xFF0C;return address &#x653E;&#x5728;&#x4F4D;&#x5740; (%esp)&#xFF0C;&#x4E0D;&#x662F;&#x653E;&#x5728; register esp&#xFF0C;&#x662F;&#x653E;&#x5728;&#x8A18;&#x61B6;&#x9AD4;&#x4F4D;&#x5740; (%esp)&#xFF0C;&#x56E0;&#x70BA; register esp &#x653E;&#x7684;&#x662F; stack pointer&#xFF0C;&#x800C; return address &#x662F;&#x653E;&#x5728; stack &#x88E1;&#x3002; &#x5FC5;&#x9808;&#x7279;&#x5225;&#x8AAA;&#x660E;&#x7684;&#x662F;&#xFF0C;SWITCH() &#x6240;&#x64CD;&#x4F5C;&#x7684; machineState &#x662F; host register&#xFF0C;&#x81F3;&#x65BC;&#x70BA;&#x4EC0;&#x9EBC; context switch &#x9700;&#x8981;&#x5207;&#x63DB; host register&#xFF0C;&#x6211;&#x4E0D;&#x77E5;&#x9053;&#xFF0C;&#x56E0;&#x70BA;&#x6211;&#x500B;&#x4EBA;&#x7406;&#x89E3;&#x61C9;&#x8A72;&#x53EA;&#x8981;&#x5207;&#x63DB; userRegister &#x5C31;&#x53EF;&#x4EE5;&#x4E86;&#x3002;&#x6211;&#x539F;&#x672C;&#x7684;&#x731C;&#x6E2C;&#xFF0C;&#x5982;&#x679C; NachOS &#x6703;&#x5728; guest instruction &#x57F7;&#x884C;&#x5230;&#x4E00;&#x534A;&#x7684;&#x6642;&#x5019;&#x9032;&#x884C; context switch&#xFF0C;&#x78BA;&#x5BE6;&#x6703;&#x9700;&#x8981;&#x628A; host &#x7684;&#x72C0;&#x614B;&#x4E5F;&#x4FDD;&#x7559;&#x4E0B;&#x4F86;&#xFF0C;&#x4F46;&#x6211;&#x76EE;&#x524D; trace code &#x7684;&#x7D50;&#x679C;&#xFF0C;context switch &#x90FD;&#x6703;&#x5728;&#x4E00;&#x500B;&#x6307;&#x4EE4;&#x5B8C;&#x6574;&#x5B8C;&#x6210;&#x4E4B;&#x5F8C;&#x624D;&#x6703;&#x9032;&#x884C;&#xFF0C;&#x6240;&#x4EE5;&#x6211;&#x771F;&#x7684;&#x60F3;&#x4E0D;&#x5230;&#x6709;&#x4EC0;&#x9EBC;&#x539F;&#x56E0;&#x9808;&#x8981;&#x5207;&#x63DB; host register&#x3002; 123456789101112131415161718192021222324252627282930313233343536 .comm _eax_save,4 # _eax_save is a 4 byte data .globl SWITCH .globl _SWITCH_SWITCH: SWITCH: movl %eax,_eax_save # save the value of eax to _eax_save movl 4(%esp),%eax # move pointer to t1 into eax movl %ebx,_EBX(%eax) # save ebx to machineState[1] of t1 movl %ecx,_ECX(%eax) # save ecx to machineState[2] of t1 movl %edx,_EDX(%eax) # save edx to machineState[3] of t1 movl %esi,_ESI(%eax) # save esi to machineState[5] of t1 movl %edi,_EDI(%eax) # save edi to machineState[6] of t1 movl %ebp,_EBP(%eax) # save ebp to machineState[4] of t1 movl %esp,_ESP(%eax) # save esp to stackTop of t1 movl _eax_save,%ebx # save the value of _eax_save to ebx movl %ebx,_EAX(%eax) # save ebx to machineState[0] of t1 movl 0(%esp),%ebx # get return address from stack into ebx movl %ebx,_PC(%eax) # save return address to machineState[7] # of t1 movl 8(%esp),%eax # move pointer to t2 into eax movl _EAX(%eax),%ebx # restore machineState[0] of t2 to ebx movl %ebx,_eax_save # save the value of ebx to _eax_save movl _EBX(%eax),%ebx # restore machineState[1] of t2 to ebx movl _ECX(%eax),%ecx # restore machineState[2] of t2 to ecx movl _EDX(%eax),%edx # restore machineState[3] of t2 to edx movl _ESI(%eax),%esi # restore machineState[5] of t2 to esi movl _EDI(%eax),%edi # restore machineState[6] of t2 to edi movl _EBP(%eax),%ebp # restore machineState[4] of t2 to ebp movl _ESP(%eax),%esp # restore stackTop of t2 to esp movl _PC(%eax),%eax # restore return address into eax movl %eax,4(%esp) # copy over the ret address on the stack movl _eax_save,%eax # save the value of _eax_save to eax ret &#x5728;&#x8F09;&#x5165;&#x4E0B;&#x4E00;&#x500B;&#x8981;&#x57F7;&#x884C;&#x7684; thread &#x7684; register &#x4E4B;&#x5F8C;&#xFF0C;return address &#x88AB;&#x8986;&#x5BEB;&#xFF0C;&#x56E0;&#x6B64;&#x5728; SWITCH() &#x7D50;&#x675F;&#x4E4B;&#x5F8C;&#xFF0C;&#x4E0D;&#x6703; return &#x56DE;&#x539F;&#x672C;&#x7684; thread&#xFF0C;&#x800C;&#x662F; return &#x56DE;&#x4E0B;&#x4E00;&#x500B;&#x8981;&#x57F7;&#x884C;&#x7684; thread&#xFF0C;&#x5982;&#x6B64;&#x4E00;&#x500B; context switch &#x5373;&#x5B8C;&#x6210;&#x3002; 1movl %eax,4(%esp) # copy over the ret address on the stack &#x4EE5;&#x6211;&#x7684;&#x7406;&#x89E3;&#xFF0C;&#x7576; SWITCH() &#x9032;&#x884C;&#x5230;&#x7D44;&#x8A9E; ret &#x6642;&#x6703; return &#x56DE;&#x4F4D;&#x5740; %esp&#xFF0C;&#x56E0;&#x6B64;&#x5728;&#x8986;&#x5BEB; return address &#x6642;&#x61C9;&#x8A72;&#x5BEB;&#x5230;&#x4F4D;&#x5740; %esp&#xFF0C;&#x4F46;&#x5728;&#x9019;&#x88E1;&#x4ED6;&#x5BEB;&#x5230;&#x4F4D;&#x5740; 4(%esp)&#xFF0C;&#x6211;&#x5341;&#x5206;&#x56F0;&#x60D1;&#x3002;&#x4EE5;&#x4E0B;&#x7D14;&#x5C6C;&#x6211;&#x500B;&#x4EBA;&#x731C;&#x6E2C;&#xFF0C;&#x5C0D;&#x7167; SWITCH &#x7684;&#x8A3B;&#x89E3;&#xFF0C;&#x6216;&#x8A31; movl %eax,_eax_save&#xFF0C;&#x6703;&#x4F7F;&#x5F97; _eax_save &#x88AB; push &#x9032; stack&#xFF0C;&#x800C; movl _eax_save,%ebx&#xFF0C;&#x6703;&#x4F7F;&#x5F97; _eax_save &#x88AB; pop &#x51FA; stack&#x3002;&#x5982;&#x679C;&#x9019;&#x500B;&#x63A8;&#x6E2C;&#x5C6C;&#x5BE6;&#xFF0C;&#x5C31;&#x53EF;&#x4EE5;&#x89E3;&#x91CB;&#x70BA;&#x4EC0;&#x9EBC;&#x5728;&#x8986;&#x5BEB; return address &#x6642;&#x6703;&#x4F7F;&#x7528; %eax,4(%esp)&#xFF0C;&#x56E0;&#x70BA;&#x6B64;&#x6642; (%esp) &#x6307;&#x5411;&#x525B; push &#x9032;&#x53BB;&#x7684; _eax_save&#xFF0C;4(%esp) &#x624D;&#x6307;&#x5411; return address&#xFF0C;&#x5728; ret &#x524D;&#x7684;&#x6700;&#x5F8C;&#x4E00;&#x500B;&#x6307;&#x4EE4; movl _eax_save,%eax&#xFF0C;&#x5982;&#x679C;&#x5982;&#x6211;&#x5011;&#x731C;&#x6E2C;&#x7684;&#x5C07; _eax_save pop &#x51FA; stack&#xFF0C;&#x5247;&#x6B64;&#x6642; (%esp) &#x53C8;&#x5C07;&#x662F;&#x6307;&#x5411; return address&#xFF0C;&#x53EF;&#x4EE5;&#x9806;&#x5229;&#x5B8C;&#x6210; context switch&#xFF0C;&#x4EE5;&#x4E0A;&#x7D14;&#x5C6C;&#x6211;&#x500B;&#x4EBA;&#x731C;&#x6E2C;&#xFF0C;&#x56E0;&#x70BA;&#x6211;&#x627E;&#x4E0D;&#x5230;&#x8B49;&#x64DA;&#x6216;&#x662F;&#x5176;&#x4ED6;&#x89E3;&#x91CB;&#x3002; 12345/* threads/switch.s *//* we push the current eax on the stack so that we can use it as * a pointer to t1, this decrements esp by 4, so when we use it * to reference stuff on the stack, we add 4 to the offset. */ 2. ThreadRoot threads/switch.S &#x7576;&#x4E00;&#x500B; thread &#x7B2C;&#x4E00;&#x6B21;&#x53D6;&#x5F97;&#x63A7;&#x5236;&#x6B0A;&#xFF0C;&#x4ED6;&#x4E4B;&#x524D;&#x6C92;&#x6709;&#x57F7;&#x884C;&#x904E;&#x4EFB;&#x4F55;&#x6771;&#x897F;&#xFF0C;&#x90A3;&#x4ED6;&#x61C9;&#x8A72;&#x8981; return &#x56DE;&#x54EA;&#x88E1;&#x5462;&#xFF0C;&#x5728;&#x547C;&#x53EB; StackAllocate() &#x6642;&#x6240;&#x505A;&#x7684;&#x521D;&#x59CB;&#x5316;&#xFF0C;&#x5DF2;&#x7D93;&#x6307;&#x5B9A;&#x7576;&#x4E00;&#x500B; thread &#x7B2C;&#x4E00;&#x6B21;&#x53D6;&#x5F97;&#x63A7;&#x5236;&#x6B0A;&#x6642;&#xFF0C;&#x4ED6;&#x6703; return &#x5230; ThreadRoot&#xFF0C;&#x4E5F;&#x5C31;&#x662F;&#x4ED6;&#x6703;&#x53BB;&#x57F7;&#x884C; ThreadRoot&#xFF0C;&#x56E0;&#x6B64;&#x6211;&#x5011;&#x63A5;&#x4E0B;&#x4F86;&#x8981;&#x770B;&#xFF0C;ThreadRoot &#x6703;&#x505A;&#x54EA;&#x4E9B;&#x4E8B;&#x60C5;&#x3002; register offset thread member data value ecx t + _ECX machineState[2] ThreadBegin edx t + _EDX machineState[3] arg esi t + _ESI machineState[5] ForkExecute edi t + _EDI machineState[6] ThreadFinish t + _PC machineState[7] ThreadRoot 12345678/* threads/thread.cc *//* func - &amp;ForkExecute *//* arg - (void*)t[threadNum] */void Thread::StackAllocate (VoidFunctionPtr func, void *arg){ ... } ThreadRoot &#x5148;&#x628A; arg push &#x9032; stack&#xFF0C;&#x63A5;&#x8457;&#x547C;&#x53EB; ThreadBegin()&#xFF0C;&#x547C;&#x53EB; ForkExecute()&#xFF0C;&#x547C;&#x53EB; ThreadFinish()&#x3002; 12345678910111213141516171819202122232425#define InitialPC %esi#define InitialArg %edx#define WhenDonePC %edi#define StartupPC %ecx .globl ThreadRoot .globl _ThreadRoot _ThreadRoot: ThreadRoot: pushl %ebp # push value of %ebp to stack movl %esp,%ebp # move %esp to %ebp pushl InitialArg # push value of %edx to stack call *StartupPC # push return address to stack, then set CPU program counter %ecx call *InitialPC # push return address to stack, then set CPU # program counter %esi call *WhenDonePC # push return address to stack, then set CPU # program counter %edi # NOT REACHED movl %ebp,%esp popl %ebp ret 3. ThreadBegin threads/thread.cc 123456/* deallocate the previously running thread if it finished. */static void ThreadBegin() { kernel-&gt;currentThread-&gt;Begin(); } 1234void Thread::Begin (){ kernel-&gt;scheduler-&gt;CheckToBeDestroyed();} 12345678910/* If the old thread gave up the processor because it was finishing, * we need to delete its carcass. */ void Scheduler::CheckToBeDestroyed(){ if (toBeDestroyed != NULL) { delete toBeDestroyed; toBeDestroyed = NULL; }} 4. ForkExecute threads/kernel.cc 123456789void ForkExecute(Thread *t){ /* load executable file from file to memory &amp; * allocate pageTable for this thread */ if (!t-&gt;space-&gt;Load(t-&gt;getName())) { return; /* executable not found */ } t-&gt;space-&gt;Execute(t-&gt;getName());} 12345678void AddrSpace::Execute(char* fileName) { kernel-&gt;currentThread-&gt;space = this; this-&gt;InitRegisters(); /* initialize user register */ this-&gt;RestoreState(); /* load page table register */ kernel-&gt;machine-&gt;Run(); /* jump to the user program */ ASSERTNOTREACHED(); /* machine-&gt;Run never returns; */ } 5. ThreadFinish threads/thread.cc 1234567/* called by ThreadRoot when a thread is done executing the forked * procedure. */static void ThreadFinish(){ kernel-&gt;currentThread-&gt;Finish(); } 1234void Thread::Finish(){ Sleep(TRUE); /* invokes SWITCH */} Running --&gt; Waiting 1. SynchConsoleOutput::PutChar userporg/synchconsole.cc &#x53EA;&#x6709;&#x4E00;&#x500B; console&#xFF0C;&#x56E0;&#x6B64;&#x5FC5;&#x9808;&#x8981; sync&#xFF0C;&#x8F38;&#x51FA;&#x7684;&#x904E;&#x7A0B;&#x662F; critical section&#xFF0C;&#x4E00;&#x6B21;&#x53EA;&#x80FD;&#x6709;&#x4E00;&#x500B; thread &#x505A; console output&#xFF0C;schedule &#x5B8C;&#x8F38;&#x51FA;&#x4E4B;&#x5F8C;&#x624D;&#x80FD; release lock &#x8B93;&#x5225;&#x7684; thread &#x4E5F;&#x80FD;&#x53BB;&#x505A;&#x8F38;&#x51FA;&#x3002; 1234567void SynchConsoleOutput::PutChar(char ch){ lock-&gt;Acquire(); consoleOutput-&gt;PutChar(ch); waitFor-&gt;P(); lock-&gt;Release();} 2. ConsoleOutput::PutChar machine/console.cc &#x547C;&#x53EB; WriteFile() &#x5C0D;&#x87A2;&#x5E55;&#x9032;&#x884C;&#x8F38;&#x51FA;&#xFF0C;&#x547C;&#x53EB; Schedule() &#x6A21;&#x64EC;&#x87A2;&#x5E55;&#x5B8C;&#x6210;&#x8F38;&#x51FA;&#x5F8C;&#x767C;&#x51FA; interrupt&#x3002; 12345void ConsoleOutput::PutChar(char ch){ WriteFile(writeFileNo, &amp;ch, sizeof(char)); kernel-&gt;interrupt-&gt;Schedule(this, ConsoleTime, ConsoleWriteInt);} WriteFile() &#x7684;&#x5BE6;&#x505A;&#x662F;&#x547C;&#x53EB; linux &#x63D0;&#x4F9B;&#x7684; write()&#xFF0C;fd &#x662F;&#x88AB;&#x5BEB;&#x5165;&#x6A94;&#x6848;&#x7684; file descriptor&#xFF0C;writeFileNo &#x7684;&#x503C;&#x5728; console.cc &#x4E2D;&#x88AB; assign &#x70BA; 1&#x3002; &#x5728; linux &#x7CFB;&#x7D71;&#x4E2D;&#xFF0C;file descriptor &#x70BA; 1 &#x5373;&#x662F; stdout&#xFF0C;&#x5B57;&#x5143;&#x6703;&#x88AB;&#x8F38;&#x51FA;&#x5230;&#x87A2;&#x5E55;&#x3002; 1234567/* lib/sysdep.cc */int WriteFile(int fd, char *buffer, int nBytes){ int retVal = write(fd, buffer, nBytes); return retVal;} &#x4E00;&#x500B;&#x771F;&#x6B63;&#x7684;&#x4F5C;&#x696D;&#x7CFB;&#x7D71;&#x6703;&#x5728;&#x8F38;&#x51FA;&#x5B8C;&#x6210;&#x7684;&#x6642;&#x5019;&#x767C;&#x51FA; interrupt&#xFF0C;&#x7531;&#x65BC;&#x9019;&#x4E0D;&#x662F;&#x771F;&#x7684;&#x4F5C;&#x696D;&#x7CFB;&#x7D71;&#xFF0C;&#x6240;&#x4EE5;&#x4ED6;&#x53EA;&#x80FD;&#x9810;&#x4F30;&#x8F38;&#x51FA;&#x6642;&#x9593;&#x7136;&#x5F8C;&#x81EA;&#x5DF1;&#x767C;&#x51FA; interrupt &#x3002;NachOS &#x9810;&#x4F30;&#x5B57;&#x5143;&#x8F38;&#x51FA;&#x9700;&#x8981; 100 &#x55AE;&#x4F4D;&#x6642;&#x9593;&#xFF0C;&#x56E0;&#x6B64;&#x5B89;&#x6392;&#x5728; 100 &#x500B;&#x55AE;&#x4F4D;&#x6642;&#x9593;&#x5F8C;&#x767C;&#x51FA; interrupt &#x3002;&#x95DC;&#x9375;&#x5B57; this &#x901A;&#x5E38;&#x88AB;&#x7528;&#x5728;&#x4E00;&#x500B; class &#x5167;&#x90E8;&#xFF0C;this &#x662F;&#x4E00;&#x500B;&#x6307;&#x6A19;&#xFF0C;&#x6307;&#x5411;&#x6B63;&#x5728;&#x88AB;&#x57F7;&#x884C;&#x7684; class &#x7684;&#x7269;&#x4EF6;&#xFF0C;&#x56E0;&#x6B64; this &#x662F; ConsoleOutput&#x3002; 1kernel-&gt;interrupt-&gt;Schedule(this, ConsoleTime, ConsoleWriteInt); 123/* machine/stats.h */ const int ConsoleTime = 100; /* time to read or write one character */ IntType &#x7D00;&#x9304;&#x9019;&#x500B; interrupt &#x662F;&#x7531;&#x54EA;&#x500B;&#x786C;&#x9AD4;&#x767C;&#x51FA;&#xFF0C;NachOS&#x652F;&#x63F4;&#x516D;&#x7A2E;&#x786C;&#x9AD4;&#x76F8;&#x95DC; interrupt&#x3002; 1234/* machine/interrupt.h */enum IntType { TimerInt, DiskInt, ConsoleWriteInt, ConsoleReadInt, NetworkSendInt, NetworkRecvInt}; writeFileNo &#x7684;&#x503C;&#x5728; console.cc &#x4E2D;&#x88AB; assign &#x70BA; 1&#x3002; 1234567891011/* machine/console.cc */ConsoleOutput::ConsoleOutput(char *writeFile, CallBackObj *toCall){ if (writeFile == NULL) { writeFileNo = 1; } else { writeFileNo = OpenForWrite(writeFile); }} 123/* threads/kernel.cc */synchConsoleOut = new SynchConsoleOutput(consoleOut); 123/* threads/kernel.cc */consoleOut = NULL; 3. Semaphore::P threads/synch.cc 123456789101112/* threads/synch.h */class Semaphore {public: void P(); /* waits until value &gt; 0, then decrement */ void V(); /* increment, waking up a thread waiting in P() if * necessary */private: int value; List&lt;Thread *&gt; *queue; /* threads waiting in P() for the value to be * &gt; 0 */ }; waitFor &#x662F; class Semaphore &#x7684;&#x7269;&#x4EF6;&#x3002; 1waitFor-&gt;P(); 123456789101112/* threads/synch.h */class Semaphore {public: void P(); /* waits until value &gt; 0, then decrement */ void V(); /* increment, waking up a thread waiting in P() if * necessary */private: int value; List&lt;Thread *&gt; *queue; /* threads waiting in P() for the value to be * &gt; 0 */ }; &#x5728; SynchConsole &#x7684;&#x5EFA;&#x69CB;&#x5B50;&#xFF0C;&#x6211;&#x5011;&#x53EF;&#x4EE5;&#x770B;&#x5230; waitFor &#x7684;&#x521D;&#x59CB;&#x503C;&#x662F; 0&#xFF0C;&#x56E0;&#x6B64;&#x7576;&#x7B2C;&#x4E00;&#x500B;&#x8981;&#x8F38;&#x51FA;&#x7684;&#x5B57;&#x5143;&#x9032;&#x5165; Semaphore &#x6642;&#xFF0C;&#x5C31;&#x6703;&#x9032;&#x5165; while &#x8FF4;&#x5708;&#xFF0C;&#x4E26;&#x4E14;&#x9032;&#x5165; Sleep&#xFF0C;&#x7B49;&#x5230;&#x8F38;&#x51FA;&#x5B8C;&#x6210;&#xFF0C;kernel &#x6703;&#x9019;&#x500B; thread &#x52A0;&#x5165; readyList&#xFF0C;&#x4E26;&#x4E14;&#x547C;&#x53EB; CallBack()&#xFF0C;CallBack() &#x6703;&#x547C;&#x53EB; V() &#x8B93; value &#x5F9E; 0 &#x8B8A;&#x6210; 1&#xFF0C;&#x5728;&#x9019;&#x500B; thread &#x518D;&#x6B21;&#x53D6;&#x5F97;&#x63A7;&#x5236;&#x6B0A;&#x6642;&#xFF0C;value &#x662F; 1&#xFF0C;&#x6240;&#x4EE5;&#x53EF;&#x4EE5;&#x8DF3;&#x51FA; while &#x8FF4;&#x5708;&#xFF0C;&#x6B64;&#x6642; value &#x5F9E; 1 &#x8B8A;&#x6210; 0&#xFF0C;&#x56E0;&#x6B64;&#x82E5;&#x6709;&#x4E0B;&#x4E00;&#x500B; thread &#x9032;&#x5165; Semaphore&#xFF0C;&#x4ED6;&#x5FC5;&#x9808;&#x91CD;&#x8907;&#x4E0A;&#x8FF0;&#x7684;&#x6D41;&#x7A0B;&#x3002; 12345678910/* threads/synch.cc */void Semaphore::P(){ while (value == 0) { queue-&gt;Append(currentThread); currentThread-&gt;Sleep(FALSE); } value--; } 12345678/* kernel/synchconsole.cc */SynchConsoleOutput::SynchConsoleOutput(char *outputFile){ consoleOutput = new ConsoleOutput(outputFile, this); lock = new Lock(&quot;console out&quot;); waitFor = new Semaphore(&quot;console out&quot;, 0);} 4. List::Append threads/synchlist.cc queue &#x662F; class List &#x7684;&#x7269;&#x4EF6;&#xFF0C;class List &#x88E1;&#x7DAD;&#x8B77;&#x4E00;&#x500B; linked list&#xFF0C;&#x547C;&#x53EB; Append() &#x5C07; currentThread &#x52A0;&#x5230; queue &#x7684;&#x5C3E;&#x7AEF;&#x3002; 123456789101112131415template &lt;class T&gt;void List&lt;T&gt;::Append(T item){ ListElement&lt;T&gt; *element = new ListElement&lt;T&gt;(item); if (IsEmpty()) { /* list is empty */ first = element; last = element; } else { /* else put it after last */ last-&gt;next = element; last = element; } numInList++;} 5. Thread::Sleep threads/thread.cc &#x5728; thread &#x9032;&#x5165; sleep &#x4E4B;&#x524D;&#xFF0C;&#x8981;&#x5148;&#x627E;&#x597D;&#x8981;&#x628A;&#x63A7;&#x5236;&#x6B0A;&#x7D66;&#x8AB0;&#xFF0C;&#x624D;&#x80FD;&#x628A;&#x63A7;&#x5236;&#x6B0A;&#x4EA4;&#x51FA;&#x53BB;&#xFF0C;&#x9032;&#x5165; sleep&#xFF0C;&#x7B49;&#x5230;&#x9019;&#x500B; thread &#x518D;&#x6B21;&#x57F7;&#x884C;&#x6642;&#xFF0C;&#x4EE3;&#x8868;&#x5B57;&#x5143;&#x5DF2;&#x7D93;&#x8F38;&#x51FA;&#x5B8C;&#x6210;&#x4E86;&#x3002; 123456789101112void Thread::Sleep (bool finishing){ Thread *nextThread; status = BLOCKED; while ((nextThread = kernel-&gt;scheduler-&gt;FindNextToRun()) == NULL) { kernel-&gt;interrupt-&gt;Idle(); } /* returns when it&apos;s time for us to run */ kernel-&gt;scheduler-&gt;Run(nextThread, finishing); } 6. Scheduler::FindNextToRun threads/scheduler.cc &#x5F9E; readyList &#x53D6;&#x51FA;&#x6700;&#x524D;&#x9762;&#x7684; thread&#xFF0C;&#x662F;&#x4E0B;&#x4E00;&#x500B;&#x8981;&#x57F7;&#x884C;&#x7684; thread&#x3002; 123456789Thread *Scheduler::FindNextToRun(){ if (readyList-&gt;IsEmpty()) { return NULL; } else { return readyList-&gt;RemoveFront(); }} 7. Scheduler::Run threads/scheduler.cc old thread &#x548C; next thread &#x9032;&#x884C; context switch&#x3002; 12345678910111213141516171819202122232425262728293031323334353637void Scheduler::Run (Thread *nextThread, bool finishing){ Thread *oldThread = kernel-&gt;currentThread; if (finishing) { /* mark that we need to delete current thread */ ASSERT(toBeDestroyed == NULL); toBeDestroyed = oldThread; } if (oldThread-&gt;space &#xFF01;= NULL) { /* save the user&apos;s state */ oldThread-&gt;SaveUserState(); oldThread-&gt;space-&gt;SaveState(); } oldThread-&gt;CheckOverflow(); /* switch to the next thread */ kernel-&gt;currentThread = nextThread; /* nextThread is now running */ nextThread-&gt;setStatus(RUNNING); /* This is a machine-dependent assembly language routine defined * in switch.s */ SWITCH(oldThread, nextThread); /* we&apos;re back, running oldThread */ /* check if thread we were running before this one has finished * and needs to be cleaned up */ CheckToBeDestroyed(); if (oldThread-&gt;space != NULL) { /* if there is an address space to restore, do it */ oldThread-&gt;RestoreUserState(); oldThread-&gt;space-&gt;RestoreState(); }} Waiting --&gt; Ready 1. void Machine::Run machine/mipssim.cc Onetick() &#x5C07;&#x7CFB;&#x7D71;&#x6642;&#x9593;&#x63A8;&#x9032;&#x4E00;&#x500B;&#x55AE;&#x4F4D;&#xFF0C;&#x4E26;&#x4E14;&#x6AA2;&#x67E5;&#x662F;&#x5426;&#x6709; interrupt &#x6B63;&#x8981;&#x767C;&#x751F;&#x3002; 123456789void Machine::Run(){ Instruction *instr = new Instruction; kernel-&gt;interrupt-&gt;setStatus(UserMode); for (;;) { OneInstruction(instr); kernel-&gt;interrupt-&gt;OneTick(); }} 2. Interrupt::OneTick machine/interrupt.cc &#x4E4B;&#x524D;&#x6211;&#x5011;&#x5728;&#x5B89;&#x6392;&#x8F38;&#x51FA;&#x6642;&#xFF0C;&#x6709; schedule &#x4E00;&#x500B; interrupt&#xFF0C;&#x6A21;&#x64EC;&#x786C;&#x9AD4;&#x5B8C;&#x6210;&#x8F38;&#x51FA;&#x6642;&#x767C;&#x51FA; interrupt&#xFF0C;&#x6211;&#x5011;&#x5728; CheckIfDue() &#x6AA2;&#x67E5;&#x662F;&#x5426;&#x6709;&#x61C9;&#x8A72;&#x767C;&#x751F;&#x7684; interrupt&#x3002; 123456789101112void Interrupt::OneTick(){ if (status == SystemMode) { stats-&gt;totalTicks += SystemTick; stats-&gt;systemTicks += SystemTick; } else { stats-&gt;totalTicks += UserTick; stats-&gt;userTicks += UserTick; } CheckIfDue(FALSE);} 3. Interrupt::CheckIfDue machine/interrupt.cc &#x5982;&#x679C;&#x6C92;&#x6709;interrupt &#x8981;&#x767C;&#x751F;&#xFF0C;&#x56DE;&#x50B3; false&#xFF0C;&#x82E5;&#x6709; interrupt &#x8981;&#x767C;&#x751F;&#xFF0C;&#x57F7;&#x884C;&#x4E26;&#x4E14;&#x56DE;&#x50B3; true&#xFF0C;&#x82E5; advanceClock &#x70BA; true&#xFF0C;&#x8868;&#x793A;&#x76EE;&#x524D;&#x5DF2;&#x7D93;&#x6C92;&#x6709;&#x4EFB;&#x4F55;&#x6307;&#x4EE4;&#x8981;&#x57F7;&#x884C;&#xFF0C;&#x5247;&#x76F4;&#x63A5;&#x57F7;&#x884C;&#x4E00;&#x500B; interrupt&#x3002; 1234567891011121314151617181920212223242526272829bool Interrupt::CheckIfDue(bool advanceClock){ PendingInterrupt *next; Statistics *stats = kernel-&gt;stats; if (pending-&gt;IsEmpty()) { return FALSE; } next = pending-&gt;Front(); if (next-&gt;when &gt; stats-&gt;totalTicks) { if (!advanceClock) { return FALSE; } else { stats-&gt;idleTicks += (next-&gt;when - stats-&gt;totalTicks); stats-&gt;totalTicks = next-&gt;when; } } inHandler = TRUE; do { next = pending-&gt;RemoveFront(); next-&gt;callOnInterrupt-&gt;CallBack(); delete next; } while(!pending-&gt;IsEmpty() &amp;&amp; (pending-&gt;Front()-&gt;when &lt;= stats-&gt;totalTicks)); inHandler = FALSE; return TRUE;} &#x82E5;&#x76EE;&#x524D;&#x6709;&#x8981;&#x767C;&#x751F;&#x7684; interrupt&#xFF0C;&#x628A; interrupt &#x5F9E; pending &#x4E2D;&#x53D6;&#x51FA;&#xFF0C;&#x547C;&#x53EB;&#x767C;&#x51FA;&#x6B64; interrupt &#x7269;&#x4EF6;&#x7684; callBack()&#xFF0C;&#x5728; interrupt &#x8655;&#x7406;&#x5B8C;&#x4E4B;&#x5F8C;&#xFF0C;&#x56DE;&#x50B3; true&#x3002; 12345do { next = pending-&gt;RemoveFront(); next-&gt;callOnInterrupt-&gt;CallBack(); delete next;} while(!pending-&gt;IsEmpty() &amp;&amp; (pending-&gt;Front()-&gt;when &lt;= stats-&gt;totalTicks)); 4. void ConsoleOutput::CallBack machine/console.cc &#x7576;&#x87A2;&#x5E55;&#x8F38;&#x51FA;&#x5B8C;&#x6210;&#xFF0C;ConsoleOutput &#x547C;&#x53EB; SynchConsoleOutput&#x7269;&#x4EF6;&#x7684; callBack()&#x3002; 123456void ConsoleOutput::CallBack() { putBusy = FALSE; kernel-&gt;stats-&gt;numConsoleCharsWritten++; callWhenDone-&gt;CallBack();} consoleOutput &#x7684; callWhenDone &#x662F; SynchConsoleOutput&#x3002; 123456/* machine/console.h */class ConsoleOutput : public CallBackObj {private: CallBackObj *callWhenDone; }; 123456/* machine/console.cc */ConsoleOutput::ConsoleOutput(char *writeFile, CallBackObj *toCall){ callWhenDone = toCall;} 123456/* userprog/synchconsole.cc */SynchConsoleOutput::SynchConsoleOutput(char *outputFile){ consoleOutput = new ConsoleOutput(outputFile, this);} 5. SynchConsoleOutput::CallBack userprog/synchconsole.cc 1234void SynchConsoleOutput::CallBack(){ waitFor-&gt;V();} &#x547C;&#x53EB; V() &#x91CB;&#x653E;&#x4E00;&#x500B; semaphore &#x8CC7;&#x6E90;&#xFF0C;&#x4E26;&#x4E14; pop &#x51FA;&#x4E0B;&#x4E00;&#x500B;&#x5728;queue &#x88E1;&#x7684; thread &#x653E;&#x9032; readyList&#xFF0C;&#x7B49;&#x5230; scheduler &#x5B89;&#x6392;&#x6B64; thread &#x53EF;&#x4EE5;&#x4F7F;&#x7528; CPU &#x6642;&#xFF0C;&#x4E0A;&#x4E00;&#x500B;&#x5B57;&#x5143;&#x5DF2;&#x7D93;&#x5B8C;&#x6210;&#x8F38;&#x51FA;&#xFF0C;&#x53EF;&#x4EE5;&#x8F38;&#x51FA;&#x4E0B;&#x4E00;&#x500B;&#x5B57;&#x5143;&#x3002; 123456789/* threads/synch.cc */void Semaphore::V(){ if (!queue-&gt;IsEmpty()) { kernel-&gt;scheduler-&gt;ReadyToRun(queue-&gt;RemoveFront()); } value++;} 6. Scheduler::ReadyToRun threads/scheduler.cc 12345void Scheduler::ReadyToRun (Thread *thread){ thread-&gt;setStatus(READY); readyList-&gt;Append(thread);} Running --&gt; Terminated 1. ExceptionHandler userprog/exception.cc &#x547C;&#x53EB; Finish() &#x7D50;&#x675F; current thread &#x7684;&#x57F7;&#x884C;&#x3002; 123456789101112131415161718void ExceptionHandler(ExceptionType which){ int type = kernel-&gt;machine-&gt;ReadRegister(2); int val; ... switch (which) { ... case SyscallException: switch(type) { ... case SC_Exit: val=kernel-&gt;machine-&gt;ReadRegister(4); cout &lt;&lt; &quot;return value:&quot; &lt;&lt; val &lt;&lt; endl; kernel-&gt;currentThread-&gt;Finish(); break; } ...} 2. Thread::Finish userprog/exception.cc 123456void Thread::Finish(){ (void) kernel-&gt;interrupt-&gt;SetLevel(IntOff); Sleep(TRUE); /* invokes SWITCH */ /* not reached */} 3. Thread::Sleep threads/thread.cc &#x5728;&#x547C;&#x53EB; Sleep() &#x6642;&#xFF0C;&#x5982;&#x679C;&#x50B3;&#x5165;&#x7684;&#x53C3;&#x6578;&#x662F; FALSE&#xFF0C;&#x4EE3;&#x8868;&#x9019;&#x500B; thread &#x53EA;&#x662F;&#x66AB;&#x6642;&#x4EA4;&#x51FA;&#x63A7;&#x5236;&#x6B0A;&#xFF0C;&#x4F46;&#x5982;&#x679C;&#x50B3;&#x5165;&#x7684;&#x53C3;&#x6578;&#x662F; TRUE&#xFF0C;&#x4EE3;&#x8868;&#x9019;&#x500B; thread &#x5DF2;&#x7D93;&#x5B8C;&#x6210;&#x5DE5;&#x4F5C;&#xFF0C;&#x8981;&#x88AB; destroy &#x4E86;&#x3002; 123456789101112void Thread::Sleep (bool finishing){ Thread *nextThread; status = BLOCKED; while ((nextThread = kernel-&gt;scheduler-&gt;FindNextToRun()) == NULL) { kernel-&gt;interrupt-&gt;Idle(); } /* not reach if finishing is TRUE */ kernel-&gt;scheduler-&gt;Run(nextThread, finishing); } 4. Scheduler::FindNextToRun threads/scheduler.cc &#x5F9E; readyList &#x53D6;&#x51FA;&#x6700;&#x524D;&#x9762;&#x7684; thread&#xFF0C;&#x662F;&#x4E0B;&#x4E00;&#x500B;&#x8981;&#x57F7;&#x884C;&#x7684; thread&#x3002; 123456789Thread *Scheduler::FindNextToRun(){ if (readyList-&gt;IsEmpty()) { return NULL; } else { return readyList-&gt;RemoveFront(); }} 5. Scheduler::Run threads/scheduler.cc 123456789101112131415161718192021222324252627282930313233343536void Scheduler::Run (Thread *nextThread, bool finishing){ Thread *oldThread = kernel-&gt;currentThread; if (finishing) { /* mark that we need to delete old thread */ toBeDestroyed = oldThread; } if (oldThread-&gt;space &#xFF01;= NULL) { /* save the user&apos;s state */ oldThread-&gt;SaveUserState(); oldThread-&gt;space-&gt;SaveState(); } oldThread-&gt;CheckOverflow(); /* switch to the next thread */ kernel-&gt;currentThread = nextThread; /* nextThread is now running */ nextThread-&gt;setStatus(RUNNING); /* This is a machine-dependent assembly language routine defined * in switch.s */ SWITCH(oldThread, nextThread); /* we&apos;re back, running oldThread */ /* check if thread we were running before this one has finished * and needs to be cleaned up */ CheckToBeDestroyed(); if (oldThread-&gt;space != NULL) { /* if there is an address space to restore, do it */ oldThread-&gt;RestoreUserState(); oldThread-&gt;space-&gt;RestoreState(); }} &#x5982;&#x679C; finishing &#x70BA;&#x771F;&#xFF0C;&#x4EE3;&#x8868; old thread &#x61C9;&#x8A72;&#x88AB; destroy&#xFF0C;&#x56E0;&#x70BA;&#x4E00;&#x500B; thread &#x4E0D;&#x80FD;&#x81EA;&#x5DF1; destroy &#x81EA;&#x5DF1;&#xFF0C;&#x56E0;&#x6B64;&#x8981;&#x7B49; context switch &#x4E4B;&#x5F8C;&#x8B93;&#x4E0B;&#x4E00;&#x500B; thread destroy old thread&#x3002; 1234if (finishing) { /* mark that we need to delete old thread */ toBeDestroyed = oldThread;} 1234567void Scheduler::CheckToBeDestroyed(){ if (toBeDestroyed != NULL) { delete toBeDestroyed; toBeDestroyed = NULL; }} Reference [1] shawn2000100/10810CS_342301_OperatingSystem https://github.com/shawn2000100/10810CS_342301_OperatingSystem","categories":[],"tags":[]},{"title":"微微主婦心得","slug":"微微主婦心得","date":"2021-08-12T18:56:29.000Z","updated":"2021-08-13T08:34:00.256Z","comments":true,"path":"2021/08/13/微微主婦心得/","link":"","permalink":"http://example.com/2021/08/13/%E5%BE%AE%E5%BE%AE%E4%B8%BB%E5%A9%A6%E5%BF%83%E5%BE%97/","excerpt":"","text":"&#x6691;&#x5047;&#x525B;&#x958B;&#x59CB;&#x7684;&#x6642;&#x5019;&#x5C0D;&#x75AB;&#x60C5;&#x9084;&#x6709;&#x9EDE;&#x671F;&#x5F85;&#xFF0C;&#x60F3;&#x8457;&#x75AB;&#x60C5;&#x662F;&#x4E0D;&#x662F;&#x5F88;&#x5FEB;&#x5C31;&#x6703;&#x7D50;&#x675F;&#x4E86;&#xFF0C;&#x5F88;&#x5FEB;&#x5C31;&#x80FD;&#x51FA;&#x53BB;&#x73A9;&#xFF0C;&#x73FE;&#x5728;&#x770B;&#x8D77;&#x4F86;&#xFF0C;&#x6574;&#x500B;&#x6691;&#x5047;&#x90FD;&#x5F97;&#x5728;&#x9632;&#x75AB;&#x4E4B;&#x4E2D;&#x5EA6;&#x904E;&#x4E86;&#x3002; &#x5F1F;&#x5F1F;&#x5728;&#x6691;&#x5047;&#x958B;&#x59CB;&#x7684;&#x6642;&#x5019;&#x958B;&#x59CB;&#x5BC6;&#x96C6;&#x9762;&#x8A66;&#xFF0C;&#x627E;&#x5230;&#x5DE5;&#x4F5C;&#x958B;&#x59CB;&#x52A0;&#x73ED;&#x4EBA;&#x751F;&#x5F8C;&#xFF0C;&#x5E38;&#x5E38;&#x4E5D;&#x9EDE;&#x624D;&#x56DE;&#x5BB6;&#xFF0C;&#x4E5F;&#x4E0D;&#x597D;&#x53EB;&#x4ED6;&#x505A;&#x4EC0;&#x9EBC;&#x5BB6;&#x4E8B;&#xFF0C;&#x53F0;&#x5317;&#x9084;&#x5728;&#x9632;&#x75AB;&#x671F;&#xFF0C;&#x53EA;&#x80FD;&#x5916;&#x5E36;&#x4E0D;&#x80FD;&#x5167;&#x7528;&#xFF0C;&#x53C8;&#x56E0;&#x70BA;&#x7537;&#x53CB;&#x9000;&#x5F79;&#x4F86;&#x6211;&#x5BB6;&#x66AB;&#x4F4F;&#x966A;&#x4F34;&#x6211;&#xFF0C;&#x6211;&#x4E5F;&#x5C31;&#x958B;&#x59CB;&#x8CA0;&#x8CAC;&#x5BB6;&#x88E1;&#x7684;&#x5348;&#x9910;&#xFF0C;&#x5F1F;&#x5F1F;&#x5728;&#x9762;&#x8A66;&#x671F;&#x9593;&#x716E;&#x7D66;&#x5F1F;&#x5F1F;&#x5403;&#xFF0C;&#x5F1F;&#x5F1F;&#x53BB;&#x4E0A;&#x73ED;&#x4E4B;&#x5F8C;&#x716E;&#x7D66;&#x7537;&#x53CB;&#x5403;&#x3002; &#x6211;&#x4EE5;&#x524D;&#x5176;&#x5BE6;&#x6C92;&#x6709;&#x610F;&#x8B58;&#x5230;&#x5BB6;&#x5EAD;&#x4E3B;&#x5A66;&#x8981;&#x505A;&#x9019;&#x9EBC;&#x591A;&#x5DE5;&#x4F5C;&#xFF0C;&#x96D6;&#x7136;&#x73FE;&#x5728;&#x5BB6;&#x88E1;&#x53EA;&#x4F4F;&#x4E86;&#x4E09;&#x500B;&#x4EBA;&#xFF0C;&#x537B;&#x5DF2;&#x7D93;&#x5E38;&#x5E38;&#x8981;&#x71D2;&#x6C34;&#xFF0C;&#x6D17;&#x8863;&#x670D;&#xFF0C;&#x8863;&#x670D;&#x6D17;&#x4E86;&#x8981;&#x66EC;&#x8981;&#x6298;&#xFF0C;&#x716E;&#x98EF;&#x4E4B;&#x524D;&#x8981;&#x5099;&#x6599;&#xFF0C;&#x5403;&#x5B8C;&#x4E4B;&#x5F8C;&#x8981;&#x6D17;&#x7897;&#xFF0C;&#x6BCF;&#x9031;&#x8981;&#x4E0A;&#x83DC;&#x5E02;&#x5834;&#x8CB7;&#x83DC;&#x8CB7;&#x8089;&#xFF0C;&#x53BB;&#x8D85;&#x5E02;&#x8CB7;&#x96DE;&#x86CB;&#x8CB7;&#x725B;&#x5976;&#xFF0C;&#x5BB6;&#x88E1;&#x5C11;&#x4E86;&#x6D17;&#x8863;&#x7CBE;&#x885B;&#x751F;&#x7D19;&#x7684;&#x4E5F;&#x5F97;&#x53BB;&#x88DC;&#x8CA8;&#xFF0C;&#x5BB6;&#x88E1;&#x5BC4;&#x4F86;&#x7684;&#x5E33;&#x55AE;&#x8981;&#x7E73;&#xFF0C;&#x4FE1;&#x4EF6;&#x8981;&#x8655;&#x7406;&#xFF0C;&#x5E38;&#x5728;&#x5BB6;&#x716E;&#x98EF;&#x5EDA;&#x9918;&#x589E;&#x52A0;&#x7684;&#x5F88;&#x5FEB;&#xFF0C;&#x5012;&#x5783;&#x573E;&#x7684;&#x983B;&#x7387;&#x4E5F;&#x6703;&#x589E;&#x52A0;&#x3002;&#x6211;&#x7684;&#x6642;&#x9593;&#x4E3B;&#x8981;&#x90FD;&#x9084;&#x662F;&#x82B1;&#x5728;&#x770B;&#x66F8;&#x5BEB;&#x4F5C;&#x696D;&#x4E0A;&#xFF0C;&#x4EE5;&#x4E0A;&#x7684;&#x6240;&#x6709;&#x5BB6;&#x4E8B;&#x7537;&#x53CB;&#x4E5F;&#x90FD;&#x6703;&#x5E6B;&#x5FD9;&#xFF0C;&#x82B1;&#x7684;&#x6642;&#x9593;&#x8AAA;&#x591A;&#x4E0D;&#x591A;&#xFF0C;&#x53EA;&#x662F;&#x5F88;&#x7463;&#x788E;&#xFF0C;&#x4F46;&#x5982;&#x679C;&#x5168;&#x90FD;&#x8981;&#x6211;&#x4E00;&#x500B;&#x4EBA;&#x505A;&#xFF0C;&#x90A3;&#x80AF;&#x5B9A;&#x8981;&#x82B1;&#x66F4;&#x591A;&#x6642;&#x9593;&#x3002; &#x9019;&#x4E9B;&#x4E8B;&#x8AAA;&#x96E3;&#x4E0D;&#x96E3;&#xFF0C;&#x8AAA;&#x7D2F;&#x4E5F;&#x4E0D;&#x662F;&#x5F88;&#x7D2F;&#xFF0C;&#x4F46;&#x4E00;&#x500B;&#x8A8D;&#x771F;&#x7684;&#x5BB6;&#x5EAD;&#x4E3B;&#x5A66;&#x505A;&#x7684;&#x4E8B;&#x60C5;&#x6BD4;&#x6211;&#x505A;&#x7684;&#x591A;&#x591A;&#x4E86;&#xFF0C;&#x6211;&#x53EA;&#x662F;&#x7DAD;&#x6301;&#x5BB6;&#x88E1;&#x4E0D;&#x8981;&#x592A;&#x4E82;&#x53EF;&#x4EE5;&#x6B63;&#x5E38;&#x904B;&#x4F5C;&#x800C;&#x5DF2;&#xFF0C;&#x5982;&#x679C;&#x8981;&#x7DAD;&#x6301;&#x5BB6;&#x88E1;&#x7684;&#x6574;&#x9F4A;&#x4E7E;&#x6DE8;&#xFF0C;&#x9084;&#x5F97;&#x8981;&#x4ED8;&#x51FA;&#x66F4;&#x591A;&#x6642;&#x9593;&#xFF0C;&#x5982;&#x679C;&#x9084;&#x8981;&#x7167;&#x9867;&#x5C0F;&#x5B69;&#x7684;&#xFF0C;&#x771F;&#x7684;&#x662F;&#x4E0D;&#x5BB9;&#x6613;&#xFF0C;&#x4EE5;&#x524D;&#x4E0D;&#x61C2;&#x5BB6;&#x5EAD;&#x4E3B;&#x5A66;&#x70BA;&#x4EC0;&#x9EBC;&#x5E38;&#x8AAA;&#x81EA;&#x5DF1;&#x4E5F;&#x5F88;&#x8F9B;&#x82E6;&#xFF0C;&#x73FE;&#x5728;&#x4E5F;&#x7B97;&#x662F;&#x5FAE;&#x5FAE;&#x9AD4;&#x9A57;&#x5230;&#x4E86;&#x3002;","categories":[{"name":"生活","slug":"生活","permalink":"http://example.com/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://example.com/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"Parallel TSP using pthread and fork","slug":"Parallel-TSP-using-pthread-and-fork","date":"2021-08-09T16:54:06.000Z","updated":"2021-08-26T13:08:04.837Z","comments":true,"path":"2021/08/10/Parallel-TSP-using-pthread-and-fork/","link":"","permalink":"http://example.com/2021/08/10/Parallel-TSP-using-pthread-and-fork/","excerpt":"","text":"Introduction TSP &#x65C5;&#x884C;&#x5546;&#x554F;&#x984C;&#x662F;&#x9019;&#x6A23;&#x4E00;&#x500B;&#x554F;&#x984C; : &#x7D66;&#x5B9A;&#x4E00;&#x7CFB;&#x5217;&#x57CE;&#x5E02;&#x548C;&#x6BCF;&#x5C0D;&#x57CE;&#x5E02;&#x4E4B;&#x9593;&#x7684;&#x8DDD;&#x96E2;&#xFF0C;&#x6C42;&#x89E3;&#x9020;&#x8A2A;&#x6BCF;&#x4E00;&#x5EA7;&#x57CE;&#x5E02;&#x4E00;&#x6B21;&#x4E26;&#x56DE;&#x5230;&#x8D77;&#x59CB;&#x57CE;&#x5E02;&#x7684;&#x6700;&#x77ED;&#x8FF4;&#x8DEF;&#x3002; 2-opt &#x5982;&#x679C;&#x6211;&#x5011;&#x7D66;&#x6BCF;&#x500B;&#x57CE;&#x5E02;&#x4E00;&#x500B;&#x7DE8;&#x865F;&#xFF0C;&#x5C31;&#x53EF;&#x4EE5;&#x4F7F;&#x7528;&#x4E00;&#x500B; string &#x4F86;&#x8868;&#x793A;&#x4E00;&#x500B;&#x8DEF;&#x5F91;&#x3002; 1[1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10] &#x7576;&#x6211;&#x5011;&#x8981;&#x505A;&#x6700;&#x4F73;&#x5316;&#x6642;&#xFF0C;&#x6211;&#x5011;&#x8981;&#x5B9A;&#x7FA9;&#x4E00;&#x500B;&#x89E3;&#x7684;&#x9130;&#x5C45;&#x3002;&#x6211;&#x4F7F;&#x7528; 2-opt &#x53BB;&#x5C0B;&#x627E;&#x4E00;&#x500B;&#x89E3;&#x7684;&#x9130;&#x5C45;&#x3002;&#x5C0D;&#x65BC;&#x4E00;&#x689D;&#x8DEF;&#x5F91;&#xFF0C;&#x4EFB;&#x9078;&#x5169;&#x500B;&#x57CE;&#x5E02;&#xFF0C;&#x5C07;&#x4ED6;&#x5011;&#x4E4B;&#x9593;&#x7684;&#x8DEF;&#x5F91;&#x505A;&#x7FFB;&#x8F49;&#x3002;&#x5728;&#x5716;&#x5F62;&#x4E0A;&#xFF0C;&#x505A;&#x9019;&#x6A23;&#x7684;&#x7FFB;&#x8F49;&#x6070;&#x597D;&#x53EF;&#x4EE5;&#x628A;&#x4E00;&#x500B;&#x4EA4;&#x53C9;&#x7684;&#x8DEF;&#x5F91;&#x6253;&#x958B;&#x3002; &#x4F7F;&#x7528; 2-opt &#x5728;&#x8A08;&#x7B97;&#x4E0A;&#x4E5F;&#x5F88;&#x65B9;&#x4FBF;&#xFF0C;&#x96D6;&#x7136;&#x8DEF;&#x5F91;&#x6539;&#x52D5;&#x5F88;&#x591A;&#xFF0C;&#x4F46;&#x662F;&#x5176;&#x5BE6;&#x53EA;&#x662F;&#x79FB;&#x9664;&#x5169;&#x500B; edge&#xFF0C;&#x518D;&#x52A0;&#x4E0A;&#x5169;&#x500B; edge&#x3002;&#x4EE5;&#x7FFB;&#x8F49;&#x57CE;&#x5E02; 3 &#x548C;&#x57CE;&#x5E02; 7 &#x4E4B;&#x9593;&#x7684;&#x8DEF;&#x5F91;&#x70BA;&#x4F8B;&#xFF0C;&#x5C31;&#x662F;&#x79FB;&#x9664; edge 23 &#x548C; edge 78&#xFF0C;&#x52A0;&#x4E0A; edge 27 &#x548C; edge 38&#xFF0C;&#x56E0;&#x70BA;&#x53EA;&#x6709;&#x6539;&#x52D5;&#x5230; 4 &#x500B; edge&#xFF0C;&#x6240;&#x4EE5;&#x5728;&#x8A08;&#x7B97;&#x8DEF;&#x5F91;&#x9577;&#x5EA6;&#x7684;&#x6642;&#x5019;&#x5F88;&#x5FEB;&#xFF0C;&#x53EA;&#x8981;&#x628A;&#x79FB;&#x9664;&#x7684; edge &#x9577;&#x5EA6;&#x6E1B;&#x6389;&#xFF0C;&#x628A;&#x52A0;&#x4E0A;&#x7684; edge &#x9577;&#x5EA6;&#x52A0;&#x4E0A;&#xFF0C;&#x4E0D;&#x9700;&#x8981;&#x6574;&#x689D;&#x8DEF;&#x5F91;&#x91CD;&#x65B0;&#x8A08;&#x7B97;&#x3002; 1[1 , 2 , 7 , 6 , 5 , 4 , 3 , 8 , 9 , 10] 2-opt parallel &#x6211;&#x4F7F;&#x7528;&#x8CAA;&#x5A6A;&#x6F14;&#x7B97;&#x6CD5;&#xFF0C;&#x6211;&#x6703;&#x628A;&#x4E00;&#x500B;&#x89E3;&#x7684;&#x6240;&#x6709;&#x9130;&#x5C45;&#x90FD;&#x627E;&#x51FA;&#x4F86;&#xFF0C;&#x4E26;&#x4E14;&#x9078;&#x64C7;&#x9577;&#x5EA6;&#x6700;&#x77ED;&#x8DEF;&#x5F91;&#x70BA;&#x65B0;&#x7684;&#x89E3;&#xFF0C;&#x56E0;&#x70BA;&#x627E;&#x9130;&#x5C45;&#x7684;&#x65B9;&#x6CD5;&#x662F;&#x9078;&#x5169;&#x500B;&#x57CE;&#x5E02;&#x4E26;&#x4E14;&#x7FFB;&#x8F49;&#xFF0C;&#x6240;&#x4EE5;&#x5C0D;&#x65BC;&#x4E00;&#x689D;&#x8DEF;&#x5F91;&#x800C;&#x8A00;&#xFF0C;&#x6709; n * ( n - 1 ) / 2 &#x7A2E;&#x9130;&#x5C45;&#x8DEF;&#x5F91;&#xFF0C;&#x4EE5;&#x4E00;&#x500B; 5 &#x500B;&#x57CE;&#x5E02;&#x7684; tsp &#x554F;&#x984C;&#x8209;&#x4F8B;&#xFF0C;&#x4E0B;&#x5716;&#x662F;&#x4ED6;&#x7684;&#x6240;&#x6709;&#x9130;&#x5C45;&#x3002;&#x6240;&#x6709;&#x9130;&#x5C45;&#x7684;&#x8DEF;&#x5F91;&#x9577;&#x5EA6;&#x662F;&#x53EF;&#x4EE5;&#x55AE;&#x7368;&#x8A08;&#x7B97;&#x7684;&#xFF0C;&#x56E0;&#x70BA;&#x6C92;&#x6709;&#x8A08;&#x7B97;&#x4E0A;&#x7684;&#x76F8;&#x4F9D;&#x6027;&#xFF0C;&#x6240;&#x4EE5;&#x5F88;&#x9069;&#x5408;&#x505A;&#x5E73;&#x884C;&#x3002; thread 0 thread 1 thread 0 thread 1 (0 , 1) (0 , 2) (1 , 2) (0 , 3) (1 , 3) (2 , 3) (0 , 4) (1 , 4) (2 , 4) (3 , 4) &#x5728;&#x8A2D;&#x8A08;&#x5E73;&#x884C;&#x7A0B;&#x5F0F;&#x7684;&#x6642;&#x5019;&#x6211;&#x5011;&#x9700;&#x8981;&#x5206;&#x914D;&#x6BCF;&#x500B; thread / child process &#x8981;&#x505A;&#x4EC0;&#x9EBC;&#xFF0C;&#x56E0;&#x70BA;&#x5728;&#x6240;&#x6709;thread / child process &#x90FD;&#x5B8C;&#x6210;&#x81EA;&#x5DF1;&#x7684;&#x5DE5;&#x4F5C;&#x4E4B;&#x5F8C;&#xFF0C;&#x624D;&#x80FD;&#x958B;&#x59CB;&#x9032;&#x884C;&#x4E0B;&#x4E00;&#x8F2A;&#x7684;&#x8A08;&#x7B97;&#xFF0C;&#x56E0;&#x6B64;&#x9700;&#x8981;&#x5E73;&#x5747;&#x7684;&#x5206;&#x914D;&#x5DE5;&#x4F5C;&#x91CF;&#x3002;&#x4EE5; 2 &#x500B; thread / child process &#x70BA;&#x4F8B;&#xFF0C;&#x6211;&#x4F7F;&#x7528;&#x4E0A;&#x5716;&#x7684;&#x65B9;&#x6CD5;&#x5206;&#x914D;&#x5DE5;&#x4F5C;&#xFF0C;(x,y) &#x6307;&#x7684;&#x662F;&#x7FFB;&#x8F49;&#x57CE;&#x5E02; x &#x5230;&#x57CE;&#x5E02; y &#x7684;&#x8DEF;&#x5F91;&#xFF0C;&#x7FFB;&#x8F49;&#x6642;&#x9078;&#x64C7;&#x7684;&#x7B2C;&#x4E00;&#x500B;&#x57CE;&#x5E02;&#x662F; city 0 &#x7684;&#x5C31;&#x8B93; thread 0 / child process 0 &#x8CA0;&#x8CAC;&#xFF0C;&#x6240;&#x6709;&#x7FFB;&#x8F49;&#x6642;&#x9078;&#x64C7;&#x7684;&#x7B2C;&#x4E00;&#x500B;&#x57CE;&#x5E02;&#x662F; city 1 &#x7684;&#x5C31;&#x8B93; thread 1 / child process 1 &#x8CA0;&#x8CAC;&#xFF0C;&#x4EE5;&#x6B64;&#x985E;&#x63A8;&#xFF0C;&#x4EE5;&#x6B64;&#x8868;&#x683C;&#x8209;&#x4F8B;&#xFF0C;&#x7B2C;&#x4E00;&#x6B04;&#x548C;&#x7B2C;&#x4E09;&#x6B04;&#x90E8;&#x4EFD;&#x7531; thread 0 / child process 0 &#x8CA0;&#x8CAC;&#xFF0C;&#x7B2C;&#x4E8C;&#x6B04;&#x548C;&#x7B2C;&#x56DB;&#x6B04;&#x7531; thread 1 / child process 1 &#x8CA0;&#x8CAC;&#x3002; Implementation Algorithm 1234567initialize the routewhile termination condition not meet 2-opt() evaluate neighbor routes select the best neighbor route as new routeend while &#x6211;&#x521D;&#x59CB;&#x5316;&#x8DEF;&#x5F91;&#x8B93;&#x70BA;&#x57CE;&#x5E02; &quot;1 2 3 4 . . . &quot;&#xFF0C;&#x4E2D;&#x6B62;&#x689D;&#x4EF6;&#x662F;&#x7576;&#x65B0;&#x7684;&#x6700;&#x77ED;&#x8DEF;&#x5F91;&#x548C;&#x820A;&#x7684;&#x6700;&#x77ED;&#x8DEF;&#x5F91;&#xFF0C;&#x53EA;&#x5DEE;&#x8DDD;&#x4E0D;&#x5230; 0.1 &#x7684;&#x6642;&#x5019;&#x5373;&#x4E2D;&#x6B62;&#x3002; &#x5728; while &#x8FF4;&#x5708;&#x88E1;&#xFF0C;&#x5148;&#x9032;&#x884C; 2-opt&#xFF0C;&#x5B8C;&#x6210; 2-opt &#x4E4B;&#x5F8C;&#xFF0C;&#x6BCF;&#x500B; thread / child process &#x6703;&#x56DE;&#x50B3;&#x81EA;&#x5DF1;&#x8CA0;&#x8CAC;&#x7684;&#x5DE5;&#x4F5C;&#x5340;&#x57DF;&#x88E1;&#x9762;&#x6700;&#x77ED;&#x7684;&#x8DEF;&#x5F91;&#xFF0C;&#x5927;&#x5BB6;&#x90FD;&#x5DE5;&#x4F5C;&#x5B8C;&#x6210;&#x4E4B;&#x5F8C;&#xFF0C;&#x6BD4;&#x8F03;&#x6240;&#x6709;&#x4EBA;&#x6240;&#x5F97;&#x5230;&#x7684;&#x8DEF;&#x5F91;&#xFF0C;&#x9078;&#x51FA;&#x6700;&#x77ED;&#x7684;&#x8DEF;&#x5F91;&#xFF0C;&#x5C31;&#x662F;&#x9019;&#x500B; iteration &#x7684;&#x7D50;&#x679C;&#xFF0C;&#x9019;&#x500B;&#x8DEF;&#x5F91;&#x5C31;&#x662F;&#x65B0;&#x7684;&#x8DEF;&#x5F91;&#xFF0C;&#x5927;&#x5BB6;&#x518D;&#x4EE5;&#x9019;&#x500B;&#x8DEF;&#x5F91;&#x9032;&#x884C;&#x4E0B;&#x4E00;&#x8F2A;&#x7684;&#x8A08;&#x7B97;&#x3002; &#x6211;&#x5BE6;&#x505A;&#x4E86; sequential / pthread / fork &#x4E09;&#x500B;&#x7248;&#x672C;&#xFF0C;&#x7531;&#x65BC; pthread library &#x5DF2;&#x7D93;&#x5F88;&#x5B8C;&#x5584;&#xFF0C;&#x56E0;&#x6B64;&#x6211;&#x6703;&#x7565;&#x904E; pthread&#xFF0C;&#x53EA;&#x4ECB;&#x7D39;&#x6211;&#x5728; fork &#x7248;&#x672C;&#x4E2D;&#x4F7F;&#x7528;&#x7684;&#x540C;&#x6B65;&#x6A5F;&#x5236;&#x3002; Fork &#x4F7F;&#x7528; fork &#x53EF;&#x4EE5;&#x7528; pipe &#x6216;&#x662F; shared memory &#x9032;&#x884C;&#x540C;&#x6B65;&#xFF0C;&#x6211;&#x9078;&#x64C7;&#x7528; shared memory&#xFF0C;&#x56E0;&#x70BA;&#x6BCF;&#x500B; child process &#x9700;&#x8981;&#x7684;&#x8CC7;&#x8A0A;&#x4E0D;&#x5C11;&#xFF0C;&#x4F8B;&#x5982;&#x5169;&#x5169;&#x57CE;&#x5E02;&#x7684;&#x8DDD;&#x96E2;&#x77E9;&#x9663;&#xFF0C;&#x5982;&#x679C;&#x57CE;&#x5E02;&#x6578;&#x91CF;&#x5F88;&#x591A;&#x7684;&#x8A71;&#xFF0C;&#x9019;&#x500B;&#x77E9;&#x9663;&#x6703;&#x975E;&#x5E38;&#x5927;&#xFF0C;&#x7528; pipe &#x7684;&#x65B9;&#x5F0F;&#x6211;&#x5011;&#x9700;&#x8981;&#x628A;&#x6240;&#x6709;&#x8CC7;&#x8A0A;&#x50B3;&#x7D66;&#x6BCF;&#x4E00;&#x500B; child process&#xFF0C;&#x5F88;&#x82B1;&#x6642;&#x9593;&#xFF0C;&#x56E0;&#x6B64;&#x6211;&#x9078;&#x64C7;&#x4F7F;&#x7528; shared memory&#x3002; &#x6211;&#x4F7F;&#x7528;&#x5169;&#x500B; array&#xFF0C;finish &#x548C; passGranted&#xFF0C;&#x505A;&#x540C;&#x6B65;&#x7684;&#x63A7;&#x5236;&#x3002;&#x7576;&#x4E00;&#x500B; child process &#x5B8C;&#x6210;&#x88AB;&#x4EA4;&#x5F85;&#x7684;&#x4EFB;&#x52D9;&#xFF0C;&#x5C31;&#x53EF;&#x4EE5;&#x53BB;&#x4FEE;&#x6539;&#x81EA;&#x5DF1;&#x7684;finsh&#x6B04;&#x4F4D;&#xFF0C;&#x5C07;&#x5176;&#x6A19;&#x8A18;&#x70BA; 1&#x3002;&#x800C;&#x7576; parent process &#x767C;&#x73FE;&#x6240;&#x6709; child process &#x7684; finish &#x6B04;&#x4F4D;&#x90FD;&#x6A19;&#x8A18;&#x70BA; 1&#xFF0C;&#x53EF;&#x4EE5;&#x958B;&#x59CB;&#x9032;&#x884C;&#x6BD4;&#x8F03;&#x54EA;&#x4E00;&#x500B; child process &#x627E;&#x51FA;&#x4F86;&#x7684;&#x8DEF;&#x5F91;&#x8DDD;&#x96E2;&#x6700;&#x77ED;&#xFF0C;parent process &#x6703;&#x5C07;&#x6B64;&#x6700;&#x77ED;&#x8DEF;&#x5F91;&#x66F4;&#x65B0;&#x7D66;&#x6240;&#x6709;&#x7684; child process&#xFF0C;&#x63A5;&#x8457; parent process &#x5C31;&#x53EF;&#x4EE5;&#x5C07;&#x6240;&#x6709; child process &#x7684; passGranted &#x6B04;&#x4F4D;&#x6A19;&#x8A18;&#x70BA; 1&#xFF0C;&#x901A;&#x77E5; child process &#x53EF;&#x4EE5;&#x958B;&#x59CB;&#x4E0B;&#x4E00;&#x500B; iterration &#x7684;&#x8A08;&#x7B97;&#x3002; 1234567/* shared memory */static int *finish;static int *passGranted;finish = (int *)mmap(NULL, childNum * sizeof(int), PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_SHARED, -1, 0);passGranted = (int *)mmap(NULL, childNum * sizeof(int), PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_SHARED, -1, 0); Parent Process &#x7576; finish &#x6B04;&#x4F4D;&#x9084;&#x6C92;&#x6709;&#x5168;&#x90E8;&#x6A19;&#x8A18;&#x70BA; 1&#xFF0C;&#x4E5F;&#x5C31;&#x662F;&#x9084;&#x6709; child process &#x6C92;&#x6709;&#x5B8C;&#x6210;&#x5DE5;&#x4F5C;&#x7684;&#x6642;&#x5019;&#xFF0C;parent process &#x5C31;&#x6703;&#x88AB;&#x5361;&#x5728; while loop &#x88E1;&#x9762;&#x3002;&#x812B;&#x96E2; while loop &#x4E4B;&#x5F8C; parent process &#x624D;&#x80FD;&#x958B;&#x59CB;&#x9032;&#x4ED6;&#x7684;&#x5DE5;&#x4F5C;&#x3002;&#x7576; parent process &#x628A;&#x81EA;&#x5DF1;&#x7684;&#x5DE5;&#x4F5C;&#x505A;&#x5B8C;&#x5F8C;&#xFF0C;&#x624D;&#x5141;&#x8A31; child process&#x9032;&#x884C;&#x4E0B;&#x4E00;&#x8F2A;&#x7684;&#x8A08;&#x7B97;&#x3002; 123456/* wait until all child process finish */while(!canPass(finish)) { /* do nothing */}... 12345678/* parent process working */.../* reset synchronize variable */for(int j = 0; j &lt; childNum; j++) { finish[j] = 0; pass_granted[j] = 1;} 12345678int canPass(int childNum, int *finish) { int sum = 0; for(int i = 0; i &lt; childNum; i++) { if(finish[i] &gt; 0) sum ++; } if(sum == childNum) return 1; else return 0;} Child Process &#x7576; child process &#x6C92;&#x6709;&#x5F97;&#x5230;&#x5141;&#x8A31;&#xFF0C;&#x5373; passGranted &#x6B04;&#x4F4D;&#x70BA; 0 &#x6642;&#xFF0C;&#x6703;&#x88AB;&#x5361;&#x5728; while loop &#x88E1;&#x9762;&#xFF0C;&#x7B49;&#x5F85; parent process &#x7D66;&#x4E88;&#x901A;&#x904E;&#x7684;&#x5141;&#x8A31;&#x3002; 123456789101112/* child process working */...finish[id] = 1;/* wait until all child process finish */while(!passGranted[id]) { /* do nothing */}/* reset synchronize variable */passGranted[id] = 0; Experimental Result &#x56E0;&#x70BA;&#x6211;&#x4F7F;&#x7528;&#x8CAA;&#x5A6A;&#x6F14;&#x7B97;&#x6CD5;&#xFF0C;&#x6240;&#x4EE5;&#x4E0D;&#x8AD6;&#x662F; sequential / pthread / fork&#xFF0C;&#x627E;&#x8DEF;&#x5F91;&#x7684;&#x904E;&#x7A0B;&#x90FD;&#x662F;&#x4E00;&#x6A21;&#x4E00;&#x6A23;&#x7684;&#xFF0C;&#x6700;&#x5F8C;&#x627E;&#x5230;&#x7684;&#x7D50;&#x679C;&#x4E5F;&#x662F;&#x4E00;&#x6A21;&#x4E00;&#x6A23;&#x7684;&#x3002;&#x6211;&#x5F9E; tsplib &#x53D6;&#x5F97;&#x6E2C;&#x8CC7;&#xFF0C;tsplib&#x63D0;&#x4F9B;&#x591A;&#x500B; tsp &#x6E2C;&#x8CC7;&#x4EE5;&#x53CA;&#x8DDD;&#x96E2;&#x6700;&#x4F73;&#x89E3;&#xFF0C;&#x6211;&#x9078;&#x64C7;&#x4E86;&#x4E09;&#x500B;&#x5927;&#x5C0F;&#x7684;&#x6E2C;&#x8CC7;&#xFF0C;&#x5206;&#x5225;&#x662F; 1002 / 3795 / 7397 &#x500B;&#x57CE;&#x5E02;&#xFF0C;&#x62EC;&#x865F;&#x5167;&#x662F;&#x8A72;&#x6E2C;&#x8CC7;&#x7684;&#x6700;&#x4F73;&#x89E3;&#xFF0C;&#x6240;&#x6709;&#x7684;&#x6E2C;&#x8A66;&#x7D50;&#x679C;&#x90FD;&#x662F; 5 &#x6B21;&#x6E2C;&#x8A66;&#x7684;&#x5E73;&#x5747;&#xFF0C;&#x5728; pthread &#x548C; fork &#x7684;&#x6E2C;&#x8A66;&#xFF0C;&#x6211;&#x4F7F;&#x7528;&#x4E86; 2 &#x500B; thread &#x548C; 2 &#x500B; child process&#x3002; pr1002 pr1002 generation distance time (s) speedup sequential 122 28079 (259045) 0.55 1.00 pthread (2) 122 28079 (259045) 0.45 1.22 fork (2) 122 28079 (259045) 0.38 1.45 fl3795 fl3795 generation distance time (s) speedup sequential 2251 34049 (28772) 294.61 1.00 pthread (2) 2251 34049 (28772) 149.16 1.98 fork (2) 2251 34049(28772) 160.16 1.84 pla7397 pla7397 generation distance time (s) speedup sequential 2243 25018352 (23260728) 1191.42 1.00 pthread (2) 2243 25018352 (23260728) 586.33 2.03 fork (2) 2243 34049(23260728) 705.31 1.69 Speed Up Route &#x4E0B;&#x5716;&#x662F;&#x6E2C;&#x8CC7; pr1002 &#x521D;&#x59CB;&#x5316;&#x6642;&#x7684;&#x8DEF;&#x5F91;&#x5716;&#xFF0C;&#x4EE5;&#x53CA;&#x5B8C;&#x6210;&#x6700;&#x4F73;&#x5316;&#x4E4B;&#x5F8C;&#x7684;&#x8DEF;&#x5F91;&#x5716;&#xFF0C;&#x53EF;&#x4EE5;&#x770B;&#x5230;&#x7D93;&#x904E;&#x6700;&#x4F73;&#x5316;&#x7684;&#x8DEF;&#x5F91;&#xFF0C;&#x78BA;&#x5BE6;&#x5F97;&#x5230;&#x66F4;&#x597D;&#x7684;&#x8DEF;&#x5F91;&#x3002; Conclusion &#x5EFA;&#x7ACB;&#x4E00;&#x500B;&#x65B0;&#x7684; process &#x6240;&#x9700;&#x8981;&#x7684;&#x8CC7;&#x6E90;&#x548C;&#x6642;&#x9593;&#x90FD;&#x8F03;&#x591A;&#xFF0C;&#x56E0;&#x6B64;&#x6211;&#x9810;&#x671F; fork &#x7684;&#x6548;&#x80FD;&#x6703;&#x6BD4;&#x8F03;&#x5DEE;&#xFF0C;&#x5BE6;&#x9A57;&#x7D50;&#x679C;&#x4E5F;&#x5448;&#x73FE; pthread &#x6709;&#x8F03;&#x597D;&#x7684;&#x6548;&#x80FD;&#x3002;&#x7576;&#x6E2C;&#x8CC7;&#x592A;&#x5C0F;&#x6642;&#x5EFA;&#x7ACB;&#x5E73;&#x884C;&#x7684; overhead &#x6703;&#x4F7F;&#x5F97;&#x5E73;&#x884C;&#x7684;&#x6548;&#x80FD;&#x964D;&#x4F4E;&#xFF0C;&#x6700;&#x5C0F;&#x7684;&#x6E2C;&#x8CC7; pr1002 &#x78BA;&#x5BE6;&#x6548;&#x80FD;&#x4E0D;&#x4F73;&#xFF0C;&#x4E2D;&#x6E2C;&#x8CC7; fl3795 &#x6548;&#x80FD;&#x660E;&#x986F;&#x8F03;&#x4F73;&#x3002; &#x5927;&#x6E2C;&#x8CC7; pla7394 &#x5728; pthread &#x7684; speedup &#x8D85;&#x904E; 2&#xFF0C;&#x7406;&#x8AD6;&#x4E0A; speedup &#x4E0D;&#x61C9;&#x8A72;&#x8D85;&#x904E; 2&#xFF0C;&#x56E0;&#x70BA;&#x6C92;&#x6709;&#x5DEE;&#x5F88;&#x591A;&#xFF0C;&#x6211;&#x5224;&#x65B7;&#x9019;&#x662F;&#x7D71;&#x8A08;&#x4E0A;&#x7684;&#x8AA4;&#x5DEE;&#x3002; &#x9664;&#x4E86;&#x5EFA;&#x7ACB; thread / process &#x7684; overhead &#x4E4B;&#x5916;&#xFF0C;&#x6211;&#x4E0D;&#x78BA;&#x5B9A;&#x4F5C;&#x696D;&#x7CFB;&#x7D71;&#x5C0D;&#x65BC; thread &#x548C; process &#x7684;&#x6392;&#x7A0B;&#x512A;&#x5148;&#x6B0A;&#x662F;&#x5426;&#x76F8;&#x540C; (&#x6216;&#x8A31; process &#x7684;&#x512A;&#x5148;&#x6B0A;&#x6703;&#x9AD8;&#x65BC; thread&#xFF0C;&#x53EF;&#x4EE5;&#x62FF;&#x5230;&#x6BD4;&#x8F03;&#x9AD8;&#x7684;&#x512A;&#x5148;&#x6B0A;)&#xFF0C;&#x4EE5;&#x53CA;&#x9019;&#x5169;&#x8005;&#x5E95;&#x5C64;&#x7684;&#x5BE6;&#x505A;&#x5DEE;&#x7570;&#xFF0C;&#x96D6;&#x7136;&#x5728;&#x5BE6;&#x9A57;&#x7D50;&#x679C;&#x4E2D;&#x770B;&#x4E0D;&#x592A;&#x51FA;&#x4F86;&#x9019;&#x500B;&#x56E0;&#x7D20;&#x662F;&#x5426;&#x6709;&#x4F5C;&#x7528;&#xFF0C;&#x4F46;&#x9019;&#x4E5F;&#x6703;&#x662F;&#x5F71;&#x97FF; pthread &#x548C; fork &#x6548;&#x80FD;&#x7684;&#x4E00;&#x500B;&#x56E0;&#x7D20;&#x3002; Command Compile 123&gt; gcc tsp_seq.c -o tsp_seq -lm&gt; g++ fork.cc -o fork -lm&gt; gcc tsp_pthread.c -o tsp_pthread -lm -lpthread Execute 123&gt; time ./tsp_seq &gt; 7397_seq.txt&gt; time ./fork &gt; fork_7397.txt&gt; time ./tsp_pthread &gt; 7397_pthread.txt Reference [1] &#x65C5;&#x884C;&#x63A8;&#x92B7;&#x54E1;&#x554F;&#x984C; https://zh.wikipedia.org/wiki/&#x65C5;&#x884C;&#x63A8;&#x9500;&#x5458;&#x95EE;&#x9898; [2] TSP Test Data http://www.math.uwaterloo.ca/tsp/data/index.html [3] 2-opt https://en.wikipedia.org/wiki/2-opt [4] TSPLIB http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/","categories":[],"tags":[]},{"title":"北科資工修課紀錄 - 碩一下","slug":"北科資工修課紀錄-碩一下","date":"2021-07-31T05:55:20.000Z","updated":"2021-08-15T17:35:28.383Z","comments":true,"path":"2021/07/31/北科資工修課紀錄-碩一下/","link":"","permalink":"http://example.com/2021/07/31/%E5%8C%97%E7%A7%91%E8%B3%87%E5%B7%A5%E4%BF%AE%E8%AA%B2%E7%B4%80%E9%8C%84-%E7%A2%A9%E4%B8%80%E4%B8%8B/","excerpt":"","text":"&#x78A9;&#x4E00;&#x4E0B; &#x56E0;&#x70BA;&#x7533;&#x8ACB;&#x63D0;&#x65E9;&#x5165;&#x5B78;&#xFF0C;&#x6240;&#x4EE5;&#x4E8C;&#x6708;&#x5C31;&#x5165;&#x5B78;&#x4E86;&#xFF0C;&#x6211;&#x5728;&#x5317;&#x79D1;&#x7684;&#x7B2C;&#x4E00;&#x500B;&#x5B78;&#x671F;&#x5C31;&#x662F;&#x4E0B;&#x5B78;&#x671F;&#xFF0C;&#x5317;&#x79D1;&#x8CC7;&#x5DE5;&#x898F;&#x5B9A;&#x975E;&#x672C;&#x79D1;&#x7684;&#x78A9;&#x58EB;&#x73ED;&#x5B78;&#x751F;&#x5FC5;&#x9700;&#x88DC;&#x4FEE;&#x5927;&#x5B78;&#x90E8;&#x7684;&#x8AB2;&#x7A0B;&#xFF0C;&#x6240;&#x4EE5;&#x6211;&#x4E5F;&#x6703;&#x4FEE;&#x4E00;&#x4E9B;&#x5927;&#x5B78;&#x90E8;&#x7684;&#x8AB2;&#x3002; &#x5927;&#x5B78;&#x90E8;&#x8AB2;&#x7A0B; &#x8A08;&#x7B97;&#x6A5F;&#x7D44;&#x7E54; - &#x9673;&#x5F65;&#x9716; &#x8001;&#x5E2B;&#x6559;&#x7684;&#x5F88;&#x597D;&#x5F88;&#x4ED4;&#x7D30;&#xFF0C;&#x5C0D;&#x8AB2;&#x7A0B;&#x7684;&#x638C;&#x63E1;&#x5EA6;&#x5F88;&#x9AD8;&#xFF0C;&#x61C9;&#x8A72;&#x5DF2;&#x7D93;&#x6559;&#x9019;&#x9580;&#x8AB2;&#x5F88;&#x591A;&#x5E74;&#x4E86;&#xFF0C;&#x5C0D;&#x540C;&#x5B78;&#x7684;&#x554F;&#x984C;&#x90FD;&#x56DE;&#x7B54;&#x5F97;&#x5F88;&#x5B8C;&#x6574;&#x3002;&#x9019;&#x9580;&#x8AB2;&#x662F;&#x8CC7;&#x5DE5;&#x5927;&#x4E00;&#x7684;&#x8AB2;&#xFF0C;&#x4FEE;&#x9019;&#x9580;&#x8AB2;&#x4E4B;&#x524D;&#x901A;&#x5E38;&#x61C9;&#x8A72;&#x6703;&#x5148;&#x4FEE;&#x6578;&#x4F4D;&#x96FB;&#x8DEF;&#xFF0C;&#x4F46;&#x6211;&#x6C92;&#x4FEE;&#x904E;&#x5C31;&#x76F4;&#x63A5;&#x4E0A;&#x4E86;&#xFF0C;&#x671F;&#x4E2D;&#x8003;&#x524D;&#x8B1B;&#x95DC;&#x65BC; MIPS &#x6307;&#x4EE4;&#x7684;&#x9084;&#x6C92;&#x4EC0;&#x9EBC;&#x554F;&#x984C;&#xFF0C;&#x671F;&#x4E2D;&#x8003;&#x5F8C;&#x8B1B; CPU &#x8A2D;&#x8A08;&#x7684;&#x5C31;&#x89BA;&#x5F97;&#x6709;&#x9EDE;&#x96E3;&#x4EE5;&#x7406;&#x89E3;&#xFF0C;&#x9700;&#x8981;&#x82B1;&#x6BD4;&#x8F03;&#x591A;&#x6642;&#x9593;&#x53BB;&#x7406;&#x89E3;&#x3002;&#x6574;&#x500B;&#x5B78;&#x671F;&#x6709;&#x516D;&#x4EFD;&#x4F5C;&#x696D;&#xFF0C;&#x90FD;&#x662F;&#x624B;&#x5BEB;&#x4F5C;&#x696D;&#xFF0C;&#x671F;&#x4E2D;&#x671F;&#x672B;&#x5E7E;&#x4E4E;&#x90FD;&#x662F;&#x4F5C;&#x696D;&#x7684;&#x984C;&#x578B;&#xFF0C;&#x7D66;&#x5206;&#x5F88;&#x751C;&#xFF0C;&#x4E5F;&#x5B78;&#x5230;&#x5F88;&#x591A;&#xFF0C;&#x5C24;&#x5176;&#x662F;&#x6307;&#x4EE4;&#x96C6;&#x7684;&#x90E8;&#x4EFD;&#x5F88;&#x5BE6;&#x7528;&#x3002; &#x8A08;&#x7B97;&#x6A5F;&#x6F14;&#x7B97;&#x6CD5; - &#x856D;&#x69AE;&#x4FEE; &#x6559;&#x7684;&#x975E;&#x5E38;&#x7C21;&#x55AE;&#xFF0C;&#x8AB2;&#x975E;&#x5E38;&#x6DBC;&#xFF0C;&#x4F5C;&#x696D;&#x5F88;&#x5C11;&#xFF0C;&#x8003;&#x8A66;&#x7C21;&#x55AE;&#xFF0C;&#x7D66;&#x5206;&#x5F88;&#x751C;&#x3002;&#x6211;&#x76F8;&#x4FE1;&#x6240;&#x6709;&#x4EBA;&#x5728;&#x9078;&#x8AB2;&#x7684;&#x6642;&#x5019;&#x4E0D;&#x53EF;&#x80FD;&#x5168;&#x90E8;&#x90FD;&#x9078;&#x786C;&#x8AB2;&#xFF0C;&#x6DBC;&#x8AB2;&#x7D55;&#x5C0D;&#x6709;&#x5B58;&#x5728;&#x7684;&#x5FC5;&#x8981;&#xFF0C;&#x4F46;&#x662F;&#x6F14;&#x7B97;&#x6CD5;&#x4F5C;&#x70BA;&#x8CC7;&#x5DE5;&#x6700;&#x6838;&#x5FC3;&#x7684;&#x8AB2;&#x7A0B;&#x4E4B;&#x4E00;&#xFF0C;&#x7ADF;&#x7136;&#x662F;&#x6DBC;&#x8AB2;&#x771F;&#x7684;&#x5F88;&#x554F;&#x865F;&#x3002; &#x7814;&#x7A76;&#x6240;&#x8AB2;&#x7A0B; &#x4F5C;&#x696D;&#x7CFB;&#x7D71; - &#x738B;&#x6B63;&#x8C6A; &#x82F1;&#x6587;&#x6388;&#x8AB2;&#xFF0C;&#x4E0A;&#x8AB2;&#x5167;&#x5BB9;&#x57FA;&#x672C;&#x4E0A;&#x91CD;&#x8907;&#x5927;&#x5B78;&#x90E8;&#x7684;&#x4F5C;&#x696D;&#x7CFB;&#x7D71;&#xFF0C;&#x518D;&#x591A;&#x52A0;&#x4E00;&#x4E9B;&#x5206;&#x6563;&#x5F0F;&#x7CFB;&#x7D71;&#x7684;&#x5167;&#x5BB9;&#xFF0C;&#x8AB2;&#x5F88;&#x6DBC;&#xFF0C;&#x4F5C;&#x696D;&#x4E0D;&#x96E3;&#xFF0C;&#x671F;&#x672B;&#x8981;&#x5831;&#x544A;&#x8AD6;&#x6587;&#x6216;&#x505A;&#x5C08;&#x984C;&#xFF0C;&#x8001;&#x5E2B;&#x7684;&#x7D50;&#x5DF4;&#x6709;&#x9EDE;&#x56B4;&#x91CD;&#xFF0C;&#x6211;&#x662F;&#x56E0;&#x70BA;&#x6C92;&#x6709;&#x4FEE;&#x904E;&#x5927;&#x5B78;&#x90E8;&#x7684;&#x4F5C;&#x696D;&#x7CFB;&#x7D71;&#x6240;&#x4EE5;&#x4F86;&#x4FEE;&#x7684;&#x3002;&#x6211;&#x4FEE;&#x4E4B;&#x524D;&#x6015;&#x6211;&#x6C92;&#x4FEE;&#x904E;&#x4F5C;&#x696D;&#x7CFB;&#x7D71;&#x6703;&#x8DDF;&#x4E0D;&#x4E0A;&#xFF0C;&#x6240;&#x4EE5;&#x770B;&#x4E86;&#x6E05;&#x5927;&#x5468;&#x5FD7;&#x9060;&#x7684;&#x4F5C;&#x696D;&#x7CFB;&#x7D71;&#x958B;&#x653E;&#x5F0F;&#x8AB2;&#x7A0B;&#xFF0C;&#x7D50;&#x8AD6;&#x662F;&#x5468;&#x5FD7;&#x9060;&#x7684;&#x8AB2;&#x4E0A;&#x7684;&#x6BD4;&#x8F03;&#x597D;&#x3002; &#x6A94;&#x6848;&#x8207;&#x5132;&#x5B58;&#x7CFB;&#x7D71; - &#x9673;&#x78A9;&#x6F22; &#x82F1;&#x6587;&#x6388;&#x8AB2;&#xFF0C;&#x8001;&#x5E2B;&#x662F;&#x65B0;&#x4F86;&#x5317;&#x79D1;&#x7684;&#x8001;&#x5E2B;&#xFF0C;&#x96D6;&#x7136;&#x4E0A;&#x8AB2;&#x8A8D;&#x771F;&#x4F46;&#x53EF;&#x80FD;&#x56E0;&#x70BA;&#x624D;&#x525B;&#x958B;&#x59CB;&#x6559;&#x66F8;&#xFF0C;&#x89BA;&#x5F97;&#x9084;&#x6709;&#x9032;&#x6B65;&#x7A7A;&#x9593;&#xFF0C;&#x524D;&#x534A;&#x5B78;&#x671F;&#x8B1B;&#x6A94;&#x6848;&#x7CFB;&#x7D71;&#xFF0C;&#x5F8C;&#x534A;&#x5B78;&#x671F;&#x8B1B;&#x4F5C;&#x696D;&#x7CFB;&#x7D71;&#xFF0C;&#x4F5C;&#x696D;&#x662F; NachOS &#x5BE6;&#x4F5C;&#xFF0C;&#x4ED6;&#x7684;&#x7684;&#x4F5C;&#x696D;&#x57FA;&#x672C;&#x4E0A;&#x5C31;&#x662F;&#x6E05;&#x5927;&#x5468;&#x5FD7;&#x9060;&#x4F5C;&#x696D;&#x7CFB;&#x7D71;&#x7684;&#x4F5C;&#x696D;&#x4E00;&#x548C;&#x4F5C;&#x696D;&#x56DB;&#xFF0C;&#x672C;&#x4F86;&#x9084;&#x6709;&#x53E6;&#x4E00;&#x4EFD;&#x4F5C;&#x696D;&#xFF0C;&#x4F46;&#x56E0;&#x70BA;&#x5927;&#x5BB6;&#x5728;&#x5BEB; NachOS &#x7684;&#x6642;&#x5019;&#x4EA4;&#x4F5C;&#x696D;&#x7387;&#x4E0D;&#x662F;&#x5F88;&#x9AD8;&#xFF0C;&#x8001;&#x5E2B;&#x5C31;&#x628A;&#x4F5C;&#x696D;&#x671F;&#x9650;&#x5EF6;&#x9577;&#xFF0C;&#x628A;&#x53E6;&#x4E00;&#x4EFD;&#x4F5C;&#x696D;&#x53D6;&#x6D88;&#x3002;&#x6211;&#x81EA;&#x5DF1;&#x662F;&#x4E0D;&#x592A;&#x559C;&#x6B61;&#x4E0A;&#x82F1;&#x6587;&#x6388;&#x8AB2;&#x7684;&#x8AB2;&#xFF0C;&#x4E0D;&#x904E;&#x6211;&#x9078;&#x8AB2;&#x662F;&#x770B;&#x8AB2;&#x7684;&#x5167;&#x5BB9;&#xFF0C;&#x82F1;&#x6587;&#x6388;&#x8AB2;&#x4E5F;&#x4E0D;&#x6392;&#x65A5;&#x3002;&#x6211;&#x89BA;&#x5F97;&#x8001;&#x5E2B;&#x5F88;&#x8A8D;&#x771F;&#x4F5C;&#x696D;&#x5F88;&#x6709;&#x8DA3;&#xFF0C;&#x5982;&#x679C;&#x9019;&#x9580;&#x8AB2;&#x662F;&#x4E2D;&#x6587;&#x6388;&#x8AB2;&#x7684;&#x5C31;&#x597D;&#x4E86;&#x3002; &#x7D50;&#x8A9E; &#x904E;&#x53BB;&#x96D6;&#x7136;&#x4E5F;&#x5728;&#x6E05;&#x5927;&#x4FEE;&#x904E;&#x8CC7;&#x5DE5;&#x7CFB;&#x7684;&#x8AB2;&#xFF0C;&#x4F46;&#x4FEE;&#x7684;&#x5927;&#x90E8;&#x5206;&#x90FD;&#x9084;&#x662F;&#x6A5F;&#x68B0;&#x7CFB;&#x5FC5;&#x4FEE;&#xFF0C;&#x7B2C;&#x4E00;&#x6B21;&#x6240;&#x6709;&#x8AB2;&#x90FD;&#x662F;&#x4FEE;&#x8CC7;&#x5DE5;&#x7CFB;&#x7684;&#x8AB2;&#xFF0C;&#x89BA;&#x5F97;&#x548C;&#x4EE5;&#x524D;&#x5728;&#x6A5F;&#x68B0;&#x7CFB;&#x7684;&#x6642;&#x5019;&#x4E0D;&#x4E00;&#x6A23;&#xFF0C;&#x4E0D;&#x662F;&#x53EA;&#x60F3;&#x6E4A;&#x5B78;&#x5206;&#xFF0C;&#x662F;&#x771F;&#x7684;&#x5C0D;&#x8AB2;&#x7A0B;&#x611F;&#x8208;&#x8DA3;&#xFF0C;&#x6709;&#x6642;&#x5019;&#x5F8C;&#x6094;&#x6C92;&#x6709;&#x65E9;&#x9EDE;&#x8F49;&#x7CFB;&#xFF0C;&#x4F46;&#x904E;&#x53BB;&#x7684;&#x4E8B;&#x60C5;&#x662F;&#x4E0D;&#x80FD;&#x6539;&#x8B8A;&#x7684;&#x662F;&#x5427;&#xFF0C;&#x73FE;&#x5728;&#x9019;&#x6A23;&#x4E5F;&#x5F88;&#x597D;&#x3002;","categories":[],"tags":[]},{"title":"NachOS MP2 - Multi Programming","slug":"NachOS-MP2","date":"2021-07-18T13:44:55.000Z","updated":"2021-08-24T09:24:12.604Z","comments":true,"path":"2021/07/18/NachOS-MP2/","link":"","permalink":"http://example.com/2021/07/18/NachOS-MP2/","excerpt":"","text":"&#x9019;&#x662F;&#x6E05;&#x5927;&#x5468;&#x5FD7;&#x9060;&#x6559;&#x6388;&#x4F5C;&#x696D;&#x7CFB;&#x7D71;&#x7684;&#x4F5C;&#x696D;&#xFF0C;&#x6211;&#x5728;&#x7DB2;&#x8DEF;&#x4E0A;&#x627E;&#x5230;&#x9019;&#x4EFD;&#x4F5C;&#x696D;&#x7684;&#x76F8;&#x95DC;&#x8CC7;&#x6599;&#xFF0C;&#x6211;&#x4E26;&#x6C92;&#x6709;&#x4E0A;&#x904E;&#x9019;&#x9580;&#x8AB2;&#xFF0C;&#x9019;&#x53EA;&#x662F;&#x6211;&#x7684;&#x81EA;&#x5B78;&#x7DF4;&#x7FD2;&#xFF0C;&#x6211;&#x7121;&#x6CD5;&#x80AF;&#x5B9A;&#x6211;&#x7684;&#x5831;&#x544A;&#x548C;&#x5BE6;&#x4F5C;&#x7684;&#x6B63;&#x78BA;&#x6027;&#xFF0C;&#x6211;&#x7684;&#x5BE6;&#x4F5C;&#x5728;&#x9019;&#x88E1;&#xFF0C;&#x6211;&#x7684; shell script &#x5728;&#x9019;&#x88E1;&#x3002; Trace code Kernel::ExecAll()&#x200B; Starting from &#x201C;threads/kernel.cc&#x200B; Kernel::ExecAll()&#x200B;&#x201D; is called. 1. main threads/main.cc kernel &#x5BA3;&#x544A;&#x70BA;&#x5168;&#x57DF;&#x8B8A;&#x6578;&#xFF0C;&#x6574;&#x500B; NachOS file &#x90FD;&#x53EF;&#x4EE5;&#x5171;&#x4EAB;&#x3002; 1Kernel *kernel; /* global variable */ 1234567int main(int argc, char **argv){ kernel = new Kernel(argc, argv); kernel-&gt;Initialize(); ... kernel-&gt;ExecAll();} &#x7576;&#x6211;&#x5011;&#x5728;&#x547D;&#x4EE4;&#x5217;&#x4E0B;&#x6307;&#x4EE4; -e halt&#xFF0C;halt &#x5373;&#x662F;&#x6211;&#x5011;&#x60F3;&#x57F7;&#x884C;&#x7684;&#x53EF;&#x57F7;&#x884C;&#x6A94;&#x3002; 1234567891011/* threads/kernel.cc */Kernel::Kernel(int argc, char **argv){ for (int i = 1; i &lt; argc; i++) { ... else if (strcmp(argv[i], &quot;-e&quot;) == 0) { execfile[++execfileNum]= argv[++i]; cout &lt;&lt; execfile[execfileNum] &lt;&lt; &quot;\\n&quot;; } } 123456789/* threads/kernel.h */class Kernel {public: Thread *currentThread; /* the thread holding CPU */private: Thread* t[10]; /* 10 threads at most */ char* execfile[10]; /* executable file name */}; 1234567/* threads/kernel.cc */void Kernel::Initialize(){ currentThread = new Thread(&quot;main&quot;, threadNum++); currentThread-&gt;setStatus(RUNNING); } 2. Kernel::ExecAll threads/kernel.cc&#x200B; &#x628A;&#x6240;&#x6709;&#x53EF;&#x57F7;&#x884C;&#x6A94;&#x4E1F;&#x9032; Exec() &#x57F7;&#x884C;&#x3002; 1234567void Kernel::ExecAll(){ for (int i = 1; i &lt;= execfileNum; i++) { int a = Exec(execfile[i]); } currentThread-&gt;Finish();} 3. Kernel::Exec threads/kernel.cc&#x200B; &#x6BCF;&#x4E00;&#x500B;&#x53EF;&#x57F7;&#x884C;&#x6A94;&#x90FD;&#x9700;&#x8981; new &#x4E00;&#x500B;&#x65B0;&#x7684; thread &#x4F86;&#x57F7;&#x884C;&#x3002; 123456789int Kernel::Exec(char* name){ t[threadNum] = new Thread(name, threadNum); t[threadNum]-&gt;space = new AddrSpace(); t[threadNum]-&gt;Fork((VoidFunctionPtr)&amp;ForkExecute, (void*)t[threadNum]); threadNum++; return threadNum-1;} 4. Thread::Fork threads/thread.cc &#x5EFA;&#x7ACB; thread &#x57F7;&#x884C;&#x6240;&#x9700;&#x8981;&#x7684; stack&#xFF0C;&#x4E26;&#x628A; thread &#x4E1F;&#x9032; readyList &#x7B49;&#x5F85;&#x57F7;&#x884C;&#x3002; 123456789101112void Thread::Fork(VoidFunctionPtr func, void *arg){ Interrupt *interrupt = kernel-&gt;interrupt; Scheduler *scheduler = kernel-&gt;scheduler; IntStatus oldLevel; StackAllocate(func, arg); oldLevel = interrupt-&gt;SetLevel(IntOff); scheduler-&gt;ReadyToRun(this); (void) interrupt-&gt;SetLevel(oldLevel);} 5. Scheduler::ReadyToRun threads/scheduler.cc &#x5C07; thread &#x52A0;&#x5165; readyList&#xFF0C;&#x7576; scheduler &#x9700;&#x8981;&#x5B89;&#x6392; thread &#x4F86;&#x57F7;&#x884C;&#x7684;&#x6642;&#x5019;&#xFF0C;&#x5C31;&#x5F9E; readyList dequeue &#x4E00;&#x500B; thread &#x4F86;&#x57F7;&#x884C;&#x3002; 123456void Scheduler::ReadyToRun (Thread *thread){ ASSERT(kernel-&gt;interrupt-&gt;getLevel() == IntOff); thread-&gt;setStatus(READY); readyList-&gt;Append(thread);} 1234class Scheduler { Thread* FindNextToRun(); List&lt;Thread *&gt; *readyList; }; Thread::Sleep Starting from &#x201C;threads/thread.cc thread::Sleep&#x200B;&#x201D; is called. 1. Thread::Sleep threads/thread.cc &#x53EA;&#x6709; currentThread &#x53EF;&#x4EE5;&#x547C;&#x53EB; Sleep()&#xFF0C;currentThread &#x662F;&#x76EE;&#x524D;&#x6B63;&#x5728;&#x57F7;&#x884C;&#x7684; thread&#xFF0C;&#x7576;currentThread &#x5B8C;&#x6210;&#x4ED6;&#x7684;&#x5DE5;&#x4F5C;&#x6216;&#x662F;&#x5728;&#x7B49;&#x5F85; synchronization variable (Semaphore, Lock, or Condition)&#xFF0C;&#x6703;&#x9032;&#x5165; Sleep()&#x3002; &#x7576; currentThread &#x9032;&#x5165; Sleep()&#xFF0C;&#x5C31;&#x80FD;&#x5F9E; readyList &#x4E2D; dequeue &#x4E00;&#x500B; thread &#x6210;&#x70BA; currentThread&#xFF0C;&#x4F7F;&#x7528; CPU&#x3002;&#x6211;&#x5011;&#x5C07;&#x9032;&#x5165; Sleep() &#x7684; thread &#x7684; state &#x5B58;&#x8D77;&#x4F86;&#xFF0C;&#x4E26;&#x4E14;&#x9032;&#x884C; context switch &#x3002;&#x7576;&#x518D;&#x6B21;&#x8F2A;&#x5230;&#x5728; Sleep() &#x7684; thread &#x4F7F;&#x7528; CPU &#x6642;&#xFF0C;Run() &#x624D;&#x6703; return&#x3002; 123456789101112131415void Thread::Sleep (bool finishing){ Thread *nextThread; ASSERT(this == kernel-&gt;currentThread); ASSERT(kernel-&gt;interrupt-&gt;getLevel() == IntOff); status = BLOCKED; while ((nextThread = kernel-&gt;scheduler-&gt;FindNextToRun()) == NULL) { /* no one to run, wait for an interrupt */ kernel-&gt;interrupt-&gt;Idle(); } /* returns when it&apos;s time for us to run */ kernel-&gt;scheduler-&gt;Run(nextThread, finishing); } 2. Scheduler::Run threads/scheduler.cc 12345678910111213141516171819202122232425262728293031323334353637void Scheduler::Run (Thread *nextThread, bool finishing){ Thread *oldThread = kernel-&gt;currentThread; if (finishing) { /* mark that we need to delete current thread */ ASSERT(toBeDestroyed == NULL); toBeDestroyed = oldThread; } if (oldThread-&gt;space &#xFF01;= NULL) { /* save the user&apos;s state */ oldThread-&gt;SaveUserState(); oldThread-&gt;space-&gt;SaveState(); } oldThread-&gt;CheckOverflow(); /* switch to the next thread */ kernel-&gt;currentThread = nextThread; /* nextThread is now running */ nextThread-&gt;setStatus(RUNNING); /* This is a machine-dependent assembly language routine defined * in switch.s */ SWITCH(oldThread, nextThread); /* we&apos;re back, running oldThread */ /* check if thread we were running before this one has finished * and needs to be cleaned up */ CheckToBeDestroyed(); if (oldThread-&gt;space != NULL) { /* if there is an address space to restore, do it */ oldThread-&gt;RestoreUserState(); oldThread-&gt;space-&gt;RestoreState(); }} &#x547C;&#x53EB; SWITCH() &#x9032;&#x884C; context switch&#xFF0C;&#x5728; SWITCH() &#x5B8C;&#x6210;&#x4E4B;&#x5F8C;&#xFF0C;&#x4E26;&#x4E0D;&#x6703;&#x7E7C;&#x7E8C;&#x57F7;&#x884C; Run() &#x7684;&#x4E0B;&#x4E00;&#x884C;&#xFF0C;&#x56E0;&#x70BA;&#x63A7;&#x5236;&#x6B0A;&#x5DF2;&#x7D93;&#x50B3;&#x7D66; nextThread&#xFF0C;&#x4E0B;&#x4E00;&#x884C;&#x8981;&#x88AB;&#x57F7;&#x884C;&#x7684;&#x6307;&#x4EE4;&#x662F; nextThread &#x7684;&#x6307;&#x4EE4;&#xFF0C;&#x7576; CheckToBeDestroyed() &#x88AB;&#x57F7;&#x884C;&#xFF0C;&#x4EE3;&#x8868;&#x5DF2;&#x7D93;&#x53C8;&#x8F2A;&#x5230;&#x9019;&#x500B; thread &#x4F7F;&#x7528; CPU&#xFF0C;&#x9019;&#x4E2D;&#x9593;&#x53EF;&#x80FD;&#x5DF2;&#x7D93;&#x5728;&#x597D;&#x5E7E;&#x500B; thread &#x4E4B;&#x9593; context switch &#x597D;&#x5E7E;&#x6B21;&#x4E86;&#x3002; 1SWITCH(oldThread, nextThread); Machine::Run()&#x200B; Starting from &#x201C;machine/mipssim.cc Machine::Run()&#x200B;&#x201D; is called. 1. Machine::Run machine/mippsim.cc 12345678910void Machine::Run(){ /* storage for decoded instruction */ Instruction *instr = new Instruction; / kernel-&gt;interrupt-&gt;setStatus(UserMode); for (;;) { OneInstruction(instr); kernel-&gt;interrupt-&gt;OneTick();} 2. Machine::OneInstruction machine/mippsim.cc OneInstruction() &#x8B80;&#x53D6;&#x7576;&#x524D;&#x6307;&#x4EE4;&#xFF0C;&#x7D93;&#x904E; decode()&#xFF0C;&#x6211;&#x5011;&#x53EF;&#x4EE5;&#x5F97;&#x5230; rs / rt / rd / opCode&#xFF0C;&#x4F9D;&#x7167; opCode &#x6211;&#x5011;&#x5C0D; register[rs] &#x548C; register[rt] &#x9032;&#x884C;&#x5C0D;&#x61C9;&#x7684;&#x64CD;&#x4F5C;&#xFF0C;&#x4E26;&#x4E14;&#x5C07;&#x7D50;&#x679C;&#x5BEB;&#x5165; register[rd]&#x3002; 123456789101112131415161718192021222324252627void Machine::OneInstruction(Instruction *instr){ int raw; /* Fetch instruction */ if (!ReadMem(registers[PCReg], 4, &amp;raw)) return; /* exception occurred */ instr-&gt;value = raw; instr-&gt;Decode(); ... int pcAfter = registers[NextPCReg] + 4; unsigned int rs, rt, imm; /* Execute the instruction */ switch (instr-&gt;opCode) { case OP_ADD: sum = registers[instr-&gt;rs] + registers[instr-&gt;rt]; registers[instr-&gt;rd] = sum; break; ... } ... /* Advance program counters */ registers[PrevPCReg] = registers[PCReg]; registers[PCReg] = registers[NextPCReg]; registers[NextPCReg] = pcAfter;} &#x4E00;&#x500B; Instruction &#x662F; 4 &#x500B; byte&#xFF0C;&#x6070;&#x597D;&#x662F;&#x4E00;&#x500B; unsigned int &#x7684;&#x5927;&#x5C0F;&#xFF0C;&#x56E0;&#x6B64;&#x6211;&#x5011;&#x7528;&#x4E00;&#x500B; unsigned int &#x4F86;&#x5132;&#x5B58;&#x4ED6;&#x3002; 12345678class Instruction {public: void Decode(); unsigned int value; char opCode; /* Type of instruction */ char rs, rt, rd; /* Three registers from instruction */ int extra; /* Immediate or target or shamt field or offset */}; 3. Instruction::Decode machine/mippsim.cc &#x5C07;&#x6211;&#x5011;&#x5B58;&#x5728; unsigned int value &#x88E1;&#x7684; instruction decode&#xFF0C;&#x6211;&#x5011;&#x53EF;&#x4EE5;&#x5F97;&#x5230;&#x9019;&#x4E00;&#x5230;&#x6307;&#x4EE4;&#x7684; rs / rt / rd / opCode&#x3002; 1234567891011void Instruction::Decode(){ OpInfo *opPtr; rs = (value &gt;&gt; 21) &amp; 0x1f; rt = (value &gt;&gt; 16) &amp; 0x1f; rd = (value &gt;&gt; 11) &amp; 0x1f; opPtr = &amp;opTable[(value &gt;&gt; 26) &amp; 0x3f]; opCode = opPtr-&gt;opCode; ...} Implementation PageTable &#x5728;&#x4FEE;&#x6539;&#x4E4B;&#x524D;&#xFF0C;&#x5728; addrSpace &#x7269;&#x4EF6;&#x5EFA;&#x7ACB;&#x6642;&#x5C31;&#x6703;&#x5EFA;&#x7ACB; pageTable&#xFF0C;&#x9810;&#x8A2D; NachOS &#x53EA;&#x6703;&#x904B;&#x884C;&#x4E00;&#x500B;&#x53EF;&#x57F7;&#x884C;&#x6A94;&#xFF0C;&#x56E0;&#x6B64;&#x9019;&#x500B; pageTable &#x6DB5;&#x84CB;&#x6574;&#x500B; physical memory&#xFF0C;&#x56E0;&#x6B64;&#x4E0D;&#x9700;&#x8981;&#x505A;&#x4EFB;&#x4F55; virtualPage &#x548C; physicalPage &#x4E4B;&#x9593;&#x7684;&#x6620;&#x5C04;&#x3002; 1234567891011121314151617/* userprog/addrspace.cc */AddrSpace::AddrSpace(){ pageTable = new TranslationEntry[NumPhysPages]; for (int i = 0; i &lt; NumPhysPages; i++) { pageTable[i].virtualPage = i; pageTable[i].physicalPage = i; pageTable[i].valid = TRUE; pageTable[i].use = FALSE; pageTable[i].dirty = FALSE; pageTable[i].readOnly = FALSE; } /* zero out the entire address space */ bzero(kernel-&gt;machine-&gt;mainMemory, MemorySize);} &#x4F46;&#x662F;&#x7576;&#x6211;&#x5011;&#x60F3;&#x8981;&#x540C;&#x6642;&#x57F7;&#x884C;&#x4E00;&#x500B;&#x4EE5;&#x4E0A;&#x7684;&#x53EF;&#x57F7;&#x884C;&#x6A94;&#x6642;&#xFF0C;&#x6703;&#x767C;&#x751F;&#x554F;&#x984C;&#xFF0C;&#x56E0;&#x70BA;&#x55AE;&#x4E00;&#x500B; thread &#x4E0D;&#x80FD;&#x64C1;&#x6709;&#x6574;&#x500B; physical memory &#x7684;&#x6240;&#x6709;&#x6B0A;&#xFF0C;&#x6BCF;&#x500B; thread &#x90FD;&#x53EA;&#x80FD;&#x64C1;&#x6709;&#x90E8;&#x4EFD;&#x7684; physical memory&#xFF0C;&#x56E0;&#x6B64;&#x6211;&#x4FEE;&#x6539; pageTable &#x7684;&#x5EFA;&#x7ACB;&#xFF0C;&#x6BCF;&#x500B; thread &#x7684; pageTable &#x7684;&#x5C3A;&#x5BF8;&#x53EA;&#x5305;&#x542B;&#x4ED6;&#x6240;&#x9700;&#x8981;&#x7684;&#x90E8;&#x4EFD;&#x3002;&#x4F46;&#x662F;&#x5728;&#x6211;&#x5011;&#x5C07;&#x53EF;&#x57F7;&#x884C;&#x6A94; load &#x9032; memory &#x4E4B;&#x524D;&#xFF0C;&#x6211;&#x5011;&#x4E26;&#x4E0D;&#x77E5;&#x9053;&#x9019;&#x500B;&#x53EF;&#x57F7;&#x884C;&#x6A94;&#x9700;&#x8981;&#x591A;&#x5C11;&#x7A7A;&#x9593;&#xFF0C; &#x56E0;&#x6B64;&#x6211;&#x5C07; pageTable &#x7684;&#x5EFA;&#x7ACB;&#x5EF6;&#x5F8C;&#xFF0C;&#x76F4;&#x5230;&#x53EF;&#x57F7;&#x884C;&#x6A94;&#x7684; header &#x8B80;&#x5165;&#xFF0C;&#x6211;&#x5011;&#x77E5;&#x9053;&#x9019;&#x500B;&#x53EF;&#x57F7;&#x884C;&#x6A94;&#x7684;&#x5927;&#x5C0F;&#x4E4B;&#x5F8C;&#xFF0C;&#x624D;&#x5EFA;&#x7ACB; pageTable&#x3002; 12345678910111213141516171819202122/* userprog/addrspace.cc */bool AddrSpace::Load(char *fileName) { ... numPages = divRoundUp(size, PageSize); /* setup pageTable after we know how much space the program needs */ pageTable = new TranslationEntry[numPages]; for (int i = 0; i &lt; numPages; i++) { pageTable[i].virtualPage = i; pageTable[i].physicalPage = kernel-&gt;usedPhyPage-&gt;checkAndSet(); pageTable[i].valid = true; pageTable[i].use = false; pageTable[i].dirty = false; pageTable[i].readOnly = false; /* zero out this physical page */ bzero(kernel-&gt;machine-&gt;mainMemory + pageTable[i].physicalPage * PageSize, PageSize); }} &#x65B0;&#x589E; class UsedPhyPage &#x4F86;&#x7BA1;&#x7406; physical memory&#xFF0C;&#x4F7F;&#x7528;&#x4E00;&#x500B; array &#x7D00;&#x9304; physical page &#x662F;&#x5426;&#x5DF2;&#x7D93;&#x88AB;&#x4F7F;&#x7528;&#x3002; 1234567/* threads/kernel.cc */class UsedPhyPage {public: int *pages; /* 0 for unused, 1 for used */ int checkAndSet();}; checkAndSet() &#x56DE;&#x50B3;&#x4E00;&#x500B;&#x672A;&#x4F7F;&#x7528;&#x7684; physical page &#x7684; pageNum&#xFF0C;&#x5982;&#x679C;&#x6574;&#x500B; physical memory &#x90FD;&#x5DF2;&#x7D93;&#x88AB;&#x4F7F;&#x7528;&#xFF0C;&#x56DE;&#x50B3; -1&#x3002;&#x4F7F;&#x7528;&#x9019;&#x500B;&#x65B9;&#x6CD5;&#x5EFA;&#x7ACB; pageTable&#xFF0C;&#x6BCF;&#x500B; thread &#x7BA1;&#x7406;&#x81EA;&#x5DF1;&#x7684; pageTable&#xFF0C;&#x4F7F;&#x7528;&#x5C6C;&#x65BC;&#x81EA;&#x5DF1;&#x7684; memory space &#x3002; 1pageTable[i].physicalPage = kernel-&gt;usedPhyPage-&gt;checkAndSet(); File Loading &#x7576;&#x6211;&#x5011;&#x8981;&#x57F7;&#x884C;&#x4E00;&#x500B;&#x53EF;&#x57F7;&#x884C;&#x6A94;&#xFF0C;&#x9996;&#x5148;&#x8981;&#x628A;&#x8A72;&#x6A94;&#x6848; load &#x9032; memory&#xFF0C;&#x4E00;&#x500B; NachOS &#x53EF;&#x57F7;&#x884C;&#x6A94;&#x5206;&#x6210;&#x56DB;&#x500B;&#x90E8;&#x4EFD;&#xFF0C;header / code / initData / readonlyData&#xFF0C;&#x6211;&#x5011;&#x9996;&#x5148;&#x8B80;&#x51FA; header &#x4F86;&#x7372;&#x53D6;&#x6A94;&#x6848;&#x7684; metadata&#xFF0C;&#x6839;&#x64DA;&#x6B64; metadata &#x6211;&#x5011;&#x53EF;&#x4EE5;&#x77E5;&#x9053; code / initData / readonlyData &#x5728;&#x6A94;&#x6848;&#x4E2D;&#x7684;&#x8D77;&#x59CB;&#x4F4D;&#x7F6E;&#x548C;&#x5927;&#x5C0F;&#x3002; 123456789101112/* coff2noff/noff.h */typedef struct noffHeader { int noffMagic; /* should be NOFFMAGIC */ Segment code; /* executable code segment */ Segment initData; /* initialized data segment */#ifdef RDATA Segment readonlyData; /* read only data */#endif Segment uninitData; /* uninitialized data segment, should be zero&apos;ed * before use */} NoffHeader; 1234567/* coff2noff/noff.h */typedef struct segment { int virtualAddr; /* location of segment in virt addr space */ int inFileAddr; /* location of segment in this file */ int size; /* size of segment */} Segment; &#x6211;&#x5011;&#x7684;&#x76EE;&#x6A19;&#x662F;&#x628A;&#x6BCF;&#x4E00;&#x6BB5; segment &#x5F9E;&#x4ED6;&#x5728;&#x6A94;&#x6848;&#x88E1;&#x7684;&#x4F4D;&#x7F6E;&#xFF0C;load &#x5230;&#x4ED6;&#x7684; virtualAddr &#x6240;&#x5C0D;&#x61C9;&#x7684; physicalAddr&#x3002;&#x672A;&#x4FEE;&#x6539;&#x524D;&#x56E0;&#x70BA;&#x6574;&#x500B; memory &#x53EA;&#x6709;&#x4E00;&#x500B; thread &#x5728;&#x4F7F;&#x7528;&#xFF0C;&#x6240;&#x4EE5; physicalAddr &#x548C; virtualAddr &#x76F8;&#x540C;&#xFF0C;&#x4E26;&#x4E14;&#x56E0;&#x70BA;&#x9019;&#x500B;&#x53EF;&#x57F7;&#x884C;&#x6A94;&#x662F;&#x7B2C;&#x4E00;&#x500B;&#x4E5F;&#x662F;&#x552F;&#x4E00;&#x4E00;&#x500B; load &#x9032; memory &#x7684;&#x6A94;&#x6848;&#xFF0C;&#x56E0;&#x6B64;&#x6574;&#x500B;&#x7A7A;&#x9593;&#x662F;&#x9023;&#x7E8C;&#x4E14;&#x7121;&#x4EBA;&#x4F7F;&#x7528;&#x7684;&#xFF0C;&#x628A;&#x53EF;&#x57F7;&#x884C;&#x6A94;&#x642C;&#x79FB;&#x5230; memory&#xFF0C;&#x6BCF;&#x4E00;&#x500B; segment &#x53EA;&#x8981;&#x642C;&#x79FB;&#x4E00;&#x6B21;&#x5373;&#x53EF;&#x3002; 123456789101112131415161718192021222324252627282930313233/* userprog/addrspace.cc */bool AddrSpace::Load(char *fileName) { /* read header file */ OpenFile *executable = kernel-&gt;fileSystem-&gt;Open(fileName); NoffHeader noffH; unsigned int size; executable-&gt;ReadAt((char *)&amp;noffH, sizeof(noffH), 0); ...#ifdef RDATA size = noffH.code.size + noffH.readonlyData.size + noffH.initData.size + noffH.uninitData.size + UserStackSize; ...#endif numPages = divRoundUp(size, PageSize); size = numPages * PageSize; if (noffH.code.size &gt; 0) { executable-&gt;ReadAt( &amp;(kernel-&gt;machine-&gt;mainMemory[noffH.code.virtualAddr]), noffH.code.size, noffH.code.inFileAddr); } if (noffH.initData.size &gt; 0) { ... }#ifdef RDATA if (noffH.readonlyData.size &gt; 0) { ... }#endif} &#x5728;&#x4FEE;&#x6539;&#x4E4B;&#x5F8C;&#xFF0C;memory &#x7531;&#x591A;&#x500B; thread &#x5171;&#x7528;&#xFF0C;&#x56E0;&#x6B64;&#x5728;&#x5C07;&#x8CC7;&#x6599;&#x5F9E;&#x6A94;&#x6848; load &#x9032; memory &#x4E4B;&#x524D;&#xFF0C;&#x9700;&#x8981;&#x5148;&#x4F7F;&#x7528; Translate() &#x5C07; virtualAddr &#x8F49;&#x63DB;&#x6210;&#x5C0D;&#x61C9;&#x7684; physicalAddr&#x3002;&#x56E0;&#x70BA;&#x6709;&#x591A;&#x500B; thread &#x5171;&#x7528; memory&#xFF0C;memory &#x4E2D;&#x53EF;&#x80FD;&#x5DF2;&#x7D93;&#x6709;&#x4E9B; page &#x88AB;&#x5225;&#x7684; thread &#x4F54;&#x7528;&#x4E86;&#xFF0C;&#x56E0;&#x6B64;&#x8CC7;&#x6599;&#x9700;&#x8981;&#x4E00;&#x500B; page &#x4E00;&#x500B; page &#x7684; load &#x9032; memory &#xFF0C;&#x800C;&#x4E0D;&#x80FD;&#x6574;&#x6BB5; segment (&#x5305;&#x542B;&#x6578;&#x500B; page ) load &#x9032; memory &#x3002; &#x4EE5;&#x4E0B;&#x5716;&#x70BA;&#x4F8B;&#xFF0C;&#x9019;&#x500B;&#x6A94;&#x6848;&#x6709; 4 &#x500B; page&#xFF0C;&#x6BCF;&#x4E00;&#x500B; page &#x6709; 5 &#x500B; bytes&#xFF0C;virtal page &#x548C; physical page &#x7684;&#x5C0D;&#x61C9;&#x5982;&#x4E0B;&#xFF0C;&#x53EF;&#x4EE5;&#x770B;&#x5230; virtual page &#x662F;&#x9023;&#x7E8C;&#x7684; (0 , 1 , 2 , 3)&#xFF0C;&#x4F46; physical page &#x4E0D;&#x662F;&#x9023;&#x7E8C;&#x7684; (6 , 9 , 7 , 11)&#xFF0C;&#x56E0;&#x6B64;&#x6211;&#x5011;&#x5728;&#x642C;&#x79FB;&#x8CC7;&#x6599;&#x6642;&#xFF0C;&#x4E00;&#x6B21;&#x53EA;&#x80FD;&#x642C;&#x4E00;&#x500B; virtual page &#x7684;&#x8CC7;&#x6599;&#x3002; &#x5047;&#x8A2D;&#x6211;&#x5011;&#x6240;&#x8981;&#x642C;&#x79FB;&#x7684;&#x8CC7;&#x6599;&#x5F9E; virtual addr 8 - 17&#xFF0C;&#x53EF;&#x4EE5;&#x770B;&#x5230;&#x4ED6;&#x5305;&#x542B;&#x4E86; 3 &#x500B; page&#xFF0C;&#x56E0;&#x6B64;&#x6211;&#x5011;&#x9700;&#x8981;&#x5206;&#x6210; 3 &#x6B21;&#x8F49;&#x79FB;&#x8CC7;&#x6599;&#xFF0C;&#x8CC7;&#x6599;&#x5F9E; inFile addr &#x642C;&#x79FB;&#x5230;&#x6211;&#x5011;&#x6307;&#x5B9A;&#x7684; virtual addr &#x5C0D;&#x61C9;&#x5230;&#x7684; physical addr&#xFF0C;virtual addr &#x53EF;&#x4EE5;&#x81EA;&#x8A02;&#xFF0C;&#x5728; NachOS &#x88E1; virtual addr &#x548C; inFile addr &#x662F;&#x76F8;&#x540C;&#x7684;&#x3002; 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* userprog/addrspace.cc */bool AddrSpace::Load(char *fileName) { ... unsigned int virtualAddr; unsigned int physicalAddr; int unReadSize; int chunkStart; int chunkSize; int inFilePosiotion; if (noffH.code.size &gt; 0) { unReadSize = noffH.code.size; chunkStart = noffH.code.virtualAddr; chunkSize = 0; inFilePosiotion = 0; /* while still unread code */ while (unReadSize &gt; 0) { /* first chunk and last chunk might not be full */ chunkSize = calChunkSize(chunkStart, unReadSize); /* mapping from virtual addr to physical addr */ Translate(chunkStart, &amp;physicalAddr, 1); executable-&gt;ReadAt( &amp;(kernel-&gt;machine-&gt;mainMemorymainMemory[physicalAddr]), chunkSize, noffH.code.inFileAddr + inFilePosiotion); unReadSize = unReadSize - chunkSize; chunkStart = chunkStart + chunkSize; inFilePosiotion = inFilePosiotion + chunkSize; } } if (noffH.initData.size &gt; 0) { ... }#ifdef RDATA if (noffH.readonlyData.size &gt; 0) { ... }#endif ...} Questions How Nachos allocates the memory space for new thread(process)? How Nachos initializes the memory content of a thread(process), including loading the user binary code in the memory? How Nachos initializes the machine status (registers, etc) before running a thread(process)? &#x6BCF;&#x4E00;&#x500B;&#x53EF;&#x57F7;&#x884C;&#x6A94;&#x90FD;&#x9700;&#x8981; new &#x4E00;&#x500B;&#x65B0;&#x7684; thread &#x4F86;&#x57F7;&#x884C;&#x3002; 1234567891011/* threads/kernel.cc&#x200B; */int Kernel::Exec(char* name){ t[threadNum] = new Thread(name, threadNum); t[threadNum]-&gt;space = new AddrSpace(); t[threadNum]-&gt;Fork((VoidFunctionPtr)&amp;ForkExecute, (void*)t[threadNum]); threadNum++; return threadNum-1;} &#x9019;&#x500B; thread &#x6240;&#x8981;&#x57F7;&#x884C;&#x7684; function &#x548C;&#x4ED6;&#x6240;&#x9700;&#x8981;&#x7684; argument &#x4E1F;&#x9032; StackAllocate&#xFF0C;&#x6B64;&#x6642;&#x6211;&#x5011;&#x8981;&#x57F7;&#x884C;&#x7684; function &#x662F; ForkExecute&#x3002; 1234567891011121314/* threads/thread.cc */void Thread::Fork(VoidFunctionPtr func, void *arg){ Interrupt *interrupt = kernel-&gt;interrupt; Scheduler *scheduler = kernel-&gt;scheduler; IntStatus oldLevel; StackAllocate(func, arg); oldLevel = interrupt-&gt;SetLevel(IntOff); scheduler-&gt;ReadyToRun(this); (void) interrupt-&gt;SetLevel(oldLevel);} &#x5EFA;&#x7ACB;&#x548C;&#x521D;&#x59CB;&#x5316;&#x9019;&#x500B; thread &#x7684; execution stack&#x3002; 12345678910111213/* threads/thread.cc */void Thread::StackAllocate (VoidFunctionPtr func, void *arg){ stack = (int *) AllocBoundedArray(StackSize * sizeof(int)); ... machineState[PCState] = (void*)ThreadRoot; machineState[StartupPCState] = (void*)ThreadBegin; machineState[InitialPCState] = (void*)func; machineState[InitialArgState] = (void*)arg; machineState[WhenDonePCState] = (void*)ThreadFinish; ...} ForkExecute &#x662F;&#x6211;&#x5011;&#x60F3;&#x57F7;&#x884C;&#x7684; func&#xFF0C;&#x5C07;&#x6211;&#x5011;&#x6307;&#x5B9A;&#x7684;&#x53EF;&#x57F7;&#x884C;&#x6A94; load &#x9032; memory&#xFF0C;&#x7136;&#x5F8C;&#x57F7;&#x884C;&#x4ED6;&#x3002;&#x6B64;&#x6642;&#x5206;&#x914D;&#x7A7A;&#x9593;&#x4E26;&#x4E14;&#x5EFA;&#x7ACB; pageTable&#x3002; 12345678910/* threads/kernel.cc */void ForkExecute(Thread *t){ /* allocate pageTable for this process */ if (!t-&gt;space-&gt;Load(t-&gt;getName())) { return; /* executable not found */ } t-&gt;space-&gt;Execute(t-&gt;getName());} &#x5C07;&#x53EF;&#x57F7;&#x884C;&#x6A94;&#x8B80;&#x5165; memory&#x3002;&#x9996;&#x5148;&#x8B80;&#x5165;&#x53EF;&#x57F7;&#x884C;&#x6A94;&#x7684; header&#xFF0C;&#x8B80;&#x53D6; header &#x4E4B;&#x5F8C;&#x5C31;&#x80FD;&#x77E5;&#x9053;&#x6A94;&#x6848;&#x5927;&#x5C0F;&#xFF0C;&#x5EFA;&#x7ACB; pageTable&#x3002;&#x5EFA;&#x7ACB; pageTable &#x6642;&#x6703;&#x628A;&#x8A72; thread &#x5206;&#x914D;&#x5230;&#x7684; physical page &#x6E05;&#x7A7A;&#x3002;&#x6709;&#x4E86; pageTable &#x4E4B;&#x5F8C;&#x5C31;&#x80FD;&#x628A;&#x53EF;&#x57F7;&#x884C;&#x6A94;&#x7684;&#x5176;&#x4ED6;&#x90E8;&#x4EFD; load &#x9032; memory &#x4E86;&#x3002; 1t-&gt;space-&gt;Load(t-&gt;getName()) How Nachos creates and manages the page table? How Nachos translates address? class UsedPhyPage &#x53EF;&#x4EE5;&#x5E6B;&#x52A9;&#x5EFA;&#x7ACB;&#x548C;&#x7BA1;&#x7406; physical memory&#xFF0C;&#x5728;&#x5B8C;&#x6210; pageTable &#x4E4B;&#x5F8C;&#x4F7F;&#x7528; Translate &#x5373;&#x53EF;&#x5C07; virtual addr &#x8F49;&#x63DB;&#x70BA; physical addr&#x3002; 12345678910111213141516171819/* machine/translate.cc */ExceptionTypeMachine::Translate(int virtAddr, int* physAddr, int size, bool writing){ unsigned int vpn, offset; TranslationEntry *entry; unsigned int pageFrame; vpn = (unsigned) virtAddr / PageSize; /* virtual page number */ offset = (unsigned) virtAddr % PageSize; /* offset within the page */ ... entry = &amp;pageTable[vpn]; /* translate using pageTable */ ... pageFrame = entry-&gt;physicalPage; ... *physAddr = pageFrame * PageSize + offset; return NoException;} 123456class TranslationEntry {public: int virtualPage; int physicalPage; ...}; ** Which object&#x200B; in Nachos acts the role of &#x200B; process control block? ** PCB (process control block) &#x5305;&#x542B;&#x548C; process / thread &#x76F8;&#x95DC;&#x7684;&#x4E00;&#x4E9B;&#x8CC7;&#x8A0A;&#xFF0C;&#x4F8B;&#x5982; : process state program counter CPU register CPU scheduling info (e.g. priority) memory management info (e.g. base / limit register) and more class Thread &#x6709;&#x5F88;&#x591A; PCB &#x61C9;&#x8A72;&#x5305;&#x542B;&#x7684;&#x8CC7;&#x8A0A;&#xFF0C;&#x4F8B;&#x5982; : process state --&gt; status memory management --&gt; space CPU register --&gt; machineState and more 12345678910111213141516class Thread {private: int *stackTop; /* the current stack pointer */ void *machineState[MachineStateSize]; /* all registers except for * stackTop */ int *stack; /* bottom of the stack */ ThreadStatus status; /* ready, running or blocked */ char* name; int ID; int userRegisters[NumTotalRegs]; /* user-level CPU register state */ ...public: AddrSpace *space; /* user code this thread is running */ ...}; When and how does a thread get added into the ReadyToRun queue of Nachos CPU scheduler? 1234567891011121314/* threads/thread.cc */void Thread::Fork(VoidFunctionPtr func, void *arg){ Interrupt *interrupt = kernel-&gt;interrupt; Scheduler *scheduler = kernel-&gt;scheduler; IntStatus oldLevel; StackAllocate(func, arg); oldLevel = interrupt-&gt;SetLevel(IntOff); scheduler-&gt;ReadyToRun(this); (void) interrupt-&gt;SetLevel(oldLevel);} &#x7576;&#x4E00;&#x500B; thread &#x5DF2;&#x7D93;&#x5EFA;&#x7ACB;&#x597D;&#x4ED6;&#x7684; stack&#xFF0C;&#x5C07;&#x4ED6;&#x52A0;&#x5165; readyList&#xFF0C;&#x7576; scheduler &#x9700;&#x8981;&#x5B89;&#x6392; thread &#x4F86;&#x57F7;&#x884C;&#x7684;&#x6642;&#x5019;&#xFF0C;&#x5C31;&#x5F9E; readyList dequeue &#x4E00;&#x500B; thread &#x4F86;&#x57F7;&#x884C;&#x3002; 1scheduler-&gt;ReadyToRun(this); Reference [1] shawn2000100/10810CS_342301_OperatingSystem https://github.com/shawn2000100/10810CS_342301_OperatingSystem [2] OS::NachOS::HW1 http://blog.terrynini.tw/tw/OS-NachOS-HW1/ [3] Nachos Project 3 https://www.csie.ntu.edu.tw/~b96201044/Project3_Slide_2010.pdf","categories":[],"tags":[]},{"title":"NachOS MP1 - System Call","slug":"NachOS-MP1","date":"2021-07-13T16:57:48.000Z","updated":"2021-08-24T09:34:36.585Z","comments":true,"path":"2021/07/14/NachOS-MP1/","link":"","permalink":"http://example.com/2021/07/14/NachOS-MP1/","excerpt":"","text":"&#x9019;&#x662F;&#x6E05;&#x5927;&#x5468;&#x5FD7;&#x9060;&#x6559;&#x6388;&#x4F5C;&#x696D;&#x7CFB;&#x7D71;&#x7684;&#x4F5C;&#x696D;&#xFF0C;&#x6211;&#x5728;&#x7DB2;&#x8DEF;&#x4E0A;&#x627E;&#x5230;&#x9019;&#x4EFD;&#x4F5C;&#x696D;&#x7684;&#x76F8;&#x95DC;&#x8CC7;&#x6599;&#xFF0C;&#x6211;&#x4E26;&#x6C92;&#x6709;&#x4E0A;&#x904E;&#x9019;&#x9580;&#x8AB2;&#xFF0C;&#x9019;&#x53EA;&#x662F;&#x6211;&#x7684;&#x81EA;&#x5B78;&#x7DF4;&#x7FD2;&#xFF0C;&#x6211;&#x7121;&#x6CD5;&#x80AF;&#x5B9A;&#x6211;&#x7684;&#x5831;&#x544A;&#x548C;&#x5BE6;&#x4F5C;&#x7684;&#x6B63;&#x78BA;&#x6027;&#xFF0C;&#x6211;&#x7684;&#x5BE6;&#x4F5C;&#x5728;&#x9019;&#x88E1;&#xFF0C;&#x6211;&#x7684; shell script &#x5728;&#x9019;&#x88E1;&#x3002; Code Study SC_Halt Trace the SC_Halt system call to understand the implementation of a system call. (Sample code : halt.c) Halt userprog/syscall.h trace code &#x7684;&#x76EE;&#x6A19;&#x662F; syscall.h &#x7684; Halt()&#x3002; 123#define SC_Halt 0void Halt(); 123456789/* test/start.s */ .globl Halt .ent HaltHalt: addiu $2,$0,SC_Halt syscall j $31 .end Halt &#x57F7;&#x884C;&#x6307;&#x4EE4; addiu&#xFF0C;SC_Halt &#x662F;&#x5B9A;&#x7FA9;&#x5728; syscall.h &#x7684;&#x5E38;&#x6578;&#xFF0C;MIPS &#x67B6;&#x69CB;&#x7684; register(0) &#x6C38;&#x9060;&#x662F; 0&#xFF0C;&#x5C07;&#x5169;&#x8005;&#x76F8;&#x52A0;&#x5F8C;&#x5B58;&#x5230; register(2) &#x4E2D;&#xFF0C;&#x5373;&#x5C07; SC_Halt &#x7684;&#x503C; assign &#x7D66; register(2)&#x3002; 1addiu $2,$0,SC_Halt &#x57F7;&#x884C;&#x6307;&#x4EE4; syscall&#xFF0C;&#x9032;&#x5165;Exception handler&#x3002; 1syscall &#x5728; machine.h &#x5B9A;&#x7FA9;&#x5E38;&#x6578; RetAddrReg &#x7684;&#x503C;&#x662F; 31&#x3002;&#x8DF3;&#x5230; register(31) &#x6240;&#x5132;&#x5B58;&#x7684;&#x4F4D;&#x7F6E;&#xFF0C;&#x8868;&#x793A;&#x56DE;&#x5230; frame &#x7684;&#x4E0A;&#x4E00;&#x5C64;&#x3002; 1j $31 1. Machine::Run machine/mipssim.cc &#x7A0B;&#x5F0F;&#x958B;&#x59CB;&#x57F7;&#x884C;&#xFF0C;kernel &#x547C;&#x53EB; Machine::Run()&#xFF0C;Machine::Run() &#x5728;&#x7121;&#x7AAE;&#x8FF4;&#x5708;&#x547C;&#x53EB; OneInstruction()&#xFF0C;&#x4E0D;&#x505C;&#x7684;&#x57F7;&#x884C;&#x6307;&#x4EE4;&#x3002;mipssim.h &#x5B9A;&#x7FA9;&#x4E86; MIPS &#x67B6;&#x69CB;&#x652F;&#x63F4;&#x7684; 63 &#x500B;operation&#xFF0C;OneInstruction() &#x8CA0;&#x8CAC;&#x8655;&#x7406;&#x9019; 63 &#x500B; operation &#x7D44;&#x6210;&#x7684;&#x6307;&#x4EE4;&#x3002; 1234567void Machine::Run(){ for(;;) { OneInstruction(instr); }} 2. Machine::OneInstruction machine/mipssim.cc machine.h &#x5B9A;&#x7FA9;&#x5E38;&#x6578; PCReg &#x503C; 34&#xFF0C;register(34) &#x653E;&#x6709;&#x7576;&#x524D;&#x6307;&#x4EE4;&#x7684;&#x4F4D;&#x5740;&#x3002;&#x4E0D;&#x540C;&#x6307;&#x4EE4;&#x9032;&#x5165;&#x4E0D;&#x540C;&#x7684; switch case&#xFF0C;&#x7576;&#x6307;&#x4EE4;&#x662F; addiu&#xFF0C;&#x4E0D;&#x6703;&#x767C;&#x751F; interrupt&#xFF0C;&#x4F46;&#x7576;&#x6307;&#x4EE4;&#x662F; syscall&#xFF0C;interupt &#x767C;&#x751F;&#xFF0C;&#x547C;&#x53EB; RaiseException()&#x3002; 123456789101112131415161718Void Machine::OneInstruction(Instruction *instr){ int raw; /* fetch instruction */ if (!ReadMem(registers[PCReg], 4, &amp;raw)) { return; } instr-&gt;value = raw; instr-&gt;Decode(); switch (instr-&gt;opCode) { case OP_SYSCALL: RaiseException(SyscallException, 0); return; }} NachOS &#x5B9A;&#x7FA9;&#x4E86; 9 &#x7A2E; exception &#x985E;&#x578B;&#xFF0C;&#x5728; case OP_SYSCALL &#x767C;&#x751F;&#x7684;&#x662F; SyscallException &#x985E;&#x578B;&#x7684; exception&#x3002; 12345678910111213/* machine/machine.h */enum ExceptionType { NoException, SyscallException, PageFaultException, ReadOnlyException, BusErrorException, AddressErrorException, OverflowException, IllegalInstrException, NumExceptionTypes}; 3. Machine::RaiseException machine/machine.cc &#x628A;&#x7A0B;&#x5F0F;&#x5F9E; user mode &#x6539;&#x6210; kernel mode&#xFF0C;&#x547C;&#x53EB; ExceptionHandler&#x3002; 123456void Machine::RaiseException(ExceptionType which, int badVAddr){ kernel-&gt;interrupt-&gt;setStatus(SystemMode); ExceptionHandler(which); kernel-&gt;interrupt-&gt;setStatus(UserMode);} 4. ExceptionHandler userprog/exception .cc ExceptionHandler() &#x8B80;&#x53D6; register(2) &#x7684;&#x503C;&#xFF0C;&#x5148;&#x524D;&#x5DF2;&#x7D93;&#x628A; SC_Halt &#x7684;&#x503C; assign &#x7D66;register(2)&#xFF0C;&#x56E0;&#x6B64;&#x9032;&#x5165; SC_Halt &#x7684; switch case&#xFF0C;&#x547C;&#x53EB; SysHalt()&#x3002; 123456789void ExceptionHandler(ExceptionType which){ int type = kernel-&gt;machine-&gt;ReadRegister(2); switch(type) { case SC_Halt: SysHalt(); break; }} 5. SysHalt userprog/ksyscall.h 1234void SysHalt(){ kernel-&gt;interrupt-&gt;Halt();} 6. Interrupt::Halt machine/interrupt.cc &#x5C07;&#x7269;&#x4EF6; kernel &#x6240;&#x4F54;&#x7528;&#x7684;&#x8A18;&#x61B6;&#x9AD4;&#x91CB;&#x653E;&#xFF0C;&#x5373;&#x95DC;&#x6A5F;&#x3002; 1234567void Interrupt::Halt(){ cout &lt;&lt; &quot;Machine halting!\\n\\n&quot;; cout &lt;&lt; &quot;This is halt\\n&quot;; kernel-&gt;stats-&gt;Print(); delete kernel; } SC_Create Trace the SC_Create system call to understand the basic operations and data structure in a file system. (Sample code : createFile.c) Create userprog/syscall.h trace code &#x7684;&#x76EE;&#x6A19;&#x662F; syscall.h &#x7684; Create()&#x3002; 123#define SC_Create 4int Create(char *name); 1234567891011/* test/start.s */#include &quot;syscall.h&quot; .globl Create .ent CreateCreate: addiu $2,$0,SC_Create syscall j $31 .end Create 1. Machine::OneInstruction machine/mipssim 1234567891011#include &quot;machine.h&quot;#include &quot;mipssim.h&quot;void Machine::OneInstruction(Instruction *instr){ switch (instr-&gt;opCode) { case OP_SYSCALL: RaiseException(SyscallException, 0); return; }} 2. Machine::RaiseException machine/machine.cc 12345678#include &quot;machine.h&quot;void Machine::RaiseException(ExceptionType which, int badVAddr){ kernel-&gt;interrupt-&gt;setStatus(SystemMode); ExceptionHandler(which); kernel-&gt;interrupt-&gt;setStatus(UserMode);} 3. ExceptionHandler userprog/exception.cc &#x5F9E; register(4) &#x8B80;&#x51FA;&#x547C;&#x53EB; Create &#x6642;&#x50B3;&#x5165;&#x7684;&#x53C3;&#x6578;&#xFF0C;&#x5373; filename &#x7684;&#x4F4D;&#x7F6E;&#x3002;Syscreate &#x56DE;&#x50B3;&#x662F;&#x5426;&#x6709;&#x6210;&#x529F;&#x7684; create file&#xFF0C;&#x6210;&#x529F;&#x56DE;&#x50B3; 1&#xFF0C;&#x5931;&#x6557;&#x56DE;&#x50B3; 0&#x3002;&#x5B8C;&#x6210; SysCreate &#x5F8C;&#x5FC5;&#x9808;&#x4FEE;&#x6539; PCReg &#x8B93; PCReg &#x6307;&#x5411;&#x4E0B;&#x4E00;&#x500B;&#x6307;&#x4EE4;&#xFF0C;&#x5982;&#x679C;&#x6C92;&#x6709;&#x52A0;&#x4E0A;&#x9019;&#x4E00;&#x884C;&#xFF0C;&#x7A0B;&#x5F0F;&#x6703;&#x4E0D;&#x505C;&#x7684;&#x57F7;&#x884C;&#x540C;&#x4E00;&#x9053;&#x6307;&#x4EE4;&#x3002; 123456789101112131415161718192021222324252627#include &quot;syscall.h&quot;#include &quot;ksyscall.h&quot;void ExceptionHandler(ExceptionType which){ int type = kernel-&gt;machine-&gt;ReadRegister(2); switch(type) { case SC_Create: val = kernel-&gt;machine-&gt;ReadRegister(4); char *filename = &amp;(kernel-&gt;machine-&gt;mainMemory[val]); status = SysCreate(filename); if(status != -1) status = 1; kernel-&gt;machine-&gt;WriteRegister(2, (int) status); kernel-&gt;machine-&gt;WriteRegister(PrevPCReg, kernel-&gt;machine-&gt;ReadRegister(PCReg)); kernel-&gt;machine-&gt;WriteRegister(PCReg, kernel-&gt;machine-&gt;ReadRegister(PCReg) + 4); kernel-&gt;machine-&gt;WriteRegister(NextPCReg, kernel-&gt;machine-&gt;ReadRegister(PCReg)+4); return; ASSERTNOTREACHED(); break; }} 4. SysCreate userprog/ksyscall.h 1234int Interrupt::CreateFile(char *filename){ return kernel-&gt;CreateFile(filename);} 5. Interrupt::CreateFile machine/interrupt.cc class FileSystem &#x662F; NachOS &#x7684; file system API&#x3002; 1234int Kernel::CreateFile(char *filename){ return fileSystem-&gt;Create(filename);} &#x5728; filesys.cc &#x7684;&#x958B;&#x982D;&#x6709;&#x4E00;&#x6BB5; #ifdef #else&#xFF0C;&#x6709;&#x6C92;&#x6709; #define FILESYS_STUB &#x4F7F;&#x7528;&#x7684;&#x662F;&#x4E0D;&#x540C;&#x7684;&#x6A94;&#x6848;&#x7CFB;&#x7D71;&#xFF0C;&#x5982;&#x679C;&#x6709; #define FILESYS_STUB&#xFF0C;&#x4E26;&#x4E0D;&#x662F;&#x4F7F;&#x7528;&#x771F;&#x6B63;&#x7684; NachOS &#x6A94;&#x6848;&#x7CFB;&#x7D71;&#xFF0C;&#x53EA;&#x662F;&#x501F;&#x7528;&#x4E86; linux &#x7684;&#x6A94;&#x6848;&#x7CFB;&#x7D71;&#xFF0C;&#x5982;&#x679C;&#x6C92;&#x6709; #define FILESYS_STUB&#xFF0C;&#x624D;&#x662F;&#x4F7F;&#x7528; NachOS &#x7684;&#x6A94;&#x6848;&#x7CFB;&#x7D71;&#x3002; 1#ifdef FILESYS_STUB Makefile &#x88E1;&#x6709;&#x4E0B; DFILESYS_STUB &#x7684; flag&#xFF0C;&#x4EE3;&#x8868;&#x76EE;&#x524D; NachOS &#x53EA;&#x662F;&#x501F;&#x7528;&#x4E86; linux &#x7684;&#x6A94;&#x6848;&#x7CFB;&#x7D71;&#x3002; 1DEFINES = -DFILESYS_STUB -DRDATA -DSIM_FIX 6.Filesystem::Create filesys/filesys.cc 12345678910111213#ifdef FILESYS_STUB class FileSystem {public: bool Create(char *name) { int fileDescriptor = OpenForWrite(name); if (fileDescriptor == -1) return FALSE; Close(fileDescriptor); return TRUE; }} 7. OpenForWrite lib/sysdep.c &#x76EE;&#x524D;&#x7684;&#x6A94;&#x6848;&#x7CFB;&#x7D71;&#x662F;&#x501F;&#x7528; linux &#x7684;&#x6A94;&#x6848;&#x7CFB;&#x7D71;&#xFF0C;Create &#x7684;&#x5BE6;&#x4F5C;&#x662F;&#x547C;&#x53EB;&#x4E86; linux &#x63D0;&#x4F9B;&#x7684; open()&#xFF0C;open() &#x5931;&#x6557;&#x56DE;&#x50B3; -1&#xFF0C;&#x6210;&#x529F;&#x56DE;&#x50B3;&#x975E;&#x8CA0;&#x6574;&#x6578;&#x3002;NachOS &#x76EE;&#x524D;&#x6C92;&#x6709;&#x771F;&#x6B63;&#x7684;&#x6A94;&#x6848;&#x7CFB;&#x7D71;&#xFF0C;&#x5982;&#x679C;&#x6211;&#x5011;&#x8981;&#x4F7F;&#x7528;&#x771F;&#x6B63;&#x7684; NachOS &#x6A94;&#x6848;&#x7CFB;&#x7D71;&#xFF0C;&#x5C31;&#x8981;&#x5728; File System &#x7684; API &#x4E4B;&#x4E0B;&#xFF0C;&#x81EA;&#x5DF1;&#x5BEB;&#x4E00;&#x500B;&#x6A94;&#x6848;&#x7CFB;&#x7D71;&#x3002; 123456789#include &lt;stdlib.h&gt;#include &lt;sys/file.h&gt;int OpenForWrite(char *name){ int fd = open(name, O_RDWR|O_CREAT|O_TRUNC, 0666); ASSERT(fd &gt;= 0); return fd;} PrintInt Trace the SC_PrintInt system call to understand how NachOS implements asynchronized I/O using CallBack functions and register schedule events. (Sample code : add.c) PrintInt userprog/syscall.h trace code &#x7684;&#x76EE;&#x6A19;&#x662F; syscall.h &#x7684; PrintInt()&#x3002; 123#define SC_PrintInt 16void PrintInt(int number); 1234567891011/* test/start.s */#include &quot;syscall.h&quot; .globl PrintInt .ent PrintIntPrintInt: addiu $2,$0,SC_PrintInt syscall j $31 .end PrintInt 1. Machine::OneInstruction machine/mipssim 12345678910111213141516void Machine::OneInstruction(Instruction *instr){ int raw; if (!ReadMem(registers[PCReg], 4, &amp;raw)) return; instr-&gt;value = raw; instr-&gt;Decode(); switch (instr-&gt;opCode) { case OP_SYSCALL: RaiseException(SyscallException, 0); return; }} 2. Machine::RaiseException machine/machine.cc 123456void Machine::RaiseException(ExceptionType which, int badVAddr){ kernel-&gt;interrupt-&gt;setStatus(SystemMode); ExceptionHandler(which); kernel-&gt;interrupt-&gt;setStatus(UserMode);} 3. ExceptionHandler userprog/exception .cc 123456789101112131415161718192021#include &quot;syscall.h&quot;#include &quot;ksyscall.h&quot;void ExceptionHandler(ExceptionType which){ int type = kernel-&gt;machine-&gt;ReadRegister(2); switch(type) { case SC_PrintInt: val = kernel-&gt;machine-&gt;ReadRegister(4); SysPrintInt(val); kernel-&gt;machine-&gt;WriteRegister(PrevPCReg, kernel-&gt;machine-&gt;ReadRegister(PCReg)); kernel-&gt;machine-&gt;WriteRegister(PCReg, kernel-&gt;machine-&gt;ReadRegister(PCReg) + 4); kernel-&gt;machine-&gt;WriteRegister(NextPCReg, kernel-&gt;machine-&gt;ReadRegister(PCReg)+4); break; }} 4. SysPrintInt userprog/ksyscall.h 1234void SysPrintInt(int number){ kernel-&gt;synchConsoleOut-&gt;PutInt(number);} 5. SynchConsoleOutput::PutInt userprog/synchconsole.cc &#x53EA;&#x6709;&#x4E00;&#x500B; console&#xFF0C;&#x56E0;&#x6B64;&#x5FC5;&#x9808;&#x8981; sync&#xFF0C;&#x8F38;&#x51FA;&#x7684;&#x904E;&#x7A0B;&#x662F; critical section&#xFF0C;&#x4E00;&#x6B21;&#x53EA;&#x80FD;&#x6709;&#x4E00;&#x500B; thread &#x505A; console output&#x3002;&#x4F7F;&#x7528; while &#x8FF4;&#x5708;&#xFF0C;&#x5C07;&#x5B57;&#x4E32;&#x4E2D;&#x7684;&#x5B57;&#x5143;&#x4E00;&#x500B;&#x4E00;&#x500B;&#x7684;&#x5370;&#x51FA;&#x3002;&#x6BCF;&#x4E00;&#x500B;&#x5B57;&#x5143;&#x8F38;&#x51FA;&#x5B8C;&#x6210;&#x4E4B;&#x5F8C;&#xFF0C;&#x624D;&#x80FD;&#x8F38;&#x51FA;&#x4E0B;&#x4E00;&#x500B;&#x5B57;&#x5143;&#x3002; 1234567891011121314void SynchConsoleOutput::PutInt(int value){ char str[15]; int idx=0; sprintf(str, &quot;%d\\n\\0&quot;, value); /* convert int into string */ lock-&gt;Acquire(); /* enter critical section */ do{ consoleOutput-&gt;PutChar(str[idx]); idx++; waitFor-&gt;P(); } while(str[idx] != &apos;\\0&apos;); lock-&gt;Release(); /* leave critical section */ } 6. ConsoleOutput::PutChar machine/console.cc &#x547C;&#x53EB; WriteFile() &#x5C0D;&#x87A2;&#x5E55;&#x9032;&#x884C;&#x8F38;&#x51FA;&#xFF0C;&#x547C;&#x53EB; Schedule() &#x6A21;&#x64EC;&#x87A2;&#x5E55;&#x5B8C;&#x6210;&#x8F38;&#x51FA;&#x5F8C;&#x767C;&#x51FA; interrupt&#x3002; 12345void ConsoleOutput::PutChar(char ch){ WriteFile(writeFileNo, &amp;ch, sizeof(char)); kernel-&gt;interrupt-&gt;Schedule(this, ConsoleTime, ConsoleWriteInt);} WriteFile() &#x7684;&#x5BE6;&#x505A;&#x662F;&#x547C;&#x53EB; linux &#x63D0;&#x4F9B;&#x7684; write()&#xFF0C;fd &#x662F;&#x88AB;&#x5BEB;&#x5165;&#x6A94;&#x6848;&#x7684; file descriptor&#xFF0C;writeFileNo &#x7684;&#x503C;&#x5728; console.cc &#x4E2D;&#x88AB; assign &#x70BA; 1&#x3002; &#x5728; linux &#x7CFB;&#x7D71;&#x4E2D;&#xFF0C;file descriptor &#x70BA; 1 &#x5373;&#x662F; stdout&#xFF0C;&#x5B57;&#x5143;&#x6703;&#x88AB;&#x8F38;&#x51FA;&#x5230;&#x87A2;&#x5E55;&#x3002; 1234567/* lib/sysdep.cc */int WriteFile(int fd, char *buffer, int nBytes){ int retVal = write(fd, buffer, nBytes); return retVal;} &#x4E00;&#x500B;&#x771F;&#x6B63;&#x7684;&#x4F5C;&#x696D;&#x7CFB;&#x7D71;&#x6703;&#x5728;&#x8F38;&#x51FA;&#x5B8C;&#x6210;&#x7684;&#x6642;&#x5019;&#x767C;&#x51FA; interrupt&#xFF0C;&#x7531;&#x65BC;&#x9019;&#x4E0D;&#x662F;&#x771F;&#x7684;&#x4F5C;&#x696D;&#x7CFB;&#x7D71;&#xFF0C;&#x6240;&#x4EE5;&#x4ED6;&#x53EA;&#x80FD;&#x9810;&#x4F30;&#x8F38;&#x51FA;&#x6642;&#x9593;&#x7136;&#x5F8C;&#x81EA;&#x5DF1;&#x767C;&#x51FA; interrupt &#x3002;NachOS &#x9810;&#x4F30;&#x5B57;&#x5143;&#x8F38;&#x51FA;&#x9700;&#x8981; 100 &#x55AE;&#x4F4D;&#x6642;&#x9593;&#xFF0C;&#x56E0;&#x6B64;&#x5B89;&#x6392;&#x5728; 100 &#x500B;&#x55AE;&#x4F4D;&#x6642;&#x9593;&#x5F8C;&#x767C;&#x51FA; interrupt &#x3002;&#x95DC;&#x9375;&#x5B57; this &#x901A;&#x5E38;&#x88AB;&#x7528;&#x5728;&#x4E00;&#x500B; class &#x5167;&#x90E8;&#xFF0C;this &#x662F;&#x4E00;&#x500B;&#x6307;&#x6A19;&#xFF0C;&#x6307;&#x5411;&#x6B63;&#x5728;&#x88AB;&#x57F7;&#x884C;&#x7684; class &#x7684;&#x7269;&#x4EF6;&#xFF0C;this &#x5728;&#x6B64;&#x8655;&#x662F; ConsoleOutput&#x3002; 1kernel-&gt;interrupt-&gt;Schedule(this, ConsoleTime, ConsoleWriteInt); 123/* machine/stats.h */ const int ConsoleTime = 100; /* time to read or write one character */ IntType &#x7D00;&#x9304;&#x9019;&#x500B; interrupt &#x662F;&#x7531;&#x54EA;&#x500B;&#x786C;&#x9AD4;&#x767C;&#x51FA;&#xFF0C;NachOS&#x652F;&#x63F4;&#x516D;&#x7A2E;&#x786C;&#x9AD4;&#x76F8;&#x95DC; interrupt&#x3002; 1234/* machine/interrupt.h */enum IntType { TimerInt, DiskInt, ConsoleWriteInt, ConsoleReadInt, NetworkSendInt, NetworkRecvInt}; writeFileNo &#x7684;&#x503C;&#x5728; console.cc &#x4E2D;&#x88AB; assign &#x70BA; 1&#x3002; 123456789/* machine/console.cc */ConsoleOutput::ConsoleOutput(char *writeFile, CallBackObj *toCall){ if (writeFile == NULL) writeFileNo = 1; else writeFileNo = OpenForWrite(writeFile);} 123/* threads/kernel.cc */synchConsoleOut = new SynchConsoleOutput(consoleOut); 123/* threads/kernel.cc */consoleOut = NULL; 1234567class SynchConsoleOutput : public CallBackObj {private: ConsoleOutput *consoleOutput; /* the hardware display */ Lock *lock; /* only one writer at a time */ Semaphore *waitFor; /* wait for callBack */ void CallBack(); /* called when more data can be written */}; 7. Semaphore::P threads/synch.cc waitFor &#x662F; class Semaphore &#x7684;&#x7269;&#x4EF6;&#x3002; 1waitFor-&gt;P(); 123456789101112/* threads/synch.h */class Semaphore {public: void P(); /* waits until value &gt; 0, then decrement */ void V(); /* increment, waking up a thread waiting in P() if * necessary */private: int value; List&lt;Thread *&gt; *queue; /* threads waiting in P() for the value to be * &gt; 0 */ }; &#x5728; SynchConsole &#x7684;&#x5EFA;&#x69CB;&#x5B50;&#xFF0C;&#x6211;&#x5011;&#x53EF;&#x4EE5;&#x770B;&#x5230; waitFor &#x7684;&#x521D;&#x59CB;&#x503C;&#x662F; 0&#xFF0C;&#x56E0;&#x6B64;&#x7576;&#x7B2C;&#x4E00;&#x500B;&#x8981;&#x8F38;&#x51FA;&#x7684;&#x5B57;&#x5143;&#x9032;&#x5165; Semaphore &#x6642;&#xFF0C;&#x5C31;&#x6703;&#x9032;&#x5165; while &#x8FF4;&#x5708;&#xFF0C;&#x4E26;&#x4E14;&#x9032;&#x5165; Sleep&#xFF0C;&#x7B49;&#x5230;&#x8F38;&#x51FA;&#x5B8C;&#x6210;&#xFF0C;kernel &#x6703;&#x9019;&#x500B; thread &#x52A0;&#x5165; readyList&#xFF0C;&#x4E26;&#x4E14;&#x547C;&#x53EB; CallBack()&#xFF0C;CallBack() &#x6703;&#x547C;&#x53EB; V() &#x8B93; value++&#xFF0C;&#x5728;&#x9019;&#x500B; thread &#x518D;&#x6B21;&#x53D6;&#x5F97;&#x63A7;&#x5236;&#x6B0A;&#x6642;&#xFF0C;value &#x662F; 1&#xFF0C;&#x6240;&#x4EE5;&#x53EF;&#x4EE5;&#x8DF3;&#x51FA; while &#x8FF4;&#x5708;&#xFF0C;&#x6B64;&#x6642; value--&#xFF0C;&#x56E0;&#x6B64;&#x82E5;&#x6709;&#x4E0B;&#x4E00;&#x500B; thread &#x9032;&#x5165; Semaphore&#xFF0C;&#x4ED6;&#x5FC5;&#x9808;&#x91CD;&#x8907;&#x4E0A;&#x8FF0;&#x7684;&#x6D41;&#x7A0B;&#x3002; 12345678910/* threads/synch.cc */void Semaphore::P(){ while (value == 0) { queue-&gt;Append(currentThread); currentThread-&gt;Sleep(FALSE); } value--; } 12345678/* kernel/synchconsole.cc */SynchConsoleOutput::SynchConsoleOutput(char *outputFile){ consoleOutput = new ConsoleOutput(outputFile, this); lock = new Lock(&quot;console out&quot;); waitFor = new Semaphore(&quot;console out&quot;, 0);} 8. Interrupt::Schedule machine/interrupt.cc &#x628A;&#x5F85;&#x767C;&#x751F;&#x7684; interrupt &#x653E;&#x9032; pending&#xFF0C;&#x7576;&#x6392;&#x5B9A;&#x7684;&#x6642;&#x9593;&#x5230;&#x9054;&#x6642;&#x624D;&#x6703;&#x767C;&#x751F;&#x3002; 123456void Interrupt::Schedule(CallBackObj *toCall, int fromNow, IntType type){ int when = kernel-&gt;stats-&gt;totalTicks + fromNow; PendingInterrupt *toOccur = new PendingInterrupt(toCall, when, type); pending-&gt;Insert(toOccur);} 1234class Interrupt {private: SortedList&lt;PendingInterrupt *&gt; *pending; }; &#x7576;&#x6392;&#x5B9A;&#x7684;&#x6642;&#x9593;&#x5230;&#x9054;&#xFF0C;interrupt &#x767C;&#x751F;&#xFF0C;&#x56DE;&#x5831;&#x767C;&#x51FA; interrupt &#x7684;&#x7269;&#x4EF6;&#xFF0C;&#x5373; ConsoleOutput&#xFF0C;&#x8B93;&#x4ED6;&#x9032;&#x884C; interrupt &#x7684;&#x8655;&#x7406;&#x3002; 1PendingInterrupt *toOccur = new PendingInterrupt(toCall, when, type); when &#x662F; interrupt &#x6392;&#x5B9A;&#x8981;&#x767C;&#x751F;&#x7684;&#x6642;&#x9593;&#xFF0C;totalTicks &#x662F;&#x7576;&#x524D;&#x6642;&#x9593;&#xFF0C;fromNow &#x7684;&#x503C;&#x70BA; ConsoleTime&#xFF0C;&#x5373; 100&#x3002; 1int when = kernel-&gt;stats-&gt;totalTicks + fromNow; 9. Machine::Run machine/mipssim.cc Onetick() &#x5C07;&#x7CFB;&#x7D71;&#x6642;&#x9593;&#x63A8;&#x9032;&#x4E00;&#x500B;&#x55AE;&#x4F4D;&#xFF0C;&#x4E26;&#x4E14;&#x6AA2;&#x67E5;&#x662F;&#x5426;&#x6709; interrupt &#x6B63;&#x8981;&#x767C;&#x751F;&#x3002; 123456789void Machine::Run(){ Instruction *instr = new Instruction; kernel-&gt;interrupt-&gt;setStatus(UserMode); for (;;) { OneInstruction(instr); kernel-&gt;interrupt-&gt;OneTick(); }} 10. Interrupt::OneTick machine/interrupt.cc 12345678910111213void Interrupt::OneTick(){ if (status == SystemMode) { stats-&gt;totalTicks += SystemTick; stats-&gt;systemTicks += SystemTick; } else { stats-&gt;totalTicks += UserTick; stats-&gt;userTicks += UserTick; } /* check for pending interrupts */ CheckIfDue(FALSE);} 11. Interrupt::CheckIfDue machine/interrupt.cc &#x5982;&#x679C;&#x6C92;&#x6709;interrupt &#x8981;&#x767C;&#x751F;&#xFF0C;&#x56DE;&#x50B3; false&#xFF0C;&#x82E5;&#x6709; interrupt &#x8981;&#x767C;&#x751F;&#xFF0C;&#x57F7;&#x884C;&#x4E26;&#x4E14;&#x56DE;&#x50B3; true&#xFF0C;&#x82E5; advanceClock &#x70BA; true&#xFF0C;&#x8868;&#x793A;&#x76EE;&#x524D;&#x5DF2;&#x7D93;&#x6C92;&#x6709;&#x4EFB;&#x4F55;&#x6307;&#x4EE4;&#x8981;&#x57F7;&#x884C;&#xFF0C;&#x5247;&#x76F4;&#x63A5;&#x57F7;&#x884C;&#x4E00;&#x500B; interrupt&#x3002; 123456789101112131415161718192021222324252627282930bool Interrupt::CheckIfDue(bool advanceClock){ PendingInterrupt *next; Statistics *stats = kernel-&gt;stats; if (pending-&gt;IsEmpty()) { return FALSE; } next = pending-&gt;Front(); if (next-&gt;when &gt; stats-&gt;totalTicks) { if (!advanceClock) { return FALSE; } else { stats-&gt;idleTicks += (next-&gt;when - stats-&gt;totalTicks); stats-&gt;totalTicks = next-&gt;when; } } inHandler = TRUE; do { next = pending-&gt;RemoveFront(); next-&gt;callOnInterrupt-&gt;CallBack(); delete next; } while(!pending-&gt;IsEmpty() &amp;&amp; (pending-&gt;Front()-&gt;when &lt;= stats-&gt;totalTicks)); inHandler = FALSE; return TRUE;} &#x82E5;&#x76EE;&#x524D;&#x6709;&#x8981;&#x767C;&#x751F;&#x7684; interrupt&#xFF0C;&#x628A; interrupt &#x5F9E; pending &#x4E2D;&#x53D6;&#x51FA;&#xFF0C;&#x547C;&#x53EB;&#x767C;&#x51FA;&#x6B64; interrupt &#x7269;&#x4EF6;&#x7684; callBack()&#xFF0C;&#x5728; interrupt &#x8655;&#x7406;&#x5B8C;&#x4E4B;&#x5F8C;&#xFF0C;&#x56DE;&#x50B3; true&#x3002; 123456do { next = pending-&gt;RemoveFront(); next-&gt;callOnInterrupt-&gt;CallBack(); delete next;} while(!pending-&gt;IsEmpty() &amp;&amp; (pending-&gt;Front()-&gt;when &lt;= stats-&gt;totalTicks)); 12. ConsoleOutput::CallBack machine/console.cc &#x7576;&#x87A2;&#x5E55;&#x8F38;&#x51FA;&#x5B8C;&#x6210;&#xFF0C;ConsoleOutput &#x547C;&#x53EB; SynchConsoleOutput&#x7269;&#x4EF6;&#x7684; callBack()&#x3002; 123456void ConsoleOutput::CallBack() { putBusy = FALSE; kernel-&gt;stats-&gt;numConsoleCharsWritten++; callWhenDone-&gt;CallBack();} consoleOutput &#x7684; callWhenDone &#x662F; SynchConsoleOutput&#x3002; 123456/* machine/console.h */class ConsoleOutput : public CallBackObj {private: CallBackObj *callWhenDone; }; 123456/* machine/console.cc */ConsoleOutput::ConsoleOutput(char *writeFile, CallBackObj *toCall){ callWhenDone = toCall;} 123456/* userprog/synchconsole.cc */SynchConsoleOutput::SynchConsoleOutput(char *outputFile){ consoleOutput = new ConsoleOutput(outputFile, this);} 13. SynchConsoleOutput::CallBack userprog/synchconsole.cc 1234void SynchConsoleOutput::CallBack(){ waitFor-&gt;V();} V() &#x91CB;&#x653E;&#x4E00;&#x500B; semaphore &#x8CC7;&#x6E90;&#xFF0C;&#x4E26;&#x4E14; pop &#x51FA;&#x4E0B;&#x4E00;&#x500B;&#x5728; semaphore.queue &#x7684; thread &#x653E;&#x9032; readyList&#xFF0C;&#x7B49;&#x5230; scheduler &#x5B89;&#x6392;&#x6B64; thread &#x53EF;&#x4EE5;&#x4F7F;&#x7528; CPU &#x6642;&#xFF0C;&#x624D;&#x80FD;&#x8F38;&#x51FA;&#x4E0B;&#x4E00;&#x500B;&#x5B57;&#x5143;&#x3002; 123456789/* threads/synch.cc */void Semaphore::V(){ if (!queue-&gt;IsEmpty()) { kernel-&gt;scheduler-&gt;ReadyToRun(queue-&gt;RemoveFront()); } value++;} Implementation Implement four I/O system calls in NachOS OpenFileId Open(char *name); int Write(char *buffer, int size, OpenFileId id); int Read(char *buffer, int size, OpenFileId id); int Close(OpenFileId id); Open / Close / Read / Write &#x56DB;&#x8005;&#x975E;&#x5E38;&#x50CF;&#xFF0C;&#x56E0;&#x6B64;&#x6211;&#x4EE5; Write &#x70BA;&#x4F8B;&#x5B50;&#x9032;&#x884C;&#x5BE6;&#x4F5C;&#x89E3;&#x8AAA; &#xFF0C;&#x552F;&#x6709;&#x6BD4;&#x8F03;&#x9700;&#x8981;&#x8AAA;&#x660E;&#x7684;&#x90E8;&#x4EFD;&#x6703;&#x5C07; Open / Close / Read &#x4E00;&#x8D77;&#x8AAA;&#x660E;&#x3002; Write userprog/syscall.h 123#define SC_Write 8int Write(char *buffer, int size, OpenFileId id); 1234567891011/* test/start.s */#include &quot;syscall.h&quot; .globl Write .ent WriteWrite: addiu $2,$0,SC_Write syscall j $31 .end Write 1. Machine::OneInstruction machine/mipssim.cc 1234567891011#include &quot;machine.h&quot;#include &quot;mipssim.h&quot;void Machine::OneInstruction(Instruction *instr){ switch (instr-&gt;opCode) { case OP_SYSCALL: RaiseException(SyscallException, 0); return; }} 2. Machine::RaiseException machine/machine.cc 12345678#include &quot;machine.h&quot;void Machine::RaiseException(ExceptionType which, int badVAddr){ kernel-&gt;interrupt-&gt;setStatus(SystemMode); ExceptionHandler(which); kernel-&gt;interrupt-&gt;setStatus(UserMode);} 3. ExceptionHandler userprog/exception.cc &#x4F9D;&#x7167;&#x6211;&#x5011;&#x50B3;&#x5165;&#x53C3;&#x6578;&#x7684;&#x9806;&#x5E8F; (char *buffer, int size, OpenFileId id) &#x4F9D;&#x5E8F;&#x5F9E; register $a0 $a1 $a2&#xFF0C;&#x5373;&#x5F9E; register(4) register(5) register(6) &#x8B80;&#x51FA;&#x547C;&#x53EB; system call Write &#x6642;&#x6240;&#x50B3;&#x5165;&#x7684;&#x53C3;&#x6578;&#x3002;SysWrite &#x6703;&#x56DE;&#x50B3;&#x5BEB;&#x5165;&#x662F;&#x5426;&#x6210;&#x529F;&#x3002;&#x4F9D;&#x7167; MIPS &#x6163;&#x4F8B;&#xFF0C;&#x51FD;&#x5F0F;&#x56DE;&#x50B3;&#x503C;&#x61C9;&#x653E;&#x5728; register $v0&#xFF0C;&#x5373; register(4)&#x3002;&#x5B8C;&#x6210; SysWrite &#x4E4B;&#x5F8C;&#x8981;&#x4FEE;&#x6539; PCReg &#x8B93; PCReg &#x6307;&#x5411;&#x4E0B;&#x4E00;&#x500B;&#x6307;&#x4EE4;&#xFF0C;&#x5982;&#x679C;&#x6C92;&#x6709;&#x52A0;&#x4E0A;&#x9019;&#x4E00;&#x884C;&#x7684;&#x8A71;&#xFF0C;&#x7A0B;&#x5F0F;&#x6703;&#x4E0D;&#x505C;&#x7684;&#x57F7;&#x884C;&#x7576;&#x524D;&#x6307;&#x4EE4;&#x3002; 123456789101112131415161718192021222324#include &quot;syscall.h&quot;#include &quot;ksyscall.h&quot;void ExceptionHandler(ExceptionType which){ int type = kernel-&gt;machine-&gt;ReadRegister(2); case SC_Write: val = kernel-&gt;machine-&gt;ReadRegister(4); char *buffer = &amp;(kernel-&gt;machine-&gt;mainMemory[val]); size = kernel-&gt;machine-&gt;ReadRegister(5); id = kernel-&gt;machine-&gt;ReadRegister(6); status = SysWrite(buffer, size, id); kernel-&gt;machine-&gt;WriteRegister(2, (int) status); kernel-&gt;machine-&gt;WriteRegister(PrevPCReg, kernel-&gt;machine-&gt;ReadRegister(PCReg)); kernel-&gt;machine-&gt;WriteRegister(PCReg, kernel-&gt;machine-&gt;ReadRegister(PCReg) + 4); kernel-&gt;machine-&gt;WriteRegister(NextPCReg, kernel-&gt;machine-&gt;ReadRegister(PCReg)+4); return; ASSERTNOTREACHED(); break;} 4. SysWrite userprog/ksyscall.h 1234int SysWrite(char *buffer, int size, int id){ return kernel-&gt;WriteFile(buffer, size, id);} 5. Kernel::WriteFile machine/interrupt.cc class FileSystem &#x662F; NachOS &#x7684; file system API&#x3002; 1234int Kernel::WriteFile(char *buffer, int size, int id){ return fileSystem-&gt;WriteF(buffer, size, id);} 6. Filesystem::WriteF filesys/filesys.h 123456789#ifdef FILESYS_STUB class FileSystem { int WriteF(char *buffer, int size, int id) { int status = WriteFile(id, buffer, size); return status; }} 7_1. WriteFile lib/sysdep.cc class FileSystem &#x662F; NachOS &#x7684;&#x6A94;&#x6848;&#x7CFB;&#x7D71; API&#xFF0C;&#x7531;&#x65BC;&#x76EE;&#x524D;&#x7684;&#x6A94;&#x6848;&#x7CFB;&#x7D71;&#x662F;&#x4F9D;&#x8CF4; linux &#x7684;&#x6A94;&#x6848;&#x7CFB;&#x7D71;&#xFF0C;system call Write &#x7684;&#x5BE6;&#x4F5C;&#x662F;&#x547C;&#x53EB; linux &#x63D0;&#x4F9B;&#x7684; write()&#xFF0C;write() &#x5931;&#x6557;&#x56DE;&#x50B3; -1&#xFF0C;&#x6210;&#x529F;&#x56DE;&#x50B3;&#x6210;&#x529F;&#x5BEB;&#x5165;&#x7684;&#x5B57;&#x5143;&#x6578;&#x3002; 123456int WriteFile(int fd, char *buffer, int nBytes){ int retVal = write(fd, buffer, nBytes); ASSERT(retVal == nBytes); return retVal;} 7_2. OpenForReadWrite lib/sysdep.cc system call Open &#x7684;&#x5BE6;&#x4F5C;&#x662F;&#x547C;&#x53EB; linux &#x63D0;&#x4F9B;&#x7684; open()&#xFF0C;open() &#x5931;&#x6557;&#x56DE;&#x50B3; -1&#xFF0C;&#x6210;&#x529F;&#x56DE;&#x50B3; file description&#x3002;&#x9700;&#x8981;&#x6CE8;&#x610F;&#x7684;&#x662F;&#xFF0C;&#x5982;&#x679C;&#x4F7F;&#x7528; fopen() &#x958B;&#x555F;&#x6A94;&#x6848;&#xFF0C;&#x4ED6;&#x56DE;&#x50B3;&#x7684;&#x662F; FILE*&#xFF0C;&#x662F;&#x4E00;&#x500B;&#x6307;&#x6A19;&#xFF0C;&#x800C; open() &#x56DE;&#x50B3;&#x7684;&#x662F;&#x4E00;&#x500B;&#x6574;&#x6578;&#x3002; 123456int OpenForReadWrite(char *name, bool crashOnError){ int fd = open(name, O_RDWR, 0); ASSERT(!crashOnError || fd &gt;= 0); return fd;} 7_3. Read lib/sysdep.cc system call Read &#x7684;&#x5BE6;&#x4F5C;&#x662F;&#x547C;&#x53EB; linux &#x63D0;&#x4F9B;&#x7684; read()&#xFF0C;read() &#x5931;&#x6557;&#x56DE;&#x50B3; -1&#xFF0C;&#x6210;&#x529F;&#x56DE;&#x50B3;&#x6210;&#x529F;&#x8B80;&#x51FA;&#x7684;&#x5B57;&#x5143;&#x6578;&#x3002; 123456int Read(int fd, char *buffer, int nBytes){ int retVal = read(fd, buffer, nBytes); ASSERT(retVal == nBytes); return retVal;} 7_4. Close lib/sysdep.cc system call Close &#x7684;&#x5BE6;&#x4F5C;&#x662F;&#x547C;&#x53EB; linux &#x63D0;&#x4F9B;&#x7684; read()&#xFF0C;read() &#x5931;&#x6557;&#x56DE;&#x50B3; -1&#xFF0C;&#x6210;&#x529F;&#x56DE;&#x50B3; 0&#x3002; 123456int Close(int fd){ int retVal = close(fd); ASSERT(retVal &gt;= 0); return retVal;} Command Compile / Rebuild NachOS 1234&gt; cd NachOS-4.0_MP1/code/build.linux&gt; make clean&gt; make depend&gt; make Test NachOS 1234&gt; cd NachOS-4.0_MP1/code/test&gt; make clean&gt; make halt&gt; ../build.linux/nachos -e halt Reference [1] shawn2000100/10810CS_342301_OperatingSystem https://github.com/shawn2000100/10810CS_342301_OperatingSystem","categories":[],"tags":[]},{"title":"學期結束了","slug":"學期結束了","date":"2021-06-25T04:13:55.000Z","updated":"2021-07-13T08:56:18.864Z","comments":true,"path":"2021/06/25/學期結束了/","link":"","permalink":"http://example.com/2021/06/25/%E5%AD%B8%E6%9C%9F%E7%B5%90%E6%9D%9F%E4%BA%86/","excerpt":"","text":"&#x5927;&#x6982;&#x516D;&#x500B;&#x5C0F;&#x6642;&#x4E4B;&#x524D;&#x5B8C;&#x6210;&#x4E86;&#x9019;&#x5B78;&#x671F;&#x7684;&#x6700;&#x5F8C;&#x4E00;&#x5834;&#x8003;&#x8A66;&#xFF0C;&#x96D6;&#x7136;&#x660E;&#x5929;&#x9084;&#x6709;&#x4E00;&#x4EFD;&#x5831;&#x544A;&#x548C;&#x4E00;&#x4EFD;&#x88DC;&#x4EA4;&#x7684;&#x4F5C;&#x696D;&#xFF0C;&#x4F46;&#x6211;&#x7684;&#x5FC3;&#x5DF2;&#x7D93;&#x5728;&#x653E;&#x6691;&#x5047;&#x4E86;&#xFF0C;&#x4F5C;&#x696D;&#x4EC0;&#x9EBC;&#x7684;&#x5C31;&#x7B97;&#x4E86;&#x5427;&#x3002;&#x7562;&#x7ADF;&#x662F;&#x5DE5;&#x4F5C;&#x904E;&#x7684;&#x4EBA;&#xFF0C;&#x5C0D;&#x65BC;&#x6691;&#x5047;&#xFF0C;&#x56E0;&#x70BA;&#x66FE;&#x7D93;&#x5931;&#x53BB;&#x904E;&#x6240;&#x4EE5;&#x66F4;&#x52A0;&#x73CD;&#x8CB4;&#x3002;&#x5B78;&#x671F;&#x9593;&#x5C31;&#x6709;&#x6162;&#x6162;&#x5728;&#x60F3;&#x6691;&#x5047;&#x8981;&#x505A;&#x4EC0;&#x9EBC;&#xFF0C;&#x7A0B;&#x5F0F;&#x65B9;&#x9762;&#x7684;&#x9032;&#x5EA6;&#x90FD;&#x6703;&#x5728;&#x9019;&#x88E1;&#x66F4;&#x65B0;&#x7684;&#x3002;&#x4F46;&#x662F;&#x590F;&#x5929;&#xFF0C;&#x9664;&#x4E86;&#x5BEB;&#x7A0B;&#x5F0F;&#xFF0C;&#x9084;&#x662F;&#x5F97;&#x8981;&#x51FA;&#x53BB;&#x73A9;&#x7684;&#x5427;&#xFF0C;&#x8AB0;&#x77E5;&#x9053;&#x75AB;&#x60C5;&#x7A81;&#x7136;&#x8B8A;&#x5F97;&#x56B4;&#x91CD;&#xFF0C;&#x5230;&#x5E95;&#x6691;&#x5047;&#x7D50;&#x675F;&#x524D;&#x80FD;&#x4E0D;&#x80FD;&#x53BB;&#x6C99;&#x7058;&#x5462;&#xFF0C;&#x5BE6;&#x5728;&#x597D;&#x60F3;&#x53BB;&#x6C99;&#x7058;&#x5440;&#x3002;","categories":[],"tags":[]},{"title":"跨系推甄北科資工所","slug":"跨系推甄北科資工所","date":"2020-12-04T10:23:50.000Z","updated":"2021-07-27T18:24:28.170Z","comments":true,"path":"2020/12/04/跨系推甄北科資工所/","link":"","permalink":"http://example.com/2020/12/04/%E8%B7%A8%E7%B3%BB%E6%8E%A8%E7%94%84%E5%8C%97%E7%A7%91%E8%B3%87%E5%B7%A5%E6%89%80/","excerpt":"","text":"&#x63A8;&#x7504;&#x8CC7;&#x5DE5;&#x6240; &#x78A9;&#x4E8C;&#x4E0A;&#x539F;&#x672C;&#x662F;&#x61C9;&#x8A72;&#x52A0;&#x5FEB;&#x8AD6;&#x6587;&#x9032;&#x5EA6;&#x7684;&#x6642;&#x671F;&#xFF0C;&#x4F46;&#x6211;&#x56E0;&#x4E00;&#x4E9B;&#x4E0D;&#x53EF;&#x6297;&#x529B;&#x56E0;&#x7D20;&#x4F11;&#x5B78;&#x4E86;&#x4E00;&#x500B;&#x5B78;&#x671F;&#xFF0C;&#x4E0D;&#x904E;&#x6211;&#x5F9E;&#x6691;&#x5047;&#x5C31;&#x958B;&#x59CB;&#x6E96;&#x5099;&#x63A8;&#x7504;&#x3002;&#x901A;&#x5E38;&#x8DE8;&#x7CFB;&#x63A8;&#x7504;&#x7684;&#x4EBA;&#x5C31;&#x7B97;&#x6C92;&#x6709;&#x8F14;&#x7CFB;&#x4E5F;&#x6703;&#x5148;&#x53BB;&#x4FEE;&#x4E00;&#x4E9B;&#x4E3B;&#x8981;&#x8AB2;&#x7A0B;&#xFF0C;&#x4F8B;&#x5982;&#x8CC7;&#x6599;&#x7D50;&#x69CB;&#x6F14;&#x7B97;&#x6CD5;&#x7B49;&#x7B49;&#xFF0C;&#x4F46;&#x6211;&#x5B8C;&#x5168;&#x6C92;&#x6709;&#x4FEE;&#x904E;&#x4EFB;&#x4F55;&#x8CC7;&#x5DE5;&#x7CFB;&#x5927;&#x5B78;&#x90E8;&#x8AB2;&#x7A0B;&#xFF0C;&#x6A5F;&#x68B0;&#x7CFB;&#x7562;&#x696D;&#x6642;&#x7CFB;&#x6392;&#x53EA;&#x6709; 70&#xFF05;&#xFF0C;&#x60F3;&#x8981;&#x63A8;&#x6E05;&#x4EA4;&#x986F;&#x7136;&#x6C92;&#x6709;&#x6A5F;&#x6703;&#xFF0C;&#x56E0;&#x70BA;&#x6709;&#x56DE;&#x53F0;&#x5317;&#x7684;&#x6025;&#x8FEB;&#x9700;&#x8981;&#xFF0C;&#x53EA;&#x7533;&#x8ACB;&#x4E86;&#x4E2D;&#x592E;&#x548C;&#x53F0;&#x79D1;&#x548C;&#x5317;&#x79D1;&#x7684;&#x8CC7;&#x5DE5;&#x6240;&#xFF0C;&#x4E2D;&#x592E;&#x548C;&#x53F0;&#x79D1;&#x6C92;&#x6709;&#x904E;&#x66F8;&#x5BE9;&#xFF0C;&#x5317;&#x79D1;&#x6B63;&#x53D6;&#x3002; &#x5317;&#x79D1;&#x8CC7;&#x5DE5;&#x9762;&#x8A66; &#x5317;&#x79D1;&#x8CC7;&#x5DE5;&#x5206;&#x6210;&#x7532;&#x7D44;&#x548C;&#x4E59;&#x7D44;&#xFF0C;&#x4E59;&#x7D44;&#x540D;&#x984D;&#x6BD4;&#x8F03;&#x5C11;&#xFF0C;&#x662F;&#x958B;&#x7D66;&#x975E;&#x672C;&#x79D1;&#x5B78;&#x751F;&#x7684;&#x7D44;&#x5225;&#x3002;&#x9762;&#x8A66;&#x5206;&#x6210;&#x4E09;&#x95DC;&#xFF0C;&#x5404;&#x4E00;&#x4F4D;&#x6559;&#x6388;&#x3002;&#x7B2C;&#x4E00;&#x95DC;&#x662F;&#x81EA;&#x6211;&#x4ECB;&#x7D39;&#xFF0C;&#x7B2C;&#x4E8C;&#x95DC;&#x662F;&#x82F1;&#x6587;&#xFF0C;&#x4E00;&#x5F35;&#x82F1;&#x6587;&#x7684;&#x6388;&#x8AB2;&#x5927;&#x7DB1;&#x8B93;&#x4F60;&#x7FFB;&#x8B6F;&#xFF0C;&#x7B2C;&#x4E09;&#x95DC;&#x4E00;&#x9032;&#x53BB;&#x6559;&#x6388;&#x554F;&#x6211;&#xFF0C;&#x77E5;&#x4E0D;&#x77E5;&#x9053;&#x7269;&#x4EF6;&#x5C0E;&#x5411;&#x7684;&#x4E09;&#x5927;&#x7279;&#x6027;&#x662F;&#x4EC0;&#x9EBC;&#xFF0C;&#x6211;&#x60F3;&#x4E86;&#x4E00;&#x4E0B;&#x8AAA;&#x4E0D;&#x77E5;&#x9053;&#xFF0C;&#x63A5;&#x8457;&#x4ED6;&#x5C31;&#x554F;&#x6211;&#x6709;&#x6C92;&#x6709;&#x8CC7;&#x5DE5;&#x76F8;&#x95DC;&#x7684;&#x5DE5;&#x4F5C;&#x7D93;&#x9A57;&#x6216;&#x5C08;&#x984C;&#xFF0C;&#x6211;&#x6709;&#x628A;&#x6211;&#x78A9;&#x4E00;&#x7684;&#x7814;&#x7A76;&#x6210;&#x679C;&#x6574;&#x7406;&#x6210;&#x4E00;&#x4EFD;&#x5C0F;&#x5C08;&#x984C;&#x653E;&#x5728;&#x5099;&#x5BE9;&#x8CC7;&#x6599;&#x88E1;&#xFF0C;&#x6240;&#x4EE5;&#x6211;&#x5C31;&#x7C21;&#x55AE;&#x4ECB;&#x7D39;&#x6211;&#x7684;&#x5C08;&#x984C;&#x5167;&#x5BB9;&#x3002; &#x7D50;&#x8A9E; &#x8DE8;&#x7CFB;&#x7533;&#x8ACB;&#x4E0D;&#x5BB9;&#x6613;&#xFF0C;&#x5982;&#x679C;&#x5C0D;&#x4EC0;&#x9EBC;&#x7CFB;&#x6709;&#x8208;&#x8DA3;&#xFF0C;&#x5C31;&#x53BB;&#x4FEE;&#x4E00;&#x4E9B;&#x4ED6;&#x5011;&#x7684;&#x5FC5;&#x4FEE;&#x8AB2;&#xFF0C;&#x63A8;&#x7504;&#x672C;&#x4F86;&#x5C31;&#x662F;&#x9577;&#x671F;&#x7684;&#x7D2F;&#x7A4D;&#x3002;&#x5927;&#x5B78;&#x7684;&#x6642;&#x5019;&#x4E0D;&#x4E00;&#x5B9A;&#x8981;&#x5F88;&#x8A8D;&#x771F;&#x8B80;&#x66F8;&#xFF0C;&#x4F46;&#x81F3;&#x5C11;&#x8981;&#x597D;&#x597D;&#x627E;&#x8208;&#x8DA3;&#xFF0C;&#x89BA;&#x5F97;&#x81EA;&#x5DF1;&#x958B;&#x59CB;&#x7684;&#x6709;&#x9EDE;&#x665A;&#x3002;","categories":[],"tags":[]},{"title":"清大資工修課紀錄","slug":"清大資工修課紀錄","date":"2020-10-02T09:21:32.000Z","updated":"2021-07-30T17:58:14.999Z","comments":true,"path":"2020/10/02/清大資工修課紀錄/","link":"","permalink":"http://example.com/2020/10/02/%E6%B8%85%E5%A4%A7%E8%B3%87%E5%B7%A5%E4%BF%AE%E8%AA%B2%E7%B4%80%E9%8C%84/","excerpt":"","text":"&#x7B2C;&#x4E00;&#x6B21;&#x4FEE;&#x8CC7;&#x5DE5;&#x7CFB;&#x7684;&#x8AB2; &#x96D6;&#x7136;&#x662F;&#x6A5F;&#x68B0;&#x6240;&#xFF0C;&#x4F46;&#x60F3;&#x5F80;&#x8CC7;&#x5DE5;&#x8D70;&#xFF0C;&#x6240;&#x4EE5;&#x4E5F;&#x4FEE;&#x4E86;&#x4E00;&#x4E9B;&#x8CC7;&#x5DE5;&#x7CFB;&#x7684;&#x8AB2;&#x3002;&#x70BA;&#x4E86;&#x6E4A;&#x8DB3;&#x7562;&#x696D;&#x5B78;&#x5206;&#xFF0C;&#x96D6;&#x7136;&#x77E5;&#x9053;&#x81EA;&#x5DF1;&#x7684;&#x80FD;&#x529B;&#x4E0D;&#x8DB3;&#xFF0C;&#x9084;&#x662F;&#x5F97;&#x8981;&#x4FEE;&#x7814;&#x7A76;&#x6240;&#x7684;&#x8AB2;&#xFF0C;&#x4FEE;&#x5F97;&#x5F88;&#x8F9B;&#x82E6;&#xFF0C;&#x4FEE;&#x5E73;&#x884C;&#x7A0B;&#x5F0F;&#x7684;&#x6642;&#x5019;&#xFF0C;&#x6BCF;&#x5929;&#x90FD;&#x5728;&#x5BEB;&#x4F5C;&#x696D;&#xFF0C;&#x4F46;&#x5B78;&#x671F;&#x7D50;&#x675F;&#x7684;&#x6642;&#x5019;&#xFF0C;&#x9084;&#x662F;&#x89BA;&#x5F97;&#x81EA;&#x5DF1;&#x5B78;&#x5230;&#x5F88;&#x591A;&#x4E86;&#x5462;&#x3002; &#x4E0A;&#x5B78;&#x671F; &#x5E73;&#x884C;&#x7A0B;&#x5F0F; - &#x5468;&#x5FD7;&#x9060; &#x8001;&#x5E2B;&#x5F88;&#x8A8D;&#x771F;&#xFF0C;&#x52A9;&#x6559;&#x4E5F;&#x5F88;&#x8A8D;&#x771F;&#xFF0C;&#x56DB;&#x6B21;&#x4F5C;&#x696D;&#xFF0C;&#x662F; MPI / Pthread / OpenMP / CUDA &#x7684;&#x5BE6;&#x4F5C;&#xFF0C;&#x6BCF;&#x6B21;&#x4F5C;&#x696D;&#x4E4B;&#x524D;&#x6703;&#x5148;&#x6709;&#x4E00;&#x500B; lab &#x8AB2;&#xFF0C;&#x5B78;&#x671F;&#x672B;&#x8981;&#x505A;&#x4E00;&#x500B;&#x5C08;&#x984C;&#xFF0C;&#x6BCF;&#x6B21;&#x4F5C;&#x696D;&#x6211;&#x90FD;&#x8981;&#x5BEB;&#x5169;&#x500B;&#x661F;&#x671F;&#x4EE5;&#x4E0A;&#xFF0C;&#x5168;&#x73ED;&#x8981;&#x7AF6;&#x8CFD;&#xFF0C;&#x4EE5;&#x6548;&#x80FD;&#x5728;&#x73ED;&#x4E0A;&#x7684;&#x767E;&#x5206;&#x6BD4;&#x505A;&#x8A55;&#x5206;&#xFF0C;&#x5927;&#x795E;&#x5F88;&#x591A;&#xFF0C;&#x6211;&#x7E3D;&#x662F;&#x588A;&#x5E95;&#xFF0C;&#x7D66;&#x5206;&#x751C;&#x5EA6;&#x6211;&#x7121;&#x6CD5;&#x8A55;&#x50F9;&#xFF0C;&#x56E0;&#x70BA;&#x9019;&#x9580;&#x8AB2;&#x958B;&#x5B78;&#x7684;&#x6642;&#x5019;&#x6709;&#x5927;&#x7D04;&#x4E94;&#x5341;&#x500B;&#x4EBA;&#xFF0C;&#x5B78;&#x671F;&#x672B;&#x53EA;&#x5269;&#x5927;&#x7D04;&#x4E09;&#x5341;&#x4E94;&#x500B;&#xFF0C;&#x5982;&#x679C;&#x53EF;&#x4EE5;&#x6490;&#x5230;&#x6700;&#x5F8C;&#x5927;&#x6982;&#x90FD;&#x662F;&#x6703;&#x904E;&#xFF0C;&#x524D;&#x63D0;&#x662F;&#x6709;&#x6490;&#x5230;&#x6700;&#x5F8C;&#x3002; &#x4E0B;&#x5B78;&#x671F; &#x96F2;&#x7AEF;&#x8A08;&#x7B97; - &#x674E;&#x54F2;&#x69AE; &#x8001;&#x5E2B;&#x5F88;&#x8A8D;&#x771F;&#xFF0C;&#x7C21;&#x4ECB;&#x4E00;&#x4E9B;&#x96F2;&#x7AEF;&#x904B;&#x7B97;&#x4E0A;&#x7684;&#x6280;&#x8853;&#xFF0C;&#x7B2C;&#x4E00;&#x6B21;&#x4F5C;&#x696D;&#x662F;&#x4F7F;&#x7528; QEMU &#x88DD; Ubuntu &#x865B;&#x64EC;&#x6A5F;&#xFF0C;&#x53E6;&#x5916;&#x5169;&#x6B21;&#x4F5C;&#x696D;&#x90FD;&#x662F;&#x5728;&#x5206;&#x6563;&#x67B6;&#x69CB;&#x4E0A;&#x8A13;&#x7DF4;&#x6A5F;&#x5668;&#x5B78;&#x7FD2;&#x7DB2;&#x8DEF;&#xFF0C;&#x4F5C;&#x696D;&#x4E0D;&#x96E3;&#xFF0C;&#x671F;&#x672B;&#x8981;&#x5831;&#x544A;&#x8AD6;&#x6587;&#xFF0C;&#x671F;&#x672B;&#x8003;&#x53EF;&#x4EE5;&#x9078;&#x64C7;&#x5BE6;&#x4F5C;&#x6216;&#x7D19;&#x7B46; (&#x4F46;&#x8001;&#x5E2B;&#x6709;&#x8AAA;&#x56E0;&#x70BA;&#x9019;&#x5B78;&#x671F;&#x4FEE;&#x7684;&#x4EBA;&#x592A;&#x591A;&#x96FB;&#x8166;&#x8CC7;&#x6E90;&#x6240;&#x4EE5;&#x624D;&#x958B;&#x653E;&#x7D19;&#x7B46;&#x8003;&#x8A66;)&#xFF0C;&#x7D19;&#x7B46;&#x8003;&#x8A66;&#x5F88;&#x7C21;&#x55AE;&#xFF0C;&#x7D66;&#x5206;&#x5F88;&#x751C;&#x3002; &#x4EBA;&#x5DE5;&#x667A;&#x6167;&#x8207;&#x85DD;&#x8853;&#x5C0E;&#x8AD6; - &#x5433;&#x4E2D;&#x6D69; &#x96D6;&#x7136;&#x662F;&#x8CC7;&#x5DE5;&#x7CFB;&#x7684;&#x8AB2;&#x4F46;&#x5167;&#x5BB9;&#x5927;&#x591A;&#x662F;&#x5728;&#x6559;&#x85DD;&#x8853;&#x76F8;&#x95DC;&#xFF0C;&#x6211;&#x767C;&#x73FE;&#x4E8B;&#x60C5;&#x4E0D;&#x592A;&#x5C0D;&#x7684;&#x6642;&#x5019;&#x5DF2;&#x7D93;&#x4F86;&#x4E0D;&#x6025;&#x4E86;&#xFF0C;&#x8001;&#x5E2B;&#x958B;&#x8AB2;&#x662F;&#x5E0C;&#x671B;&#x85DD;&#x8853;&#x7CFB;&#x7684;&#x4EBA;&#x4E5F;&#x4F86;&#x4FEE;&#x8AB2;&#xFF0C;&#x6240;&#x4EE5;&#x5BE6;&#x4F5C;&#x76F8;&#x95DC;&#x975E;&#x5E38;&#x5C11;&#xFF0C;&#x4E09;&#x4EFD;&#x4F5C;&#x696D;&#x90FD;&#x662F;&#x85DD;&#x8853;&#x76F8;&#x95DC;&#x7684;&#x5831;&#x544A;&#xFF0C;&#x5B78;&#x671F;&#x672B;&#x8981;&#x505A;&#x4E00;&#x500B;&#x5C08;&#x984C;&#xFF0C;&#x7D66;&#x5206;&#x5F88;&#x751C;&#x3002; &#x7D50;&#x8A9E; &#x6E05;&#x5927;&#x8CC7;&#x5DE5;&#x597D;&#x8AB2;&#x4E0D;&#x5C11;&#xFF0C;&#x60F3;&#x4FEE;&#x7684;&#x4EBA;&#x4E5F;&#x5F88;&#x591A;&#xFF0C;&#x5C0D;&#x65BC;&#x975E;&#x672C;&#x79D1;&#x5B78;&#x751F;&#xFF0C;&#x8981;&#x6436;&#x5230;&#x8AB2;&#x4E5F;&#x4E0D;&#x5BB9;&#x6613;&#xFF0C;&#x633A;&#x7FA8;&#x6155;&#x8CC7;&#x5DE5;&#x7CFB;&#x7684;&#x5927;&#x5B78;&#x90E8;&#x5B78;&#x751F;&#x53EF;&#x4EE5;&#x6709;&#x56DB;&#x5E74;&#x597D;&#x597D;&#x4FEE;&#x8AB2;&#x4E9B;&#x8AB2;&#x3002;","categories":[],"tags":[]},{"title":"工作兩年辭職準備研究所","slug":"工作兩年辭職準備研究所","date":"2019-03-22T22:02:11.000Z","updated":"2021-07-27T18:24:05.850Z","comments":true,"path":"2019/03/23/工作兩年辭職準備研究所/","link":"","permalink":"http://example.com/2019/03/23/%E5%B7%A5%E4%BD%9C%E5%85%A9%E5%B9%B4%E8%BE%AD%E8%81%B7%E6%BA%96%E5%82%99%E7%A0%94%E7%A9%B6%E6%89%80/","excerpt":"","text":"&#x8FAD;&#x8077;&#x6E96;&#x5099;&#x7814;&#x7A76;&#x6240; &#x6211;&#x5F9E;&#x67D0;&#x56DB;&#x5927;&#x6A5F;&#x68B0;&#x7CFB;&#x7562;&#x696D;&#x5F8C;&#x5C31;&#x53BB;&#x5DE5;&#x4F5C;&#x4E86;&#xFF0C;&#x56E0;&#x70BA;&#x6211;&#x7684;&#x7CFB;&#x6392;&#x53EA;&#x6709; 70% &#x5DE6;&#x53F3;&#xFF0C;&#x4E5F;&#x4E0D;&#x60F3;&#x8981;&#x6E96;&#x5099;&#x8003;&#x8A66;&#xFF0C;&#x7576;&#x6642;&#x6211;&#x5C0D;&#x5FF5;&#x66F8;&#x9019;&#x4EF6;&#x4E8B;&#x60C5;&#x5DF2;&#x7D93;&#x975E;&#x5E38;&#x53AD;&#x5026;&#xFF0C;&#x6211;&#x5C0D;&#x6A5F;&#x68B0;&#x7CFB;&#x4E5F;&#x4E0D;&#x662F;&#x771F;&#x7684;&#x975E;&#x5E38;&#x6709;&#x71B1;&#x5FF1;&#xFF0C;&#x6240;&#x4EE5;&#x5C31;&#x60F3;&#xFF0C;&#x90A3;&#x5C31;&#x51FA;&#x53BB;&#x5DE5;&#x4F5C;&#x5427;&#xFF0C;&#x81F3;&#x5C11;&#x53EF;&#x4EE5;&#x770B;&#x770B;&#x81EA;&#x5DF1;&#x5230;&#x5E95;&#x80FD;&#x4E0D;&#x80FD;&#x7368;&#x7ACB;&#x751F;&#x6D3B;&#xFF0C;&#x7576;&#x6642;&#x4E5F;&#x60F3;&#x597D;&#x518D;&#x904E;&#x4E00;&#x5169;&#x5E74;&#x5982;&#x679C;&#x6539;&#x8B8A;&#x5FC3;&#x610F;&#x60F3;&#x5FF5;&#x7814;&#x7A76;&#x6240;&#x90A3;&#x5C31;&#x53BB;&#x5427;&#x3002; &#x63A8;&#x7504;&#x548C;&#x8003;&#x8A66; &#x6211;&#x5F9E; 2018 &#x5E74;&#x7684;&#x4E09;&#x6708;&#x958B;&#x59CB;&#x6162;&#x6162;&#x7684;&#x8B80;&#x8D77;&#x66F8;&#x4F86;&#xFF0C; &#x4F46;&#x56E0;&#x70BA;&#x662F;&#x908A;&#x4E0A;&#x73ED;&#x908A;&#x5FF5;&#x66F8;&#xFF0C;&#x4E00;&#x5929;&#x5927;&#x7D04;&#x53EA;&#x80FD;&#x5538;&#x5230;&#x5169;&#x500B;&#x5C0F;&#x6642;&#x5DE6;&#x53F3;&#x7684;&#x66F8;&#xFF0C;&#x4E2D;&#x9593;&#x9084;&#x7D93;&#x6B77;&#x7D04;&#x672B;&#x4E00;&#x500B;&#x6708;&#x5E38;&#x5E38;&#x52A0;&#x73ED;&#x7684;&#x65E5;&#x5B50;&#xFF0C; &#x56E0;&#x6B64;&#x9032;&#x5EA6;&#x5B8C;&#x5168;&#x66AB;&#x505C;&#xFF0C;&#x76F4;&#x5230;&#x516D;&#x6708;&#x6642;&#x6C7A;&#x5B9A;&#x63D0;&#x51FA;&#x8FAD;&#x5448;&#xFF0C;&#x4E03;&#x6708;&#x6B63;&#x5F0F;&#x96E2;&#x8077;&#xFF0C;&#x4E4B;&#x5F8C;&#x5C31;&#x5728;&#x88DC;&#x7FD2;&#x73ED;&#x4E0A;&#x4E86;&#x4E00;&#x6691;&#x5047;&#x7684;&#x8AB2;&#xFF0C;&#x7D04;&#x83AB;&#x4E5D;&#x6708;&#x7684;&#x6642;&#x5019;&#x958B;&#x59CB;&#x6E96;&#x5099;&#x63A8;&#x7504;&#xFF0C;&#x63A8;&#x7504;&#x8CC7;&#x6599;&#x5305;&#x542B;&#x81EA;&#x50B3;&#x63A8;&#x85A6;&#x4FE1;&#x90FD;&#x8981;&#x82B1;&#x4E00;&#x5B9A;&#x7684;&#x6642;&#x9593;&#x6E96;&#x5099;&#xFF0C;&#x9304;&#x53D6;&#x4E4B;&#x5F8C;&#x627E;&#x6559;&#x6388;&#x7684;&#x6642;&#x9593;&#x4E5F;&#x9700;&#x8981;&#x4E00;&#x500B;&#x661F;&#x671F;&#x5DE6;&#x53F3;&#xFF0C;&#x6211;&#x4E00;&#x76F4;&#x5F88;&#x64D4;&#x5FC3;&#x5982;&#x679C;&#x6C92;&#x6709;&#x63A8;&#x4E0A;&#x4EFB;&#x4F55;&#x4E00;&#x6240;&#x5B78;&#x6821;&#xFF0C;&#x90A3;&#x6E96;&#x5099;&#x7684;&#x6642;&#x9593;&#x5C31;&#x6D6A;&#x8CBB;&#x6389;&#x4E86;&#xFF0C;&#x4F46;&#x56E0;&#x6211;&#x89BA;&#x5F97;&#x6211;&#x5728;&#x63A8;&#x7504;&#x4E0A;&#x6709;&#x4E00;&#x5B9A;&#x512A;&#x52E2; (&#x5DE5;&#x4F5C;&#x7D93;&#x9A57;)&#xFF0C;&#x6240;&#x4EE5;&#x4E0D;&#x60F3;&#x653E;&#x68C4;&#x9019;&#x500B;&#x7BA1;&#x9053;&#xFF0C;&#x6700;&#x5F8C;&#x6211;&#x5728;&#x5341;&#x4E8C;&#x6708;&#x5099;&#x4E0A;&#x6210;&#x5927;&#xFF0C;&#x4E00;&#x6708;&#x5099;&#x4E0A;&#x4EA4;&#x5927;&#xFF0C;&#x7136;&#x5F8C;&#x53C3;&#x52A0;&#x4E8C;&#x6708;&#x7684;&#x7814;&#x7A76;&#x6240;&#x8003;&#x8A66;&#xFF0C;&#x6E05;&#x5927;&#x7684;&#x8003;&#x8A66;&#x5165;&#x5B78;&#x5176;&#x5BE6;&#x4E5F;&#x662F;&#x63A8;&#x7504;&#x7684;&#x65B9;&#x5F0F; (&#x53EA;&#x662F;&#x8981;&#x8003;&#x4E00;&#x79D1;&#x82F1;&#x6587;)&#xFF0C;&#x53F0;&#x5927;&#x662F;&#x666E;&#x901A;&#x8003;&#x8A66;&#x65B9;&#x5F0F;&#xFF0C;&#x6700;&#x5F8C;&#x9019;&#x5169;&#x9593;&#x90FD;&#x6B63;&#x53D6;&#x4E86;&#x3002;&#x6211;&#x6700;&#x5F8C;&#x6C7A;&#x5B9A;&#x8981;&#x5728;&#x6E05;&#x5927;&#x8B80;&#x78A9;&#x58EB;&#xFF0C;&#x56E0;&#x70BA;&#x6211;&#x5C0D;&#x6E05;&#x5927;&#x7684;&#x5BE6;&#x9A57;&#x5BA4;&#x6BD4;&#x8F03;&#x611F;&#x8208;&#x8DA3;&#x3002; &#x5DE5;&#x4F5C;&#x5169;&#x5E74;&#x518D;&#x5FF5;&#x7814;&#x7A76;&#x6240;&#x6709;&#x4EC0;&#x9EBC;&#x597D;&#x8655; &#x6211;&#x89BA;&#x5F97;&#x73FE;&#x5728;&#x7684;&#x6211;&#x6BD4;&#x5927;&#x56DB;&#x7684;&#x6642;&#x5019;&#x66F4;&#x77E5;&#x9053;&#x81EA;&#x5DF1;&#x60F3;&#x8981;&#x4EC0;&#x9EBC;&#xFF0C;&#x6211;&#x8DDF;&#x7684;&#x5BE6;&#x9A57;&#x5BA4;&#x6709;&#x5F88;&#x5927;&#x90E8;&#x5206;&#x9700;&#x8981;&#x5BEB;&#x7A0B;&#x5F0F;&#xFF0C;&#x6240;&#x4EE5;&#x6211;&#x627E;&#x4E86;&#x597D;&#x5E7E;&#x500B;&#x8CC7;&#x5DE5;&#x80CC;&#x666F;&#x7684;&#x670B;&#x53CB;&#x8AEE;&#x8A62;&#x6211;&#x8981;&#x5982;&#x4F55;&#x5728;&#x6700;&#x77ED;&#x6642;&#x9593;&#x5167;&#x628A;&#x6211;&#x7684;&#x7A0B;&#x5F0F;&#x80FD;&#x529B;&#x62C9;&#x8D77;&#x4F86;&#xFF0C;&#x800C;&#x6211;&#x4E5F;&#x5E0C;&#x671B;&#x53EF;&#x4EE5;&#x8A66;&#x8A66;&#x770B;&#x80FD;&#x4E0D;&#x80FD;&#x8D81;&#x6B64;&#x6A5F;&#x6703;&#x57F9;&#x990A;&#x7A0B;&#x5F0F;&#x80FD;&#x529B;&#x4E4B;&#x5F8C;&#x80FD;&#x671D;&#x8CC7;&#x5DE5;&#x9818;&#x57DF;&#x767C;&#x5C55;&#x3002; &#x56E0;&#x70BA;&#x5DE5;&#x4F5C;&#x904E;&#x7684;&#x95DC;&#x4FC2;&#xFF0C;&#x5BE6;&#x9A57;&#x5BA4;&#x53EF;&#x4EE5;&#x57F9;&#x990A;&#x6211;&#x4EC0;&#x9EBC;&#x80FD;&#x529B;&#x662F;&#x6211;&#x9078;&#x5BE6;&#x9A57;&#x5BA4;&#x7684;&#x7B2C;&#x4E00;&#x6E96;&#x5247;&#xFF0C;&#x56E0;&#x70BA;&#x6211;&#x77E5;&#x9053;&#x6211;&#x7684;&#x80FD;&#x529B;&#x6703;&#x5F71;&#x97FF;&#x6211;&#x7684;&#x4E0B;&#x4E00;&#x4EFD;&#x5DE5;&#x4F5C;&#xFF0C;&#x5B78;&#x6B77;&#x6703;&#x5F71;&#x97FF;&#x4E00;&#x500B;&#x4EBA;&#x7684;&#x7B2C;&#x4E00;&#x4EFD;&#x5DE5;&#x4F5C;&#xFF0C;&#x7B2C;&#x4E00;&#x4EFD;&#x5DE5;&#x4F5C;&#x7684;&#x5167;&#x5BB9;&#x6703;&#x5F71;&#x97FF;&#x7B2C;&#x4E8C;&#x4EFD;&#x5DE5;&#x4F5C;&#xFF0C;&#x4E00;&#x500B;&#x5BE6;&#x9A57;&#x5BA4;&#x6216;&#x4E00;&#x4EFD;&#x5DE5;&#x4F5C;&#xFF0C;&#x5C0D;&#x73FE;&#x5728;&#x7684;&#x6211;&#x4F86;&#x8AAA;&#x6700;&#x91CD;&#x8981;&#x7684;&#x662F;&#x5B83;&#x80FD;&#x8B93;&#x6211;&#x8B8A;&#x6210;&#x66F4;&#x6709;&#x80FD;&#x529B;&#x7684;&#x4EBA;&#xFF0C;&#x5E36;&#x7D66;&#x6211;&#x66F4;&#x597D;&#x7684;&#x6A5F;&#x6703;&#xFF0C;&#x5E36;&#x6211;&#x53BB;&#x66F4;&#x597D;&#x7684;&#x5730;&#x65B9;&#x3002; &#x5DE5;&#x4F5C;&#x5169;&#x5E74;&#x518D;&#x5FF5;&#x7814;&#x7A76;&#x6240;&#x6709;&#x4EC0;&#x9EBC;&#x58DE;&#x8655; &#x6211;&#x8AAA;&#x4E86;&#x9019;&#x9EBC;&#x591A;&#x5148;&#x5DE5;&#x4F5C;&#x518D;&#x5FF5;&#x66F8;&#x7684;&#x597D;&#x8655;&#xFF0C;&#x4F46;&#x4E0D;&#x5728;&#x5927;&#x56DB;&#x61C9;&#x5C46;&#x8003;&#x53D6;&#x7814;&#x7A76;&#x6240;&#x9084;&#x662F;&#x6709;&#x4E00;&#x5B9A;&#x7684;&#x98A8;&#x96AA;&#xFF0C;&#x5C31;&#x662F;&#x4E0D;&#x77E5;&#x9053;&#x5230;&#x5E95;&#x56DE;&#x4E0D;&#x56DE;&#x7684;&#x53BB;&#x5B78;&#x6821;&#xFF0C;&#x597D;&#x5E7E;&#x5E74;&#x6C92;&#x6709;&#x8A8D;&#x771F;&#x5FF5;&#x66F8;&#x4E86;&#xFF0C;&#x63A8;&#x7504;&#x4E0D;&#x78BA;&#x5B9A;&#x63A8;&#x5F97;&#x4E0A;&#xFF0C;&#x8003;&#x8A66;&#x53C8;&#x6015;&#x81EA;&#x5DF1;&#x592A;&#x4E45;&#x6C92;&#x5538;&#x66F8;&#x4E0D;&#x77E5;&#x9053;&#x9084;&#x884C;&#x4E0D;&#x884C;&#xFF0C;&#x9019;&#x534A;&#x5E74;&#x771F;&#x7684;&#x662F;&#x904E;&#x7684;&#x975E;&#x5E38;&#x7126;&#x616E;&#xFF0C;&#x8FAD;&#x6389;&#x5DE5;&#x4F5C;&#x4E4B;&#x5F8C;&#x5C31;&#x4E0D;&#x6703;&#x6BCF;&#x500B;&#x6708;&#x6709;&#x9322;&#x9032;&#x5E33;&#xFF0C;&#x5B58;&#x6B3E;&#x53EA;&#x6703;&#x4E00;&#x76F4;&#x6E1B;&#x5C11;&#xFF0C;&#x64D4;&#x5FC3;&#x534A;&#x5E74;&#x5F8C;&#x6C92;&#x6709;&#x8003;&#x4E0A;&#x56DE;&#x53BB;&#x627E;&#x5DE5;&#x4F5C;&#x6703;&#x627E;&#x4E0D;&#x5230;&#x597D;&#x516C;&#x53F8;&#xFF0C;&#x5C24;&#x5176;&#x6211;&#x5728;&#x88DC;&#x7FD2;&#x73ED;&#x6642;&#x767C;&#x73FE;&#x4F3C;&#x4E4E;&#x6709;&#x4E9B;&#x5B78;&#x751F;&#x662F;&#x6E96;&#x5099;&#x4E00;&#x5E74;&#x5230;&#x4E00;&#x5E74;&#x534A;&#x53BB;&#x8003;&#x8A66;&#xFF0C;&#x800C;&#x6211;&#x53EA;&#x6709;&#x534A;&#x5E74;&#x9084;&#x8981;&#x540C;&#x6642;&#x6E96;&#x5099;&#x63A8;&#x7504;&#xFF0C;&#x4E00;&#x76F4;&#x90FD;&#x5F88;&#x64D4;&#x5FC3;&#x6642;&#x9593;&#x4E0D;&#x5920;&#x3002;&#x5927;&#x7D04;&#x5728;&#x6210;&#x5927;&#x5099;&#x4E0A;&#x5F8C;&#x6211;&#x9677;&#x5165;&#x4E00;&#x6BB5;&#x5F88;&#x7CDF;&#x7684;&#x6642;&#x9593;&#xFF0C;&#x56E0;&#x70BA;&#x6211;&#x6C92;&#x6709;&#x5728;&#x6210;&#x5927;&#x627E;&#x5230;&#x7406;&#x60F3;&#x7684;&#x8001;&#x5E2B;&#xFF0C;&#x4EA4;&#x5927;&#x5728;&#x53EF;&#x80FD;&#x6703;&#x5099;&#x4E0A;&#x7684;&#x908A;&#x7DE3;&#xFF0C;&#x6E05;&#x5927;&#x7684;&#x8003;&#x5165;&#x5165;&#x5B78;&#x4E0D;&#x8003;&#x8A66;&#x53EA;&#x505A;&#x63A8;&#x7504;&#x53EF;&#x662F;&#x6211;&#x5728;&#x6E05;&#x5927;&#x63A8;&#x7504;&#x6642;&#x5DF2;&#x7D93;&#x843D;&#x699C;&#x904E;&#x4E00;&#x6B21;&#xFF0C;&#x518D;&#x4F86;&#x4E00;&#x6B21;&#x96E3;&#x9053;&#x5C31;&#x6703;&#x4E0A;&#x55CE; (&#x7D50;&#x679C;&#x518D;&#x4F86;&#x4E00;&#x6B21;&#x771F;&#x7684;&#x5C31;&#x4E0A;&#x4E86;)&#xFF0C;&#x5F9E;&#x5099;&#x4E0A;&#x6210;&#x5927;&#x5230;&#x5099;&#x4E0A;&#x4EA4;&#x5927;&#x4E2D;&#x9593;&#x7684;&#x9019;&#x6BB5;&#x6642;&#x9593;&#x6211;&#x771F;&#x7684;&#x4E00;&#x76F4;&#x5F88;&#x7126;&#x616E;&#xFF0C;&#x76F4;&#x5230;&#x6211;&#x5728;&#x4EA4;&#x5927;&#x627E;&#x5230;&#x4E86;&#x6211;&#x89BA;&#x5F97;&#x5F88;&#x4E0D;&#x932F;&#x7684;&#x6559;&#x6388;&#xFF0C;&#x6211;&#x624D;&#x6BD4;&#x8F03;&#x6062;&#x5FA9;&#x5E73;&#x5E38;&#x5FC3;&#x7E7C;&#x7E8C;&#x6E96;&#x5099;&#x53F0;&#x5927;&#x7684;&#x8003;&#x8A66;&#x3002; &#x7D50;&#x8A9E; &#x6211;&#x53EF;&#x4EE5;&#x6536;&#x5230;&#x56DB;&#x9593;&#x5927;&#x5B78;&#x7684;&#x9304;&#x53D6;&#x55AE;&#x5F88;&#x5927;&#x4E00;&#x90E8;&#x5206;&#x9084;&#x662F;&#x8981;&#x6B78;&#x529F;&#x6211;&#x4EE5;&#x524D;&#x7684;&#x52AA;&#x529B;&#xFF0C;&#x65BC;&#x63A8;&#x7504;&#x800C;&#x8A00;&#x5927;&#x5B78;&#x6821;&#x540D;&#x7576;&#x7136;&#x662F;&#x91CD;&#x8981;&#x7684;&#xFF0C;&#x5DE5;&#x4F5C;&#x5169;&#x5E74;&#x6211;&#x89BA;&#x5F97;&#x6211;&#x7684;&#x7A4D;&#x6975;&#x5EA6;&#x548C;&#x5C0D;&#x65BC;&#x4EBA;&#x751F;&#x898F;&#x5283;&#x7684;&#x60F3;&#x6CD5;&#x90FD;&#x591A;&#x4E86;&#x5F88;&#x591A;&#xFF0C;&#x6211;&#x89BA;&#x5F97;&#x5148;&#x5DE5;&#x4F5C;&#x4E00;&#x5B9A;&#x662F;&#x6709;&#x5F88;&#x5927;&#x7684;&#x597D;&#x8655;&#xFF0C;&#x4E5F;&#x6216;&#x8A31;&#x4F60;&#x5DE5;&#x4F5C;&#x4E4B;&#x5F8C;&#x624D;&#x767C;&#x73FE;&#x9019;&#x4EFD;&#x5DE5;&#x4F5C;&#x4F60;&#x6839;&#x672C;&#x4E00;&#x9EDE;&#x4E5F;&#x4E0D;&#x559C;&#x6B61;&#xFF0C;&#x90A3;&#x4E5F;&#x5F88;&#x597D;&#xFF0C;&#x53EF;&#x4EE5;&#x5728;&#x9084;&#x5E74;&#x8F15;&#x6642;&#x5C31;&#x60F3;&#x65B9;&#x6CD5;&#x8F49;&#x63DB;&#x5DE5;&#x4F5C;&#x9818;&#x57DF; (&#x7576;&#x7136;&#x5FF5;&#x7814;&#x7A76;&#x6240;&#x4E5F;&#x662F;&#x4E00;&#x7A2E;&#x5F88;&#x597D;&#x7684;&#x8F49;&#x63DB;&#x5DE5;&#x4F5C;&#x9818;&#x57DF;&#x7684;&#x65B9;&#x6CD5;)&#xFF0C;(&#x548C;&#x79D1;&#x7CFB;&#x76F8;&#x95DC;&#x7684;) &#x5DE5;&#x4F5C;&#x7D93;&#x6B77;&#x5C0D;&#x63A8;&#x7504;&#x4F86;&#x8AAA;&#x662F;&#x4E00;&#x500B;&#x5927;&#x5927;&#x7684;&#x52A0;&#x5206;&#x9805;&#xFF0C;&#x4F46;&#x4E0D;&#x8AD6;&#x4EC0;&#x9EBC;&#x65B9;&#x6CD5;&#xFF0C;&#x8FAD;&#x8077;&#x662F;&#x4E00;&#x4EF6;&#x4E0D;&#x53EF;&#x9006;&#x7684;&#x4E8B;&#x60C5;&#xFF0C;&#x591A;&#x5C11;&#x6709;&#x4E00;&#x9EDE;&#x8CED;&#x81EA;&#x5DF1;&#x4E0A;&#x699C;&#x7684;&#x610F;&#x5473;&#x5728;&#xFF0C;&#x9664;&#x4E86;&#x8FAD;&#x8077;&#x4E4B;&#x5916;&#xFF0C;&#x534A;&#x5E74;&#x7684;&#x7A7A;&#x767D;&#x671F;&#x6211;&#x6700;&#x5BB3;&#x6015;&#x7684;&#x4E8B;&#x60C5;&#xFF0C;&#x6240;&#x4EE5;&#x6211;&#x5728;&#x8FAD;&#x8077;&#x4E4B;&#x524D;&#x5DF2;&#x7D93;&#x5728;&#x4E0B;&#x73ED;&#x5F8C;&#x5FF5;&#x66F8;&#xFF0C;&#x628A;&#x81EA;&#x5DF1;&#x5C0D;&#x5FF5;&#x66F8;&#x9019;&#x4EF6;&#x4E8B;&#x60C5;&#x7684;&#x719F;&#x6089;&#x611F;&#x627E;&#x56DE;&#x4F86;&#xFF0C;&#x7576;&#x6211;&#x6B63;&#x5F0F;&#x63D0;&#x51FA;&#x8FAD;&#x8077;&#x6642;&#x6211;&#x7684;&#x4E0A;&#x53F8;&#x9084;&#x554F;&#x6211;&#x8981;&#x4E0D;&#x8981;&#x518D;&#x8003;&#x616E;&#x4E00;&#x4E0B;&#x4E0D;&#x8981;&#x885D;&#x52D5;&#x8FAD;&#x8077;&#xFF0C;&#x4F46;&#x90A3;&#x6642;&#x5019;&#x5176;&#x5BE6;&#x6211;&#x5DF2;&#x7D93;&#x505A;&#x597D;&#x6C7A;&#x5B9A;&#x5F88;&#x4E45;&#x4E86;&#xFF0C;&#x6240;&#x4EE5;&#x975E;&#x5E38;&#x5805;&#x5B9A;&#x7684;&#x8FAD;&#x8077;&#x4E86;&#x3002;","categories":[],"tags":[]}],"categories":[{"name":"生活","slug":"生活","permalink":"http://example.com/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://example.com/tags/%E7%94%9F%E6%B4%BB/"}]}